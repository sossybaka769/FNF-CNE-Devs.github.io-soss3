<?xml version='1.0' encoding='utf-8'?>
<haxe><class path="funkin.backend.system.Main" params="" file="source/funkin/backend/system/Main.hx">
		<extends path="openfl.display.Sprite"/>
		<releaseCycle final="1" public="1" set="null" expr="&quot;Beta&quot;" line="32" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"Beta"</e></m>
				<m n=":keep"/>
			</meta>
		</releaseCycle>
		<instance public="1" static="1">
			<c path="funkin.backend.system.Main"/>
			<meta><m n=":keep"/></meta>
		</instance>
		<modToLoad public="1" expr="null" line="36" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":keep"/>
			</meta>
		</modToLoad>
		<forceGPUOnlyBitmapsOff public="1" expr="false" line="37" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":keep"/>
			</meta>
		</forceGPUOnlyBitmapsOff>
		<noTerminalColor public="1" expr="false" line="38" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":keep"/>
			</meta>
		</noTerminalColor>
		<scaleMode public="1" static="1">
			<c path="funkin.backend.system.FunkinRatioScaleMode"/>
			<meta><m n=":keep"/></meta>
		</scaleMode>
		<framerateSprite public="1" static="1">
			<c path="funkin.backend.system.framerate.Framerate"/>
			<meta><m n=":keep"/></meta>
		</framerateSprite>
		<game public="1" static="1">
			<c path="funkin.backend.system.FunkinGame"/>
			<meta><m n=":keep"/></meta>
		</game>
		<time public="1" expr="0" line="52" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":keep"/>
			</meta>
		</time>
		<gameThreads public="1" expr="[]" line="57" static="1">
			<c path="Array"><x path="sys.thread.Thread"/></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n=":keep"/>
			</meta>
		</gameThreads>
		<audioDisconnected public="1" expr="false" line="77" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":keep"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</audioDisconnected>
		<changeID public="1" expr="0" line="79" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":keep"/>
			</meta>
		</changeID>
		<pathBack public="1" expr="&quot;../../../../&quot;" line="81" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"../../../../"</e></m>
				<m n=":keep"/>
			</meta>
		</pathBack>
		<startedFromSource public="1" expr="false" line="87" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":keep"/>
			</meta>
		</startedFromSource>
		<__threadCycle expr="0" line="90" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":keep"/>
			</meta>
		</__threadCycle>
		<execAsync public="1" set="method" line="91" static="1">
			<f a="func">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</execAsync>
		<getTimer set="method" line="100" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":keep"/></meta>
		</getTimer>
		<loadGameSettings public="1" set="method" line="104" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</loadGameSettings>
		<refreshAssets public="1" set="method" line="168" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</refreshAssets>
		<initTransition public="1" set="method" line="179" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</initTransition>
		<onStateSwitch set="method" line="190" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</onStateSwitch>
		<onStateSwitchPost set="method" line="194" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</onStateSwitchPost>
		<gameWidth expr="1280">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>1280</e></m>
				<m n=":keep"/>
			</meta>
		</gameWidth>
		<gameHeight expr="720">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>720</e></m>
				<m n=":keep"/>
			</meta>
		</gameHeight>
		<skipSplash expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":keep"/>
			</meta>
		</skipSplash>
		<startFullscreen expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":keep"/>
			</meta>
		</startFullscreen>
		<new public="1" set="method" line="60">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.FlxAnimate" params="" file="source/funkin/backend/FlxAnimate.hx">
		<extends path="flxanimate.FlxAnimate"/>
		<rMatrix expr="new FlxMatrix()" line="12" static="1">
			<c path="flixel.math.FlxMatrix"/>
			<meta><m n=":value"><e>new FlxMatrix()</e></m></meta>
		</rMatrix>
		<drawLimb set="method" line="15" override="1"><f a="limb:_rMatrix:?colorTransform">
	<c path="flixel.graphics.frames.FlxFrame"/>
	<c path="flixel.math.FlxMatrix"/>
	<c path="openfl.geom.ColorTransform"/>
	<x path="Void"/>
</f></drawLimb>
		<limbOnScreen set="method" line="86" override="1"><f a="limb:m:?Camera">
	<c path="flixel.graphics.frames.FlxFrame"/>
	<c path="flixel.math.FlxMatrix"/>
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></limbOnScreen>
		<new public="1" set="method" line="11"><f a="?X:?Y:?Path:?Settings">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Null"><t path="flxanimate.Settings"/></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="funkin.backend.XMLAnimType" params="" file="source/funkin/backend/FunkinSprite.hx" module="funkin.backend.FunkinSprite">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend._FunkinSprite.XMLAnimType_Impl_" params="" file="source/funkin/backend/FunkinSprite.hx" private="1" module="funkin.backend.FunkinSprite" final="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="21" static="1">
		<x path="funkin.backend.XMLAnimType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<BEAT public="1" get="inline" set="null" expr="cast 1" line="22" static="1">
		<x path="funkin.backend.XMLAnimType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BEAT>
	<LOOP public="1" get="inline" set="null" expr="cast 2" line="23" static="1">
		<x path="funkin.backend.XMLAnimType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LOOP>
	<fromString public="1" set="method" line="26" static="1">
		<f a="str:?def" v=":NONE">
			<c path="String"/>
			<x path="funkin.backend.XMLAnimType"/>
			<x path="funkin.backend.XMLAnimType"/>
		</f>
		<meta><m n=":value"><e>{ def : NONE }</e></m></meta>
	</fromString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="funkin.backend._FunkinSprite.XMLAnimType_Impl_" params="" file="source/funkin/backend/FunkinSprite.hx" private="1" module="funkin.backend.FunkinSprite" final="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="21" static="1">
			<x path="funkin.backend.XMLAnimType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<BEAT public="1" get="inline" set="null" expr="cast 1" line="22" static="1">
			<x path="funkin.backend.XMLAnimType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BEAT>
		<LOOP public="1" get="inline" set="null" expr="cast 2" line="23" static="1">
			<x path="funkin.backend.XMLAnimType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LOOP>
		<fromString public="1" set="method" line="26" static="1">
			<f a="str:?def" v=":NONE">
				<c path="String"/>
				<x path="funkin.backend.XMLAnimType"/>
				<x path="funkin.backend.XMLAnimType"/>
			</f>
			<meta><m n=":value"><e>{ def : NONE }</e></m></meta>
		</fromString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="funkin.backend.utils.IXMLEvents" params="" file="source/funkin/backend/utils/XMLUtil.hx" module="funkin.backend.utils.XMLUtil" interface="1">
		<onPropertySet public="1" set="method"><f a="property:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></onPropertySet>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.interfaces.IOffsetCompatible" params="" file="source/funkin/backend/system/interfaces/IOffsetCompatible.hx" interface="1">
		<addOffset public="1" set="method">
			<f a="anim:?x:?y" v=":0:0">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</addOffset>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.interfaces.IBeatReceiver" params="" file="source/funkin/backend/system/interfaces/IBeatReceiver.hx" interface="1">
		<measureHit public="1" set="method"><f a="curMeasure">
	<x path="Int"/>
	<x path="Void"/>
</f></measureHit>
		<beatHit public="1" set="method"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method"><f a="curStep">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.FunkinSprite" params="" file="source/funkin/backend/FunkinSprite.hx">
		<extends path="flixel.addons.effects.FlxSkewedSprite"/>
		<implements path="funkin.backend.utils.IXMLEvents"/>
		<implements path="funkin.backend.system.interfaces.IOffsetCompatible"/>
		<implements path="funkin.backend.system.interfaces.IBeatReceiver"/>
		<copyFrom public="1" set="method" line="76" static="1"><f a="source">
	<c path="funkin.backend.FunkinSprite"/>
	<c path="funkin.backend.FunkinSprite"/>
</f></copyFrom>
		<__oldScrollFactor expr="new FlxPoint()" line="256" static="1">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</__oldScrollFactor>
		<__oldScale expr="new FlxPoint()" line="257" static="1">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</__oldScale>
		<extra public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</extra>
		<spriteAnimType public="1" expr="NONE">
			<x path="funkin.backend.XMLAnimType"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
		</spriteAnimType>
		<beatAnims public="1" expr="[]">
			<c path="Array"><t path="funkin.backend.utils.BeatAnim"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</beatAnims>
		<name public="1"><c path="String"/></name>
		<zoomFactor public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</zoomFactor>
		<initialZoom public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</initialZoom>
		<debugMode public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</debugMode>
		<animDatas public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<t path="funkin.backend.utils.AnimData"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</animDatas>
		<beatInterval public="1" set="accessor" expr="2">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
			<haxe_doc>* ODD interval -&gt; asynced; EVEN interval -&gt; synced</haxe_doc>
		</beatInterval>
		<beatOffset public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</beatOffset>
		<skipNegativeBeats public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skipNegativeBeats>
		<animateAtlas public="1"><c path="funkin.backend.FlxAnimate"/></animateAtlas>
		<atlasPlayingAnim public="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</atlasPlayingAnim>
		<atlasPath public="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</atlasPath>
		<update public="1" set="method" line="98" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<loadSprite public="1" set="method" line="112">
			<f a="path:?Unique:?Key" v=":false:null">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Key : null, Unique : false }</e></m></meta>
		</loadSprite>
		<onPropertySet public="1" set="method" line="125"><f a="property:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></onPropertySet>
		<countedBeat expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</countedBeat>
		<beatHit public="1" set="method" line="132"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method" line="144"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<measureHit public="1" set="method" line="148"><f a="curMeasure">
	<x path="Int"/>
	<x path="Void"/>
</f></measureHit>
		<getScreenBounds public="1" set="method" line="152" override="1"><f a="?newRect:?camera">
	<c path="flixel.math.FlxRect"/>
	<c path="flixel.FlxCamera"/>
	<c path="flixel.math.FlxRect"/>
</f></getScreenBounds>
		<drawComplex public="1" set="method" line="160" override="1"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></drawComplex>
		<doAdditionalMatrixStuff public="1" set="method" line="165" override="1"><f a="matrix:camera">
	<c path="flixel.math.FlxMatrix"/>
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></doAdditionalMatrixStuff>
		<getScreenPosition public="1" set="method" line="176" override="1"><f a="?point:?Camera">
	<x path="flixel.math.FlxPoint"/>
	<c path="flixel.FlxCamera"/>
	<x path="flixel.math.FlxPoint"/>
</f></getScreenPosition>
		<draw public="1" set="method" line="197" override="1"><f a=""><x path="Void"/></f></draw>
		<copyAtlasValues public="1" set="method" line="210"><f a=""><x path="Void"/></f></copyAtlasValues>
		<destroy public="1" set="method" line="235" override="1"><f a=""><x path="Void"/></f></destroy>
		<__shouldDoScaleProcedure get="inline" set="null" line="254"><f a=""><x path="Bool"/></f></__shouldDoScaleProcedure>
		<__skipZoomProcedure expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__skipZoomProcedure>
		<__doPreZoomScaleProcedure set="method" line="261"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></__doPreZoomScaleProcedure>
		<__doPostZoomScaleProcedure set="method" line="272"><f a=""><x path="Void"/></f></__doPostZoomScaleProcedure>
		<animOffsets public="1" expr="new Map&lt;String,FlxPoint&gt;()">
			<t path="Map">
				<c path="String"/>
				<x path="flixel.math.FlxPoint"/>
			</t>
			<meta><m n=":value"><e>new Map&lt;String,FlxPoint&gt;()</e></m></meta>
		</animOffsets>
		<addOffset public="1" set="method" line="284">
			<f a="name:?x:?y" v=":0:0">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</addOffset>
		<switchOffset public="1" set="method" line="289"><f a="anim1:anim2">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></switchOffset>
		<lastAnimContext public="1" expr="DANCE">
			<x path="funkin.backend.scripting.events.PlayAnimContext"/>
			<meta><m n=":value"><e>DANCE</e></m></meta>
		</lastAnimContext>
		<playAnim public="1" set="method" line="301">
			<f a="AnimName:?Force:?Context:?Reversed:?Frame" v="::NONE:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="funkin.backend.scripting.events.PlayAnimContext"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Frame : 0, Reversed : false, Context : NONE }</e></m></meta>
		</playAnim>
		<getAnim public="1" set="method" line="331"><f a="name">
	<c path="String"/>
	<x path="flixel.util.typeLimit.OneOfTwo">
		<c path="flixel.animation.FlxAnimation"/>
		<c path="flxanimate.animate.FlxSymbolAnimation"/>
	</x>
</f></getAnim>
		<getAnimOffset public="1" get="inline" set="null" line="338"><f a="name">
	<c path="String"/>
	<x path="Null"><x path="flixel.math.FlxPoint"/></x>
</f></getAnimOffset>
		<hasAnimation public="1" get="inline" set="null" line="344"><f a="AnimName">
	<c path="String"/>
	<x path="Bool"/>
</f></hasAnimation>
		<getAnimName public="1" get="inline" set="null" line="349"><f a=""><c path="String"/></f></getAnimName>
		<isAnimReversed public="1" get="inline" set="null" line="363"><f a=""><x path="Bool"/></f></isAnimReversed>
		<removeAnimation public="1" get="inline" set="null" line="367"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeAnimation>
		<getNameList public="1" get="inline" set="null" line="374"><f a=""><c path="Array"><c path="String"/></c></f></getNameList>
		<stopAnimation public="1" get="inline" set="null" line="381"><f a=""><x path="Void"/></f></stopAnimation>
		<isAnimFinished public="1" get="inline" set="null" line="389"><f a=""><x path="Bool"/></f></isAnimFinished>
		<isAnimAtEnd public="1" get="inline" set="null" line="393"><f a=""><x path="Bool"/></f></isAnimAtEnd>
		<set_beatInterval set="method" line="400">
			<f a="v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_beatInterval>
		<new public="1" set="method" line="60">
			<f a="?X:?Y:?SimpleGraphic" v="0:0:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Null"><t path="flixel.system.FlxGraphicAsset"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.FunkinText" params="" file="source/funkin/backend/FunkinText.hx">
		<extends path="flixel.text.FlxText"/>
		<new public="1" set="method" line="7">
			<f a="?X:?Y:?FieldWidth:?Text:?Size:?Border" v="0:0:0::16:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Border : true, Size : 16, FieldWidth : 0, Y : 0, X : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.MusicBeatGroup" params="" file="source/funkin/backend/MusicBeatGroup.hx">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<implements path="funkin.backend.system.interfaces.IBeatReceiver"/>
		<beatHit public="1" set="method" line="6"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method" line="9"><f a="curStep">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<measureHit public="1" set="method" line="12"><f a="curMeasure">
	<x path="Int"/>
	<x path="Void"/>
</f></measureHit>
		<new public="1" set="method" line="5"><f a="?X:?Y:?MaxSize">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.MusicBeatState" params="" file="source/funkin/backend/MusicBeatState.hx">
		<extends path="flixel.FlxState"/>
		<implements path="funkin.backend.system.interfaces.IBeatReceiver"/>
		<skipTransOut public="1" expr="false" line="98" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skipTransOut>
		<skipTransIn public="1" expr="false" line="99" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skipTransIn>
		<lastBeat expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastBeat>
		<lastStep expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastStep>
		<graphicCache public="1" expr="new GraphicCacheSprite()">
			<c path="funkin.backend.system.GraphicCacheSprite"/>
			<meta><m n=":value"><e>new GraphicCacheSprite()</e></m></meta>
			<haxe_doc>* Dummy sprite used to cache graphics to GPU.</haxe_doc>
		</graphicCache>
		<cancelConductorUpdate public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the Conductor auto update should be enabled or not.</haxe_doc>
		</cancelConductorUpdate>
		<curStep public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Current step</haxe_doc>
		</curStep>
		<curBeat public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Current beat</haxe_doc>
		</curBeat>
		<curMeasure public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Current beat</haxe_doc>
		</curMeasure>
		<curStepFloat public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current step, as a `Float` (ex: 4.94, instead of 4)</haxe_doc>
		</curStepFloat>
		<curBeatFloat public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current beat, as a `Float` (ex: 1.24, instead of 1)</haxe_doc>
		</curBeatFloat>
		<curMeasureFloat public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current beat, as a `Float` (ex: 1.24, instead of 1)</haxe_doc>
		</curMeasureFloat>
		<songPos public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current song position (in milliseconds).</haxe_doc>
		</songPos>
		<get_curStep get="inline" set="null" line="60"><f a=""><x path="Int"/></f></get_curStep>
		<get_curBeat get="inline" set="null" line="62"><f a=""><x path="Int"/></f></get_curBeat>
		<get_curMeasure get="inline" set="null" line="64"><f a=""><x path="Int"/></f></get_curMeasure>
		<get_curStepFloat get="inline" set="null" line="66"><f a=""><x path="Float"/></f></get_curStepFloat>
		<get_curBeatFloat get="inline" set="null" line="68"><f a=""><x path="Float"/></f></get_curBeatFloat>
		<get_curMeasureFloat get="inline" set="null" line="70"><f a=""><x path="Float"/></f></get_curMeasureFloat>
		<get_songPos get="inline" set="null" line="72"><f a=""><x path="Float"/></f></get_songPos>
		<controls public="1" get="accessor" set="null">
			<c path="funkin.backend.system.Controls"/>
			<haxe_doc>* Game Controls. (All players / Solo)</haxe_doc>
		</controls>
		<controlsP1 public="1" get="accessor" set="null">
			<c path="funkin.backend.system.Controls"/>
			<haxe_doc>* Game Controls (Player 1 only)</haxe_doc>
		</controlsP1>
		<controlsP2 public="1" get="accessor" set="null">
			<c path="funkin.backend.system.Controls"/>
			<haxe_doc>* Game Controls (Player 2 only)</haxe_doc>
		</controlsP2>
		<stateScripts public="1">
			<c path="funkin.backend.scripting.ScriptPack"/>
			<haxe_doc>* Current injected script attached to the state. To add one, create a file at path "data/states/stateName" (ex: data/states/FreeplayState)</haxe_doc>
		</stateScripts>
		<scriptsAllowed public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</scriptsAllowed>
		<scriptName public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</scriptName>
		<get_controls get="inline" set="null" line="102"><f a=""><c path="funkin.backend.system.Controls"/></f></get_controls>
		<get_controlsP1 get="inline" set="null" line="104"><f a=""><c path="funkin.backend.system.Controls"/></f></get_controlsP1>
		<get_controlsP2 get="inline" set="null" line="106"><f a=""><c path="funkin.backend.system.Controls"/></f></get_controlsP2>
		<loadScript set="method" line="114"><f a=""><x path="Void"/></f></loadScript>
		<tryUpdate public="1" set="method" line="135" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></tryUpdate>
		<create public="1" set="method" line="153" override="1"><f a=""><x path="Void"/></f></create>
		<createPost public="1" set="method" line="160" override="1"><f a=""><x path="Void"/></f></createPost>
		<call public="1" set="method" line="169"><f a="name:?args:?defaultVal">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
	<d/>
</f></call>
		<event public="1" params="T" set="method" line="176"><f a="name:event">
	<c path="String"/>
	<c path="event.T"/>
	<c path="event.T"/>
</f></event>
		<update public="1" set="method" line="183" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<stepHit public="1" set="method" line="194">
			<f a="curStep">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</stepHit>
		<beatHit public="1" set="method" line="200">
			<f a="curBeat">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</beatHit>
		<measureHit public="1" set="method" line="206">
			<f a="curMeasure">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</measureHit>
		<lerp public="1" set="method" line="218">
			<f a="v1:v2:ratio:?fpsSensitive" v=":::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ fpsSensitive : false }</e></m></meta>
			<haxe_doc>* Shortcut to `FlxMath.lerp` or `CoolUtil.lerp`, depending on `fpsSensitive`
	 * @param v1 Value 1
	 * @param v2 Value 2
	 * @param ratio Ratio
	 * @param fpsSensitive Whenever the ratio should not be adjusted to run at the same speed independent of framerate.</haxe_doc>
		</lerp>
		<openSubState public="1" set="method" line="228" override="1">
			<f a="subState">
				<c path="flixel.FlxSubState"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* SCRIPTING STUFF</haxe_doc>
		</openSubState>
		<onResize public="1" set="method" line="234" override="1"><f a="w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<destroy public="1" set="method" line="239" override="1"><f a=""><x path="Void"/></f></destroy>
		<draw public="1" set="method" line="246" override="1"><f a=""><x path="Void"/></f></draw>
		<switchTo public="1" set="method" line="254" override="1"><f a="nextState">
	<c path="flixel.FlxState"/>
	<x path="Bool"/>
</f></switchTo>
		<onFocus public="1" set="method" line="268" override="1"><f a=""><x path="Void"/></f></onFocus>
		<onFocusLost public="1" set="method" line="273" override="1"><f a=""><x path="Void"/></f></onFocusLost>
		<resetSubState public="1" set="method" line="278" override="1"><f a=""><x path="Void"/></f></resetSubState>
		<new public="1" set="method" line="108">
			<f a="?scriptsAllowed:?scriptName" v="true:">
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scriptsAllowed : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.MusicBeatSubstate" params="" file="source/funkin/backend/MusicBeatSubstate.hx">
		<extends path="flixel.FlxSubState"/>
		<implements path="funkin.backend.system.interfaces.IBeatReceiver"/>
		<lastBeat expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastBeat>
		<lastStep expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastStep>
		<curStep public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Current step</haxe_doc>
		</curStep>
		<curBeat public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Current beat</haxe_doc>
		</curBeat>
		<curMeasure public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Current beat</haxe_doc>
		</curMeasure>
		<curStepFloat public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current step, as a `Float` (ex: 4.94, instead of 4)</haxe_doc>
		</curStepFloat>
		<curBeatFloat public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current beat, as a `Float` (ex: 1.24, instead of 1)</haxe_doc>
		</curBeatFloat>
		<curMeasureFloat public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current beat, as a `Float` (ex: 1.24, instead of 1)</haxe_doc>
		</curMeasureFloat>
		<songPos public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current song position (in milliseconds).</haxe_doc>
		</songPos>
		<get_curStep get="inline" set="null" line="49"><f a=""><x path="Int"/></f></get_curStep>
		<get_curBeat get="inline" set="null" line="51"><f a=""><x path="Int"/></f></get_curBeat>
		<get_curMeasure get="inline" set="null" line="53"><f a=""><x path="Int"/></f></get_curMeasure>
		<get_curStepFloat get="inline" set="null" line="55"><f a=""><x path="Float"/></f></get_curStepFloat>
		<get_curBeatFloat get="inline" set="null" line="57"><f a=""><x path="Float"/></f></get_curBeatFloat>
		<get_curMeasureFloat get="inline" set="null" line="59"><f a=""><x path="Float"/></f></get_curMeasureFloat>
		<get_songPos get="inline" set="null" line="61"><f a=""><x path="Float"/></f></get_songPos>
		<stateScripts public="1">
			<c path="funkin.backend.scripting.ScriptPack"/>
			<haxe_doc>* Current injected script attached to the state. To add one, create a file at path "data/states/stateName" (ex: "data/states/PauseMenuSubstate.hx")</haxe_doc>
		</stateScripts>
		<scriptsAllowed public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</scriptsAllowed>
		<scriptName public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</scriptName>
		<controls public="1" get="accessor" set="null">
			<c path="funkin.backend.system.Controls"/>
			<haxe_doc>* Game Controls. (All players / Solo)</haxe_doc>
		</controls>
		<controlsP1 public="1" get="accessor" set="null">
			<c path="funkin.backend.system.Controls"/>
			<haxe_doc>* Game Controls (Player 1 only)</haxe_doc>
		</controlsP1>
		<controlsP2 public="1" get="accessor" set="null">
			<c path="funkin.backend.system.Controls"/>
			<haxe_doc>* Game Controls (Player 2 only)</haxe_doc>
		</controlsP2>
		<get_controls get="inline" set="null" line="88"><f a=""><c path="funkin.backend.system.Controls"/></f></get_controls>
		<get_controlsP1 get="inline" set="null" line="90"><f a=""><c path="funkin.backend.system.Controls"/></f></get_controlsP1>
		<get_controlsP2 get="inline" set="null" line="92"><f a=""><c path="funkin.backend.system.Controls"/></f></get_controlsP2>
		<loadScript set="method" line="101"><f a=""><x path="Void"/></f></loadScript>
		<tryUpdate public="1" set="method" line="122" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></tryUpdate>
		<close public="1" set="method" line="140" override="1"><f a=""><x path="Void"/></f></close>
		<create public="1" set="method" line="149" override="1"><f a=""><x path="Void"/></f></create>
		<createPost public="1" set="method" line="155" override="1"><f a=""><x path="Void"/></f></createPost>
		<call public="1" set="method" line="159"><f a="name:?args:?defaultVal">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
	<d/>
</f></call>
		<event public="1" params="T" set="method" line="166"><f a="name:event">
	<c path="String"/>
	<c path="event.T"/>
	<c path="event.T"/>
</f></event>
		<update public="1" set="method" line="173" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<stepHit public="1" set="method" line="183">
			<f a="curStep">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</stepHit>
		<beatHit public="1" set="method" line="189">
			<f a="curBeat">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</beatHit>
		<measureHit public="1" set="method" line="195">
			<f a="curMeasure">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</measureHit>
		<lerp public="1" set="method" line="207">
			<f a="v1:v2:ratio:?fpsSensitive" v=":::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ fpsSensitive : false }</e></m></meta>
			<haxe_doc>* Shortcut to `FlxMath.lerp` or `CoolUtil.lerp`, depending on `fpsSensitive`
	 * @param v1 Value 1
	 * @param v2 Value 2
	 * @param ratio Ratio
	 * @param fpsSensitive Whenever the ratio should not be adjusted to run at the same speed independent of framerate.</haxe_doc>
		</lerp>
		<openSubState public="1" set="method" line="217" override="1">
			<f a="subState">
				<c path="flixel.FlxSubState"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* SCRIPTING STUFF</haxe_doc>
		</openSubState>
		<onResize public="1" set="method" line="223" override="1"><f a="w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<destroy public="1" set="method" line="228" override="1"><f a=""><x path="Void"/></f></destroy>
		<switchTo public="1" set="method" line="234" override="1"><f a="nextState">
	<c path="flixel.FlxState"/>
	<x path="Bool"/>
</f></switchTo>
		<onFocus public="1" set="method" line="241" override="1"><f a=""><x path="Void"/></f></onFocus>
		<onFocusLost public="1" set="method" line="246" override="1"><f a=""><x path="Void"/></f></onFocusLost>
		<parent public="1"><c path="flixel.FlxState"/></parent>
		<onSubstateOpen public="1" set="method" line="253"><f a=""><x path="Void"/></f></onSubstateOpen>
		<resetSubState public="1" set="method" line="257" override="1"><f a=""><x path="Void"/></f></resetSubState>
		<new public="1" set="method" line="95">
			<f a="?scriptsAllowed:?scriptName" v="true:">
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scriptsAllowed : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.MusicBeatTransition" params="" file="source/funkin/backend/MusicBeatTransition.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<nextFrameSkip expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</nextFrameSkip>
		<transitionTween public="1" expr="null">
			<c path="flixel.tweens.FlxTween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</transitionTween>
		<transitionCamera public="1"><c path="flixel.FlxCamera"/></transitionCamera>
		<newState public="1"><c path="flixel.FlxState"/></newState>
		<blackSpr public="1"><c path="flixel.FlxSprite"/></blackSpr>
		<transitionSprite public="1"><c path="funkin.backend.FunkinSprite"/></transitionSprite>
		<create public="1" set="method" line="21" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="60" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<finish public="1" set="method" line="79"><f a=""><x path="Void"/></f></finish>
		<destroy public="1" set="method" line="85" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="16"><f a="?newState">
	<c path="flixel.FlxState"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.AssetsLibraryList" params="" file="source/funkin/backend/assets/AssetsLibraryList.hx">
		<extends path="lime.utils.AssetLibrary"/>
		<libraries public="1" expr="[]">
			<c path="Array"><c path="lime.utils.AssetLibrary"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</libraries>
		<__defaultLibraries expr="[]">
			<c path="Array"><c path="lime.utils.AssetLibrary"/></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n=":allow"><e>funkin.backend.system.Main</e></m>
				<m n=":allow"><e>funkin.backend.system.MainState</e></m>
			</meta>
		</__defaultLibraries>
		<base public="1"><c path="lime.utils.AssetLibrary"/></base>
		<removeLibrary public="1" set="method" line="14"><f a="lib">
	<c path="lime.utils.AssetLibrary"/>
	<c path="lime.utils.AssetLibrary"/>
</f></removeLibrary>
		<existsSpecific public="1" set="method" line="19">
			<f a="id:type:?source" v="::BOTH">
				<c path="String"/>
				<c path="String"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ source : BOTH }</e></m></meta>
		</existsSpecific>
		<exists public="1" get="inline" set="null" line="30" override="1"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<getSpecificPath public="1" set="method" line="32">
			<f a="id:?source" v=":BOTH">
				<c path="String"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ source : BOTH }</e></m></meta>
		</getSpecificPath>
		<getPath public="1" get="inline" set="null" line="47" override="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<getFiles public="1" set="method" line="49">
			<f a="folder:?source" v=":BOTH">
				<c path="String"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ source : BOTH }</e></m></meta>
		</getFiles>
		<getFolders public="1" set="method" line="73">
			<f a="folder:?source" v=":BOTH">
				<c path="String"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ source : BOTH }</e></m></meta>
		</getFolders>
		<getSpecificAsset public="1" set="method" line="97">
			<f a="id:type:?source" v="::BOTH">
				<c path="String"/>
				<c path="String"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ source : BOTH }</e></m></meta>
		</getSpecificAsset>
		<shouldSkipLib set="method" line="123"><f a="k:source">
	<x path="Int"/>
	<x path="funkin.backend.assets.AssetSource"/>
	<x path="Bool"/>
</f></shouldSkipLib>
		<getAsset public="1" get="inline" set="null" line="131" override="1"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></getAsset>
		<isLocal public="1" set="method" line="133" override="1"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></isLocal>
		<unloadLibraries public="1" set="method" line="145"><f a=""><x path="Void"/></f></unloadLibraries>
		<reset public="1" set="method" line="151"><f a=""><x path="Void"/></f></reset>
		<addLibrary public="1" set="method" line="161"><f a="lib">
	<c path="lime.utils.AssetLibrary"/>
	<c path="lime.utils.AssetLibrary"/>
</f></addLibrary>
		<new public="1" set="method" line="137"><f a="?base">
	<c path="lime.utils.AssetLibrary"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="funkin.backend.assets.AssetSource" params="" file="source/funkin/backend/assets/AssetsLibraryList.hx" module="funkin.backend.assets.AssetsLibraryList">
		<from>
			<icast><x path="Bool"/></icast>
			<icast><x path="Null"><x path="Bool"/></x></icast>
		</from>
		<this><x path="Null"><x path="Bool"/></x></this>
		<to><icast><x path="Null"><x path="Bool"/></x></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.assets._AssetsLibraryList.AssetSource_Impl_" params="" file="source/funkin/backend/assets/AssetsLibraryList.hx" private="1" module="funkin.backend.assets.AssetsLibraryList" extern="1" final="1">
	<SOURCE public="1" get="inline" set="null" expr="cast true" line="168" static="1">
		<x path="funkin.backend.assets.AssetSource"/>
		<meta>
			<m n=":value"><e>cast true</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SOURCE>
	<MODS public="1" get="inline" set="null" expr="cast false" line="169" static="1">
		<x path="funkin.backend.assets.AssetSource"/>
		<meta>
			<m n=":value"><e>cast false</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MODS>
	<BOTH public="1" get="inline" set="null" expr="cast null" line="170" static="1">
		<x path="funkin.backend.assets.AssetSource"/>
		<meta>
			<m n=":value"><e>cast null</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BOTH>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.assets._AssetsLibraryList.AssetSource_Impl_" params="" file="source/funkin/backend/assets/AssetsLibraryList.hx" private="1" module="funkin.backend.assets.AssetsLibraryList" extern="1" final="1">
		<SOURCE public="1" get="inline" set="null" expr="cast true" line="168" static="1">
			<x path="funkin.backend.assets.AssetSource"/>
			<meta>
				<m n=":value"><e>cast true</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SOURCE>
		<MODS public="1" get="inline" set="null" expr="cast false" line="169" static="1">
			<x path="funkin.backend.assets.AssetSource"/>
			<meta>
				<m n=":value"><e>cast false</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MODS>
		<BOTH public="1" get="inline" set="null" expr="cast null" line="170" static="1">
			<x path="funkin.backend.assets.AssetSource"/>
			<meta>
				<m n=":value"><e>cast null</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BOTH>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.backend.assets.IModsAssetLibrary" params="" file="source/funkin/backend/assets/IModsAssetLibrary.hx" interface="1">
		<prefix public="1"><c path="String"/></prefix>
		<modName public="1"><c path="String"/></modName>
		<libName public="1"><c path="String"/></libName>
		<_parsedAsset public="1"><c path="String"/></_parsedAsset>
		<getAssetPath set="method"><f a=""><c path="String"/></f></getAssetPath>
		<__isCacheValid set="method">
			<f a="cache:asset:?isLocal" v="::false">
				<t path="Map">
					<c path="String"/>
					<d/>
				</t>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ isLocal : false }</e></m></meta>
		</__isCacheValid>
		<__parseAsset set="method"><f a="asset">
	<c path="String"/>
	<x path="Bool"/>
</f></__parseAsset>
		<getFiles public="1" set="method"><f a="folder">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getFiles>
		<getFolders public="1" set="method"><f a="folder">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getFolders>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.LimeLibrarySymbol" params="" file="source/funkin/backend/assets/LimeLibrarySymbol.hx">
		<library public="1"><c path="lime.utils.AssetLibrary"/></library>
		<libraryName public="1"><c path="String"/></libraryName>
		<symbolName public="1"><c path="String"/></symbolName>
		<isLocal public="1" get="inline" set="null" line="21"><f a="?type">
	<c path="String"/>
	<x path="Bool"/>
</f></isLocal>
		<exists public="1" get="inline" set="null" line="24"><f a="?type">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<new public="1" get="inline" set="null" line="13"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* COPIED DIRECTLY FROM LIME SOURCE CAUSE LIME IS SO FUCKING DUMB!!</haxe_doc>
	</class>
	<class path="funkin.backend.assets.ModsFolderLibrary" params="" file="source/funkin/backend/assets/ModsFolderLibrary.hx">
		<extends path="lime.utils.AssetLibrary"/>
		<implements path="funkin.backend.assets.IModsAssetLibrary"/>
		<folderPath public="1"><c path="String"/></folderPath>
		<modName public="1"><c path="String"/></modName>
		<libName public="1"><c path="String"/></libName>
		<useImageCache public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</useImageCache>
		<prefix public="1" expr="&quot;assets/&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"assets/"</e></m></meta>
		</prefix>
		<editedTimes expr="[]">
			<t path="Map">
				<c path="String"/>
				<x path="Float"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</editedTimes>
		<_parsedAsset public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_parsedAsset>
		<getEditedTime public="1" set="method" line="40"><f a="asset">
	<c path="String"/>
	<x path="Null"><x path="Float"/></x>
</f></getEditedTime>
		<getAudioBuffer public="1" set="method" line="44" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></getAudioBuffer>
		<getBytes public="1" set="method" line="54" override="1"><f a="id">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></getBytes>
		<getFont public="1" set="method" line="63" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></getFont>
		<getImage public="1" set="method" line="71" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</f></getImage>
		<getPath public="1" set="method" line="81" override="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<getFolders public="1" get="inline" set="null" line="87"><f a="folder">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getFolders>
		<getFiles public="1" get="inline" set="null" line="90"><f a="folder">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getFiles>
		<__getFiles public="1" set="method" line="92">
			<f a="folder:?folders" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ folders : false }</e></m></meta>
		</__getFiles>
		<exists public="1" set="method" line="108" override="1"><f a="asset:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<getAssetPath set="method" line="113"><f a=""><c path="String"/></f></getAssetPath>
		<__isCacheValid set="method" line="117">
			<f a="cache:asset:?isLocalCache" v="::false">
				<t path="Map">
					<c path="String"/>
					<d/>
				</t>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ isLocalCache : false }</e></m></meta>
		</__isCacheValid>
		<__parseAsset set="method" line="138"><f a="asset">
	<c path="String"/>
	<x path="Bool"/>
</f></__parseAsset>
		<new public="1" set="method" line="25"><f a="folderPath:libName:?modName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.ModdableAssetsFolder" params="" file="source/funkin/backend/assets/ModdableAssetsFolder.hx">
		<extends path="funkin.backend.assets.ModsFolderLibrary"/>
		<oldLibrary public="1"><c path="lime.utils.AssetLibrary"/></oldLibrary>
		<exists public="1" set="method" line="12" override="1"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<getAsset public="1" set="method" line="18" override="1"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></getAsset>
		<__parseAsset set="method" line="34" override="1"><f a="asset">
	<c path="String"/>
	<x path="Bool"/>
</f></__parseAsset>
		<new public="1" set="method" line="28"><f a="folder:libName:oldLib">
	<c path="String"/>
	<c path="String"/>
	<c path="lime.utils.AssetLibrary"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Used to prevent crashes</haxe_doc>
	</class>
	<class path="funkin.backend.assets.ModsFolder" params="" file="source/funkin/backend/assets/ModsFolder.hx">
		<onModSwitch public="1" expr="new FlxTypedSignal&lt;String&gt;()" line="29" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>new FlxTypedSignal&lt;String&gt;()</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
			<haxe_doc>* INTERNAL - Only use when editing source mods!!</haxe_doc>
		</onModSwitch>
		<currentModFolder public="1" expr="null" line="34" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Current mod folder. Will affect `Paths`.</haxe_doc>
		</currentModFolder>
		<modsPath public="1" expr="&quot;./mods/&quot;" line="38" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"./mods/"</e></m></meta>
			<haxe_doc>* Path to the `mods` folder.</haxe_doc>
		</modsPath>
		<addonsPath public="1" expr="&quot;./addons/&quot;" line="42" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"./addons/"</e></m></meta>
			<haxe_doc>* Path to the `addons` folder.</haxe_doc>
		</addonsPath>
		<useLibFile public="1" expr="true" line="47" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If accessing a file as assets/data/global/LIB_mymod.hx should redirect to mymod:assets/data/global.hx</haxe_doc>
		</useLibFile>
		<__firstTime expr="true" line="52" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever its the first time mods has been reloaded.</haxe_doc>
		</__firstTime>
		<init public="1" set="method" line="56" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Initialises `mods` folder.</haxe_doc>
		</init>
		<switchMod public="1" set="method" line="65" static="1">
			<f a="mod">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Switches mod - unloads all the other mods, then load this one.
	 * @param libName</haxe_doc>
		</switchMod>
		<reloadMods public="1" set="method" line="70" static="1"><f a=""><x path="Void"/></f></reloadMods>
		<loadModLib public="1" set="method" line="81" static="1">
			<f a="path:?force:?modName" v=":false:">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="openfl.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
			<haxe_doc>* Loads a mod library from the specified path. Supports folders and zips.
	 * @param modName Name of the mod
	 * @param force Whenever the mod should be reloaded if it has already been loaded</haxe_doc>
		</loadModLib>
		<getModsList public="1" set="method" line="93" static="1"><f a=""><c path="Array"><c path="String"/></c></f></getModsList>
		<getLoadedMods public="1" set="method" line="111" static="1"><f a=""><c path="Array"><c path="String"/></c></f></getLoadedMods>
		<prepareLibrary public="1" set="method" line="127" static="1">
			<f a="libName:?force" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="openfl.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</prepareLibrary>
		<registerFont public="1" set="method" line="137" static="1"><f a="font">
	<c path="lime.text.Font"/>
	<c path="lime.text.Font"/>
</f></registerFont>
		<prepareModLibrary public="1" set="method" line="145" static="1">
			<f a="libName:lib:?force" v="::false">
				<c path="String"/>
				<c path="funkin.backend.assets.IModsAssetLibrary"/>
				<x path="Bool"/>
				<c path="openfl.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</prepareModLibrary>
		<loadLibraryFromFolder public="1" set="method" line="154" static="1">
			<f a="libName:folder:?force:?modName" v="::false:">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="openfl.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</loadLibraryFromFolder>
		<loadLibraryFromZip public="1" set="method" line="158" static="1">
			<f a="libName:zipPath:?force:?modName" v="::false:">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="openfl.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</loadLibraryFromZip>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.MultiFramesCollection" params="" file="source/funkin/backend/assets/MultiFramesCollection.hx">
		<extends path="flixel.graphics.frames.FlxFramesCollection"/>
		<findFrame public="1" set="method" line="34" static="1">
			<f a="graphic:?border">
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="flixel.math.FlxPoint"/>
				<c path="funkin.backend.assets.MultiFramesCollection"/>
			</f>
			<haxe_doc>* Returns the `FlxAtlasFrame` of the specified `FlxGraphic` object.
	 *
	 * @param   graphic   `FlxGraphic` object to find the `FlxAtlasFrames` collection for.
	 * @return  `FlxAtlasFrames` collection for the specified `FlxGraphic` object
	 *          Could be `null` if `FlxGraphic` doesn't have it yet.</haxe_doc>
		</findFrame>
		<parentedFrames public="1" expr="[]">
			<c path="Array"><c path="flixel.graphics.frames.FlxFramesCollection"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</parentedFrames>
		<addFrames public="1" set="method" line="47"><f a="collection">
	<c path="flixel.graphics.frames.FlxFramesCollection"/>
	<x path="Void"/>
</f></addFrames>
		<destroy public="1" set="method" line="62" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="21"><f a="parent:?border">
	<c path="flixel.graphics.FlxGraphic"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Base class for all frame collections.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.Paths" params="" file="source/funkin/backend/assets/Paths.hx">
		<SOUND_EXT final="1" public="1" get="inline" set="null" expr="&quot;ogg&quot;" line="24" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ogg"</e></m></meta>
			<haxe_doc>* Preferred sound extension for the game's audio files.
	 * Currently is set to `mp3` for web targets, and `ogg` for other targets.</haxe_doc>
		</SOUND_EXT>
		<assetsTree public="1" static="1"><c path="funkin.backend.assets.AssetsLibraryList"/></assetsTree>
		<tempFramesCache public="1" expr="[]" line="28" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="flixel.graphics.frames.FlxFramesCollection"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</tempFramesCache>
		<init public="1" set="method" line="30" static="1"><f a=""><x path="Void"/></f></init>
		<getPath public="1" get="inline" set="null" line="37" static="1"><f a="file:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<video public="1" get="inline" set="null" line="40" static="1">
			<f a="key:?ext" v=":&quot;mp4&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ ext : "mp4" }</e></m></meta>
		</video>
		<ndll public="1" get="inline" set="null" line="43" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></ndll>
		<file public="1" get="inline" set="null" line="46" static="1"><f a="file:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></file>
		<txt public="1" get="inline" set="null" line="49" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></txt>
		<pack public="1" get="inline" set="null" line="52" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></pack>
		<ini public="1" get="inline" set="null" line="55" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></ini>
		<fragShader public="1" get="inline" set="null" line="58" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></fragShader>
		<vertShader public="1" get="inline" set="null" line="61" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></vertShader>
		<xml public="1" get="inline" set="null" line="64" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></xml>
		<json public="1" get="inline" set="null" line="67" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></json>
		<ps1 public="1" get="inline" set="null" line="70" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></ps1>
		<sound public="1" set="method" line="73" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></sound>
		<soundRandom public="1" get="inline" set="null" line="76" static="1"><f a="key:min:max:?library">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></soundRandom>
		<music public="1" get="inline" set="null" line="79" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></music>
		<voices public="1" get="inline" set="null" line="82" static="1">
			<f a="song:?difficulty:?prefix" v=":&quot;normal&quot;:&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ prefix : "", difficulty : "normal" }</e></m></meta>
		</voices>
		<inst public="1" get="inline" set="null" line="88" static="1">
			<f a="song:?difficulty:?prefix" v=":&quot;normal&quot;:&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ prefix : "", difficulty : "normal" }</e></m></meta>
		</inst>
		<image public="1" set="method" line="94" static="1">
			<f a="key:?library:?checkForAtlas:?ext" v="::false:&quot;png&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ ext : "png", checkForAtlas : false }</e></m></meta>
		</image>
		<script public="1" get="inline" set="null" line="104" static="1">
			<f a="key:?library:?isAssetsPath" v="::false">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ isAssetsPath : false }</e></m></meta>
		</script>
		<chart public="1" set="method" line="120" static="1">
			<f a="song:?difficulty" v=":&quot;normal&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ difficulty : "normal" }</e></m></meta>
		</chart>
		<character public="1" get="inline" set="null" line="128" static="1"><f a="character">
	<c path="String"/>
	<c path="String"/>
</f></character>
		<getFontName public="1" get="inline" set="null" line="137" static="1">
			<f a="font">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets the name of a registered font.
	 * @param font The font's path (if it's already passed as a font name, the same name will be returned)</haxe_doc>
		</getFontName>
		<font public="1" get="inline" set="null" line="142" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></font>
		<obj public="1" get="inline" set="null" line="146" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></obj>
		<dae public="1" get="inline" set="null" line="150" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></dae>
		<md2 public="1" get="inline" set="null" line="154" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></md2>
		<md5 public="1" get="inline" set="null" line="158" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></md5>
		<awd public="1" get="inline" set="null" line="162" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></awd>
		<getSparrowAtlas public="1" get="inline" set="null" line="167" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="flixel.graphics.frames.FlxAtlasFrames"/>
</f></getSparrowAtlas>
		<getSparrowAtlasAlt public="1" get="inline" set="null" line="170" static="1"><f a="key">
	<c path="String"/>
	<c path="flixel.graphics.frames.FlxAtlasFrames"/>
</f></getSparrowAtlasAlt>
		<getPackerAtlas public="1" get="inline" set="null" line="173" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="flixel.graphics.frames.FlxAtlasFrames"/>
</f></getPackerAtlas>
		<getPackerAtlasAlt public="1" get="inline" set="null" line="176" static="1"><f a="key">
	<c path="String"/>
	<c path="flixel.graphics.frames.FlxAtlasFrames"/>
</f></getPackerAtlasAlt>
		<getAsepriteAtlas public="1" get="inline" set="null" line="179" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="flixel.graphics.frames.FlxAtlasFrames"/>
</f></getAsepriteAtlas>
		<getAsepriteAtlasAlt public="1" get="inline" set="null" line="182" static="1"><f a="key">
	<c path="String"/>
	<c path="flixel.graphics.frames.FlxAtlasFrames"/>
</f></getAsepriteAtlasAlt>
		<getAssetsRoot public="1" get="inline" set="null" line="185" static="1"><f a=""><c path="String"/></f></getAssetsRoot>
		<getFrames public="1" set="method" line="192" static="1">
			<f a="key:?assetsPath:?library" v=":false:">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Null"><c path="flixel.graphics.frames.FlxFramesCollection"/></x>
			</f>
			<meta><m n=":value"><e>{ assetsPath : false }</e></m></meta>
			<haxe_doc>* Gets frames at specified path.
	 * @param key Path to the frames
	 * @param library (Additional) library to load the frames from.</haxe_doc>
		</getFrames>
		<loadFrames set="method" line="212" static="1">
			<f a="path:?Unique:?Key:?SkipAtlasCheck" v=":false:null:false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="flixel.graphics.frames.FlxFramesCollection"/>
			</f>
			<meta><m n=":value"><e>{ SkipAtlasCheck : false, Key : null, Unique : false }</e></m></meta>
			<haxe_doc>* Loads frames from a specific image path. Supports Sparrow Atlases, Packer Atlases, and multiple spritesheets.
	 * @param path Path to the image
	 * @param Unique Whenever the image should be unique in the cache
	 * @param Key Key to the image in the cache
	 * @param SkipAtlasCheck Whenever the atlas check should be skipped.
	 * @return FlxFramesCollection Frames</haxe_doc>
		</loadFrames>
		<getFolderDirectories public="1" set="method" line="245" static="1">
			<f a="key:?addPath:?source" v=":false:BOTH">
				<c path="String"/>
				<x path="Bool"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ source : BOTH, addPath : false }</e></m></meta>
		</getFolderDirectories>
		<getFolderContent public="1" set="method" line="254" static="1">
			<f a="key:?addPath:?source" v=":false:BOTH">
				<c path="String"/>
				<x path="Bool"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ source : BOTH, addPath : false }</e></m></meta>
		</getFolderContent>
		<getFilenameFromLibFile public="1" set="method" line="318" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</getFilenameFromLibFile>
		<getLibFromLibFile public="1" set="method" line="326" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</getLibFromLibFile>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.ScriptPathInfo" params="" file="source/funkin/backend/assets/Paths.hx" module="funkin.backend.assets.Paths">
		<file public="1"><c path="String"/></file>
		<library public="1"><c path="lime.utils.AssetLibrary"/></library>
		<new public="1" set="method" line="339"><f a="file:library">
	<c path="String"/>
	<c path="lime.utils.AssetLibrary"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="funkin.backend.assets.ScriptedAssetLibrary" params="" file="source/funkin/backend/assets/ScriptedAssetLibrary.hx">
		<extends path="funkin.backend.assets.ModsFolderLibrary"/>
		<nullValue expr="{ }" line="22" static="1">
			<d/>
			<meta><m n=":value"><e>{ }</e></m></meta>
		</nullValue>
		<script public="1"><c path="funkin.backend.scripting.Script"/></script>
		<scriptName public="1"><c path="String"/></scriptName>
		<getEditedTime public="1" set="method" line="38" override="1"><f a="asset">
	<c path="String"/>
	<x path="Null"><x path="Float"/></x>
</f></getEditedTime>
		<getAudioBuffer public="1" set="method" line="46" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></getAudioBuffer>
		<getBytes public="1" set="method" line="54" override="1"><f a="id">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></getBytes>
		<getFont public="1" set="method" line="62" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></getFont>
		<getImage public="1" set="method" line="70" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</f></getImage>
		<getPath public="1" set="method" line="78" override="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<__getFiles public="1" set="method" line="86" override="1">
			<f a="folder:?folders" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
			</f>
			<meta><m n=":value"><e>{ folders : false }</e></m></meta>
		</__getFiles>
		<exists public="1" set="method" line="94" override="1"><f a="asset:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<getAssetPath set="method" line="102" override="1"><f a=""><x path="Null"><c path="String"/></x></f></getAssetPath>
		<list public="1" set="method" line="110" override="1"><f a="type">
	<c path="String"/>
	<x path="Null"><c path="Array"><c path="String"/></c></x>
</f></list>
		<__isCacheValid set="method" line="118" override="1">
			<f a="cache:asset:?isLocalCache" v="::false">
				<t path="Map">
					<c path="String"/>
					<d/>
				</t>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ isLocalCache : false }</e></m></meta>
		</__isCacheValid>
		<__parseAsset set="method" line="126" override="1"><f a="asset">
	<c path="String"/>
	<x path="Bool"/>
</f></__parseAsset>
		<new public="1" set="method" line="24">
			<f a="scriptName:?args:?folderPath:?libName:?modName" v=":null:&quot;./assets/&quot;:&quot;assets&quot;:">
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ libName : "assets", folderPath : "./assets/", args : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.ZipFolderLibrary" params="" file="source/funkin/backend/assets/ZipFolderLibrary.hx">
		<extends path="lime.utils.AssetLibrary"/>
		<implements path="funkin.backend.assets.IModsAssetLibrary"/>
		<zipPath public="1"><c path="String"/></zipPath>
		<modName public="1"><c path="String"/></modName>
		<libName public="1"><c path="String"/></libName>
		<useImageCache public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</useImageCache>
		<prefix public="1" expr="&quot;assets/&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"assets/"</e></m></meta>
		</prefix>
		<zip public="1"><c path="funkin.backend.utils.SysZip"/></zip>
		<assets public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<t path="funkin.backend.utils.SysZipEntry"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</assets>
		<_parsedAsset public="1"><c path="String"/></_parsedAsset>
		<getAudioBuffer public="1" set="method" line="57" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></getAudioBuffer>
		<getBytes public="1" set="method" line="61" override="1"><f a="id">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></getBytes>
		<getFont public="1" set="method" line="65" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></getFont>
		<getImage public="1" set="method" line="69" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</f></getImage>
		<getPath public="1" set="method" line="74" override="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<unzip public="1" get="inline" set="null" line="82"><f a="f">
	<t path="funkin.backend.utils.SysZipEntry"/>
	<x path="Null"><c path="haxe.io.Bytes"/></x>
</f></unzip>
		<__parseAsset public="1" set="method" line="84"><f a="asset">
	<c path="String"/>
	<x path="Bool"/>
</f></__parseAsset>
		<__isCacheValid public="1" set="method" line="101">
			<f a="cache:asset:?isLocal" v="::false">
				<t path="Map">
					<c path="String"/>
					<d/>
				</t>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ isLocal : false }</e></m></meta>
		</__isCacheValid>
		<exists public="1" set="method" line="106" override="1"><f a="asset:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<getAssetPath set="method" line="112"><f a=""><c path="String"/></f></getAssetPath>
		<getFiles public="1" set="method" line="117"><f a="folder">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getFiles>
		<getFolders public="1" set="method" line="134"><f a="folder">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getFolders>
		<new public="1" set="method" line="38"><f a="zipPath:libName:?modName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.chart.Chart" params="" file="source/funkin/backend/chart/Chart.hx">
		<defaultColor public="1" get="inline" set="null" expr="0xFF9271FD" line="20" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFF9271FD</e></m></meta>
			<haxe_doc>* Default background colors for songs without bg color</haxe_doc>
		</defaultColor>
		<loadEventsJson public="1" set="method" line="22" static="1"><f a="songName">
	<c path="String"/>
	<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
</f></loadEventsJson>
		<loadChartMeta public="1" set="method" line="35" static="1">
			<f a="songName:?difficulty:?fromMods" v=":&quot;normal&quot;:true">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<t path="funkin.backend.chart.ChartMetaData"/>
			</f>
			<meta><m n=":value"><e>{ fromMods : true, difficulty : "normal" }</e></m></meta>
		</loadChartMeta>
		<parse public="1" set="method" line="91" static="1">
			<f a="songName:?difficulty" v=":&quot;normal&quot;">
				<c path="String"/>
				<c path="String"/>
				<t path="funkin.backend.chart.ChartData"/>
			</f>
			<meta><m n=":value"><e>{ difficulty : "normal" }</e></m></meta>
		</parse>
		<addNoteType public="1" set="method" line="176" static="1"><f a="chart:noteTypeName">
	<t path="funkin.backend.chart.ChartData"/>
	<c path="String"/>
	<x path="Int"/>
</f></addNoteType>
		<save public="1" set="method" line="197" static="1">
			<f a="songFolderPath:chart:?difficulty:?saveSettings" v="::&quot;normal&quot;:">
				<c path="String"/>
				<t path="funkin.backend.chart.ChartData"/>
				<c path="String"/>
				<x path="Null"><t path="funkin.backend.chart.ChartSaveSettings"/></x>
				<t path="funkin.backend.chart.ChartData"/>
			</f>
			<meta><m n=":value"><e>{ difficulty : "normal" }</e></m></meta>
			<haxe_doc>* Saves the chart to the specific song folder path.
	 * @param songFolderPath Path to the song folder (ex: `mods/your mod/songs/song/`)
	 * @param chart Chart to save
	 * @param difficulty Name of the difficulty
	 * @param saveSettings
	 * @return Filtered chart used for saving.</haxe_doc>
		</save>
		<filterChartForSaving public="1" set="method" line="224" static="1"><f a="chart:?saveMetaInChart:?saveEventsInChart">
	<t path="funkin.backend.chart.ChartData"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<t path="funkin.backend.chart.ChartData"/>
</f></filterChartForSaving>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.chart.ChartSaveSettings" params="" file="source/funkin/backend/chart/Chart.hx" module="funkin.backend.chart.Chart"><a>
	<saveMetaInChart>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</saveMetaInChart>
	<saveEventsInChart>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</saveEventsInChart>
	<prettyPrint>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</prettyPrint>
	<overrideExistingMeta>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</overrideExistingMeta>
	<folder>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</folder>
</a></typedef>
	<typedef path="funkin.backend.chart.ChartData" params="" file="source/funkin/backend/chart/ChartData.hx"><a>
	<strumLines><c path="Array"><t path="funkin.backend.chart.ChartStrumLine"/></c></strumLines>
	<stage><c path="String"/></stage>
	<scrollSpeed><x path="Float"/></scrollSpeed>
	<noteTypes><c path="Array"><c path="String"/></c></noteTypes>
	<meta><t path="funkin.backend.chart.ChartMetaData"/></meta>
	<fromMods>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</fromMods>
	<events><c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c></events>
	<codenameChart><x path="Bool"/></codenameChart>
</a></typedef>
	<typedef path="funkin.backend.chart.ChartMetaData" params="" file="source/funkin/backend/chart/ChartData.hx" module="funkin.backend.chart.ChartData"><a>
	<stepsPerBeat>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</stepsPerBeat>
	<parsedColor>
		<x path="Null"><x path="flixel.util.FlxColor"/></x>
		<meta><m n=":optional"/></meta>
	</parsedColor>
	<opponentModeAllowed>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</opponentModeAllowed>
	<needsVoices>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</needsVoices>
	<name><c path="String"/></name>
	<icon>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</icon>
	<displayName>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</displayName>
	<difficulties>
		<x path="Null"><c path="Array"><c path="String"/></c></x>
		<meta><m n=":optional"/></meta>
	</difficulties>
	<customValues>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</customValues>
	<coopAllowed>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</coopAllowed>
	<color>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</color>
	<bpm>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</bpm>
	<beatsPerMeasure>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</beatsPerMeasure>
</a></typedef>
	<typedef path="funkin.backend.chart.ChartStrumLine" params="" file="source/funkin/backend/chart/ChartData.hx" module="funkin.backend.chart.ChartData"><a>
	<vocalsSuffix>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</vocalsSuffix>
	<visible>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</visible>
	<type><x path="funkin.backend.chart.ChartStrumLineType"/></type>
	<strumScale>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</strumScale>
	<strumPos>
		<x path="Null"><c path="Array"><x path="Float"/></c></x>
		<meta><m n=":optional"/></meta>
	</strumPos>
	<strumLinePos>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</strumLinePos>
	<scrollSpeed>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</scrollSpeed>
	<position><c path="String"/></position>
	<notes><c path="Array"><t path="funkin.backend.chart.ChartNote"/></c></notes>
	<characters><c path="Array"><c path="String"/></c></characters>
</a></typedef>
	<typedef path="funkin.backend.chart.ChartNote" params="" file="source/funkin/backend/chart/ChartData.hx" module="funkin.backend.chart.ChartData"><a>
	<type><x path="Int"/></type>
	<time><x path="Float"/></time>
	<sLen><x path="Float"/></sLen>
	<id><x path="Int"/></id>
</a></typedef>
	<typedef path="funkin.backend.chart.ChartEvent" params="" file="source/funkin/backend/chart/ChartData.hx" module="funkin.backend.chart.ChartData"><a>
	<time><x path="Float"/></time>
	<params><c path="Array"><d/></c></params>
	<name><c path="String"/></name>
</a></typedef>
	<abstract path="funkin.backend.chart.ChartStrumLineType" params="" file="source/funkin/backend/chart/ChartData.hx" module="funkin.backend.chart.ChartData">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.chart._ChartData.ChartStrumLineType_Impl_" params="" file="source/funkin/backend/chart/ChartData.hx" private="1" module="funkin.backend.chart.ChartData" extern="1" final="1">
	<OPPONENT public="1" get="inline" set="null" expr="cast 0" line="66" static="1">
		<x path="funkin.backend.chart.ChartStrumLineType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* STRUMLINE IS MARKED AS OPPONENT - WILL BE PLAYED BY CPU, OR PLAYED BY PLAYER IF OPPONENT MODE IS ON</haxe_doc>
	</OPPONENT>
	<PLAYER public="1" get="inline" set="null" expr="cast 1" line="70" static="1">
		<x path="funkin.backend.chart.ChartStrumLineType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* STRUMLINE IS MARKED AS PLAYER - WILL BE PLAYED AS PLAYER, OR PLAYED AS CPU IF OPPONENT MODE IS ON</haxe_doc>
	</PLAYER>
	<ADDITIONAL public="1" get="inline" set="null" expr="cast 2" line="74" static="1">
		<x path="funkin.backend.chart.ChartStrumLineType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* STRUMLINE IS MARKED AS ADDITIONAL - WILL BE PLAYED AS CPU EVEN IF OPPONENT MODE IS ENABLED</haxe_doc>
	</ADDITIONAL>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.chart._ChartData.ChartStrumLineType_Impl_" params="" file="source/funkin/backend/chart/ChartData.hx" private="1" module="funkin.backend.chart.ChartData" extern="1" final="1">
		<OPPONENT public="1" get="inline" set="null" expr="cast 0" line="66" static="1">
			<x path="funkin.backend.chart.ChartStrumLineType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* STRUMLINE IS MARKED AS OPPONENT - WILL BE PLAYED BY CPU, OR PLAYED BY PLAYER IF OPPONENT MODE IS ON</haxe_doc>
		</OPPONENT>
		<PLAYER public="1" get="inline" set="null" expr="cast 1" line="70" static="1">
			<x path="funkin.backend.chart.ChartStrumLineType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* STRUMLINE IS MARKED AS PLAYER - WILL BE PLAYED AS PLAYER, OR PLAYED AS CPU IF OPPONENT MODE IS ON</haxe_doc>
		</PLAYER>
		<ADDITIONAL public="1" get="inline" set="null" expr="cast 2" line="74" static="1">
			<x path="funkin.backend.chart.ChartStrumLineType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* STRUMLINE IS MARKED AS ADDITIONAL - WILL BE PLAYED AS CPU EVEN IF OPPONENT MODE IS ENABLED</haxe_doc>
		</ADDITIONAL>
		<meta><m n=":enum"/></meta>
	</class>
	<enum path="funkin.backend.chart.EventParamType" params="" file="source/funkin/backend/chart/EventsData.hx" module="funkin.backend.chart.EventsData">
		<TBool/>
		<TInt a="?min:?max:?step">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Float"/>
		</TInt>
		<TFloat a="?min:?max:?step:?precision">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
		</TFloat>
		<TString/>
		<TStrumLine/>
		<TColorWheel/>
		<TDropDown a="?options"><c path="Array"><c path="String"/></c></TDropDown>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="funkin.backend.chart.EventsData" params="" file="source/funkin/backend/chart/EventsData.hx">
		<defaultEventsList public="1" expr="[&quot;HScript Call&quot;, &quot;Camera Movement&quot;, &quot;Add Camera Zoom&quot;, &quot;Camera Modulo Change&quot;, &quot;Camera Flash&quot;, &quot;BPM Change&quot;, &quot;Scroll Speed Change&quot;, &quot;Alt Animation Toggle&quot;, &quot;Play Animation&quot;]" line="13" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["HScript Call", "Camera Movement", "Add Camera Zoom", "Camera Modulo Change", "Camera Flash", "BPM Change", "Scroll Speed Change", "Alt Animation Toggle", "Play Animation"]</e></m></meta>
		</defaultEventsList>
		<defaultEventsParams public="1" expr="[&quot;HScript Call&quot; =&gt; [{ name : &quot;Function Name&quot;, type : TString, defValue : &quot;myFunc&quot; }, { name : &quot;Function Parameters (String split with commas)&quot;, type : TString, defValue : &quot;&quot; }], &quot;Camera Movement&quot; =&gt; [{ name : &quot;Camera Target&quot;, type : TStrumLine, defValue : 0 }], &quot;Add Camera Zoom&quot; =&gt; [{ name : &quot;Amount&quot;, type : TFloat(-10, 10, 0.01, 2), defValue : 0.05 }, { name : &quot;Camera&quot;, type : TDropDown([&quot;camGame&quot;, &quot;camHUD&quot;]), defValue : &quot;camGame&quot; }], &quot;Camera Modulo Change&quot; =&gt; [{ name : &quot;Modulo Interval (Beats)&quot;, type : TInt(1, 9999999, 1), defValue : 4 }, { name : &quot;Bump Strength&quot;, type : TFloat(0.1, 10, 0.01, 2), defValue : 1 }], &quot;Camera Flash&quot; =&gt; [{ name : &quot;Reversed?&quot;, type : TBool, defValue : false }, { name : &quot;Color&quot;, type : TColorWheel, defValue : &quot;#FFFFFF&quot; }, { name : &quot;Time (Steps)&quot;, type : TFloat(0.25, 9999, 0.25, 2), defValue : 4 }, { name : &quot;Camera&quot;, type : TDropDown([&quot;camGame&quot;, &quot;camHUD&quot;]), defValue : &quot;camHUD&quot; }], &quot;BPM Change&quot; =&gt; [{ name : &quot;Target BPM&quot;, type : TFloat(1), defValue : 100 }], &quot;Scroll Speed Change&quot; =&gt; [{ name : &quot;Tween Speed?&quot;, type : TBool, defValue : true }, { name : &quot;New Speed&quot;, type : TFloat(0.01, 99, 0.01, 2), defValue : 1. }, { name : &quot;Tween Time (Steps)&quot;, type : TFloat(0.25, 9999, 0.25, 2), defValue : 4 }, { name : &quot;Tween Ease (ex: circ, quad, cube)&quot;, type : TDropDown([&quot;linear&quot;, &quot;back&quot;, &quot;bounce&quot;, &quot;circ&quot;, &quot;cube&quot;, &quot;elastic&quot;, &quot;expo&quot;, &quot;quad&quot;, &quot;quart&quot;, &quot;quint&quot;, &quot;sine&quot;, &quot;smoothStep&quot;, &quot;smootherStep&quot;]), defValue : &quot;linear&quot; }, { name : &quot;Tween Type (ex: InOut)&quot;, type : TDropDown([&quot;In&quot;, &quot;Out&quot;, &quot;InOut&quot;]), defValue : &quot;In&quot; }], &quot;Alt Animation Toggle&quot; =&gt; [{ name : &quot;Enable On Sing Poses&quot;, type : TBool, defValue : true }, { name : &quot;Enable On Idle&quot;, type : TBool, defValue : true }, { name : &quot;Strumline&quot;, type : TStrumLine, defValue : 0 }], &quot;Play Animation&quot; =&gt; [{ name : &quot;Character&quot;, type : TStrumLine, defValue : 0 }, { name : &quot;Animation&quot;, type : TString, defValue : &quot;animation&quot; }, { name : &quot;Is forced?&quot;, type : TBool, defValue : true }]]" line="14" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><t path="funkin.backend.chart.EventParamInfo"/></c>
			</t>
			<meta><m n=":value"><e>["HScript Call" =&gt; [{ name : "Function Name", type : TString, defValue : "myFunc" }, { name : "Function Parameters (String split with commas)", type : TString, defValue : "" }], "Camera Movement" =&gt; [{ name : "Camera Target", type : TStrumLine, defValue : 0 }], "Add Camera Zoom" =&gt; [{ name : "Amount", type : TFloat(-10, 10, 0.01, 2), defValue : 0.05 }, { name : "Camera", type : TDropDown(["camGame", "camHUD"]), defValue : "camGame" }], "Camera Modulo Change" =&gt; [{ name : "Modulo Interval (Beats)", type : TInt(1, 9999999, 1), defValue : 4 }, { name : "Bump Strength", type : TFloat(0.1, 10, 0.01, 2), defValue : 1 }], "Camera Flash" =&gt; [{ name : "Reversed?", type : TBool, defValue : false }, { name : "Color", type : TColorWheel, defValue : "#FFFFFF" }, { name : "Time (Steps)", type : TFloat(0.25, 9999, 0.25, 2), defValue : 4 }, { name : "Camera", type : TDropDown(["camGame", "camHUD"]), defValue : "camHUD" }], "BPM Change" =&gt; [{ name : "Target BPM", type : TFloat(1), defValue : 100 }], "Scroll Speed Change" =&gt; [{ name : "Tween Speed?", type : TBool, defValue : true }, { name : "New Speed", type : TFloat(0.01, 99, 0.01, 2), defValue : 1. }, { name : "Tween Time (Steps)", type : TFloat(0.25, 9999, 0.25, 2), defValue : 4 }, { name : "Tween Ease (ex: circ, quad, cube)", type : TDropDown(["linear", "back", "bounce", "circ", "cube", "elastic", "expo", "quad", "quart", "quint", "sine", "smoothStep", "smootherStep"]), defValue : "linear" }, { name : "Tween Type (ex: InOut)", type : TDropDown(["In", "Out", "InOut"]), defValue : "In" }], "Alt Animation Toggle" =&gt; [{ name : "Enable On Sing Poses", type : TBool, defValue : true }, { name : "Enable On Idle", type : TBool, defValue : true }, { name : "Strumline", type : TStrumLine, defValue : 0 }], "Play Animation" =&gt; [{ name : "Character", type : TStrumLine, defValue : 0 }, { name : "Animation", type : TString, defValue : "animation" }, { name : "Is forced?", type : TBool, defValue : true }]]</e></m></meta>
		</defaultEventsParams>
		<eventsList public="1" expr="defaultEventsList.copy()" line="54" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>defaultEventsList.copy()</e></m></meta>
		</eventsList>
		<eventsParams public="1" expr="defaultEventsParams.copy()" line="55" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><t path="funkin.backend.chart.EventParamInfo"/></c>
			</t>
			<meta><m n=":value"><e>defaultEventsParams.copy()</e></m></meta>
		</eventsParams>
		<getEventParams public="1" set="method" line="57" static="1"><f a="name">
	<c path="String"/>
	<c path="Array"><t path="funkin.backend.chart.EventParamInfo"/></c>
</f></getEventParams>
		<reloadEvents public="1" set="method" line="61" static="1"><f a=""><x path="Void"/></f></reloadEvents>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.chart.EventInfo" params="" file="source/funkin/backend/chart/EventsData.hx" module="funkin.backend.chart.EventsData"><a>
	<params><c path="Array"><t path="funkin.backend.chart.EventParamInfo"/></c></params>
	<paramValues><c path="Array"><d/></c></paramValues>
</a></typedef>
	<typedef path="funkin.backend.chart.EventParamInfo" params="" file="source/funkin/backend/chart/EventsData.hx" module="funkin.backend.chart.EventsData"><a>
	<type><e path="funkin.backend.chart.EventParamType"/></type>
	<name><c path="String"/></name>
	<defValue><d/></defValue>
</a></typedef>
	<class path="funkin.backend.chart.FNFLegacyParser" params="" file="source/funkin/backend/chart/FNFLegacyParser.hx">
		<parse public="1" set="method" line="7" static="1"><f a="data:result">
	<d/>
	<t path="funkin.backend.chart.ChartData"/>
	<x path="Void"/>
</f></parse>
		<encode public="1" set="method" line="117" static="1"><f a="chart">
	<t path="funkin.backend.chart.ChartData"/>
	<d/>
</f></encode>
		<__convertToSwagSong public="1" set="method" line="143" static="1">
			<f a="chart">
				<t path="funkin.backend.chart.ChartData"/>
				<t path="funkin.backend.chart.SwagSong"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__convertToSwagSong>
		<__convertToSwagSections public="1" set="method" line="168" static="1">
			<f a="chart">
				<t path="funkin.backend.chart.ChartData"/>
				<c path="Array"><t path="funkin.backend.chart.SwagSection"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__convertToSwagSections>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.chart.SwagSong" params="" file="source/funkin/backend/chart/FNFLegacyParser.hx" module="funkin.backend.chart.FNFLegacyParser"><a>
	<validScore><x path="Bool"/></validScore>
	<stepsPerBeat>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</stepsPerBeat>
	<stage>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</stage>
	<speed><x path="Float"/></speed>
	<song><c path="String"/></song>
	<player2><c path="String"/></player2>
	<player1><c path="String"/></player1>
	<notes><c path="Array"><t path="funkin.backend.chart.SwagSection"/></c></notes>
	<noteTypes>
		<x path="Null"><c path="Array"><c path="String"/></c></x>
		<meta><m n=":optional"/></meta>
	</noteTypes>
	<needsVoices><x path="Bool"/></needsVoices>
	<maxHealth>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</maxHealth>
	<gfVersion>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</gfVersion>
	<gf>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</gf>
	<events>
		<x path="Null"><c path="Array"><d/></c></x>
		<meta><m n=":optional"/></meta>
	</events>
	<bpm><x path="Float"/></bpm>
	<beatsPerMeasure>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</beatsPerMeasure>
</a></typedef>
	<typedef path="funkin.backend.chart.SwagSection" params="" file="source/funkin/backend/chart/FNFLegacyParser.hx" module="funkin.backend.chart.FNFLegacyParser"><a>
	<typeOfSection>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</typeOfSection>
	<sectionNotes><c path="Array"><d/></c></sectionNotes>
	<sectionBeats>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</sectionBeats>
	<mustHitSection><x path="Bool"/></mustHitSection>
	<lengthInSteps><x path="Int"/></lengthInSteps>
	<gfSection>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</gfSection>
	<changeBPM><x path="Bool"/></changeBPM>
	<camTarget>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</camTarget>
	<bpm><x path="Float"/></bpm>
	<altAnim><x path="Null"><x path="Bool"/></x></altAnim>
</a></typedef>
	<class path="funkin.backend.chart.PsychParser" params="" file="source/funkin/backend/chart/PsychParser.hx">
		<ignoreEvents public="1" expr="[&quot;Camera Movement&quot;, &quot;Alt Animation Toggle&quot;, &quot;BPM Change&quot;]" line="10" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["Camera Movement", "Alt Animation Toggle", "BPM Change"]</e></m></meta>
		</ignoreEvents>
		<parse public="1" set="method" line="17" static="1"><f a="data:result">
	<d/>
	<t path="funkin.backend.chart.ChartData"/>
	<x path="Void"/>
</f></parse>
		<encode public="1" set="method" line="19" static="1"><f a="chart">
	<t path="funkin.backend.chart.ChartData"/>
	<d/>
</f></encode>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.Script" params="" file="source/funkin/backend/scripting/Script.hx">
		<extends path="flixel.FlxBasic"/>
		<implements path="flixel.util.IFlxDestroyable"/>
		<staticVariables public="1" expr="[]" line="18" static="1">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Use "static var thing = true;" in hscript to use those!!
	 * are reset every mod switch so once you're done with them make sure to make them null!!</haxe_doc>
		</staticVariables>
		<getDefaultVariables public="1" set="method" line="20" static="1"><f a="?script">
	<c path="funkin.backend.scripting.Script"/>
	<t path="Map">
		<c path="String"/>
		<d/>
	</t>
</f></getDefaultVariables>
		<getDefaultPreprocessors public="1" set="method" line="100" static="1"><f a=""><t path="Map">
	<c path="String"/>
	<d/>
</t></f></getDefaultPreprocessors>
		<scriptExtensions public="1" expr="[&quot;hx&quot;, &quot;hscript&quot;, &quot;hsc&quot;, &quot;hxs&quot;, &quot;pack&quot;, &quot;lua&quot;]" line="111" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["hx", "hscript", "hsc", "hxs", "pack", "lua"]</e></m></meta>
			<haxe_doc>* All available script extensions</haxe_doc>
		</scriptExtensions>
		<curScript public="1" expr="null" line="120" static="1">
			<c path="funkin.backend.scripting.Script"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Currently executing script.</haxe_doc>
		</curScript>
		<create public="1" set="method" line="147" static="1">
			<f a="path">
				<c path="String"/>
				<c path="funkin.backend.scripting.Script"/>
			</f>
			<haxe_doc>* Creates a script from the specified asset path. The language is automatically determined.
	 * @param path Path in assets</haxe_doc>
		</create>
		<fromString public="1" set="method" line="170" static="1">
			<f a="code:path">
				<c path="String"/>
				<c path="String"/>
				<c path="funkin.backend.scripting.Script"/>
			</f>
			<haxe_doc>* Creates a script from the string. The language is determined based on the path.
	 * @param code code
	 * @param path filename</haxe_doc>
		</fromString>
		<fileName public="1">
			<c path="String"/>
			<haxe_doc>* Script name (with extension)</haxe_doc>
		</fileName>
		<extension public="1">
			<c path="String"/>
			<haxe_doc>* Script Extension</haxe_doc>
		</extension>
		<path public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Path to the script.</haxe_doc>
		</path>
		<rawPath expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</rawPath>
		<didLoad expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</didLoad>
		<remappedNames public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</remappedNames>
		<load public="1" set="method" line="209">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Loads the script</haxe_doc>
		</load>
		<setPublicMap public="1" set="method" line="224">
			<f a="map">
				<t path="Map">
					<c path="String"/>
					<d/>
				</t>
				<x path="Void"/>
			</f>
			<haxe_doc>* HSCRIPT ONLY FOR NOW
	 * Sets the "public" variables map for ScriptPack</haxe_doc>
		</setPublicMap>
		<reload public="1" set="method" line="231">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Hot-reloads the script, if possible</haxe_doc>
		</reload>
		<trace public="1" set="method" line="238">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Traces something as this script.</haxe_doc>
		</trace>
		<call public="1" set="method" line="255">
			<f a="func:?parameters">
				<c path="String"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>* Calls the function `func` defined in the script.
	 * @param func Name of the function
	 * @param parameters (Optional) Parameters of the function.
	 * @return Result (if void, then null)</haxe_doc>
		</call>
		<loadFromString public="1" set="method" line="269">
			<f a="code">
				<c path="String"/>
				<c path="funkin.backend.scripting.Script"/>
			</f>
			<haxe_doc>* Loads the code from a string, doesnt really work after the script has been loaded
	 * @param code The code.</haxe_doc>
		</loadFromString>
		<setParent public="1" set="method" line="277">
			<f a="variable">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets a script's parent object so that its properties can be accessed easily. Ex: Passing `PlayState.instance` will allow `boyfriend` to be typed instead of `PlayState.instance.boyfriend`.
	 * @param variable Parent variable.</haxe_doc>
		</setParent>
		<get public="1" set="method" line="284">
			<f a="variable">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>* Gets the variable `variable` from the script's variables.
	 * @param variable Name of the variable.
	 * @return Variable (or null if it doesn't exists)</haxe_doc>
		</get>
		<set public="1" set="method" line="291">
			<f a="variable:value">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the variable `variable` from the script's variables.
	 * @param variable Name of the variable.
	 * @return Variable (or null if it doesn't exists)</haxe_doc>
		</set>
		<error public="1" set="method" line="298">
			<f a="text:?additionalInfo">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shows an error from this script.
	 * @param text Text of the error (ex: Null Object Reference).
	 * @param additionalInfo Additional information you could provide.</haxe_doc>
		</error>
		<toString public="1" set="method" line="308" override="1"><f a=""><c path="String"/></f></toString>
		<onCall set="method" line="322">
			<f a="func:parameters">
				<c path="String"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>* PRIVATE HANDLERS - DO NOT TOUCH</haxe_doc>
		</onCall>
		<onCreate public="1" set="method" line="325"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></onCreate>
		<onLoad public="1" set="method" line="327"><f a=""><x path="Void"/></f></onLoad>
		<new public="1" set="method" line="186">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new instance of the script class.
	 * @param path</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.backend.scripting.ScriptPack</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.DummyScript" params="" file="source/funkin/backend/scripting/DummyScript.hx">
		<extends path="funkin.backend.scripting.Script"/>
		<variables public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</variables>
		<get public="1" set="method" line="9" override="1"><f a="v">
	<c path="String"/>
	<x path="Null"><d/></x>
</f></get>
		<set public="1" set="method" line="10" override="1"><f a="v:v2">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></set>
		<onCall public="1" set="method" line="11" override="1"><f a="method:parameters">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></onCall>
		<new public="1" set="method" line="6"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Simple class for empty scripts or scripts whose language isn't imported yet.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.EventManager" params="" file="source/funkin/backend/scripting/EventManager.hx">
		<eventValues public="1" expr="[]" line="8" static="1">
			<c path="Array"><c path="funkin.backend.scripting.events.CancellableEvent"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</eventValues>
		<eventKeys public="1" expr="[]" line="9" static="1">
			<c path="Array"><x path="Class"><c path="funkin.backend.scripting.events.CancellableEvent"/></x></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</eventKeys>
		<get public="1" params="T" set="method" line="11" static="1"><f a="cl">
	<x path="Class"><c path="get.T"/></x>
	<c path="get.T"/>
</f></get>
		<reset public="1" set="method" line="24" static="1"><f a=""><x path="Void"/></f></reset>
		<init public="1" set="method" line="31" static="1"><f a=""><x path="Void"/></f></init>
		<onStateSwitch get="inline" set="null" line="36" static="1"><f a="newState">
	<c path="flixel.FlxState"/>
	<x path="Void"/>
</f></onStateSwitch>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.GlobalScript" params="" file="source/funkin/backend/scripting/GlobalScript.hx">
		<scripts public="1" static="1"><c path="funkin.backend.scripting.ScriptPack"/></scripts>
		<init public="1" set="method" line="14" static="1"><f a=""><x path="Void"/></f></init>
		<event public="1" params="T" set="method" line="81" static="1"><f a="name:event">
	<c path="String"/>
	<c path="event.T"/>
	<c path="event.T"/>
</f></event>
		<call public="1" set="method" line="87" static="1"><f a="name:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></call>
		<onModSwitch public="1" set="method" line="91" static="1"><f a="newMod">
	<c path="String"/>
	<x path="Void"/>
</f></onModSwitch>
		<beatHit public="1" set="method" line="106" static="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method" line="110" static="1"><f a="curStep">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<haxe_doc>* Class for THE Global Script, aka script that runs in the background at all times.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.HScript" params="" file="source/funkin/backend/scripting/HScript.hx">
		<extends path="funkin.backend.scripting.Script"/>
		<initParser public="1" set="method" line="17" static="1"><f a=""><c path="hscript.Parser"/></f></initParser>
		<interp public="1"><c path="hscript.Interp"/></interp>
		<parser public="1"><c path="hscript.Parser"/></parser>
		<expr public="1"><t path="hscript.Expr"/></expr>
		<code public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</code>
		<__importedPaths><c path="Array"><c path="String"/></c></__importedPaths>
		<onCreate public="1" set="method" line="24" override="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></onCreate>
		<loadFromString public="1" set="method" line="54" override="1"><f a="code">
	<c path="String"/>
	<c path="funkin.backend.scripting.HScript"/>
</f></loadFromString>
		<importFailedCallback set="method" line="67"><f a="cl">
	<c path="Array"><c path="String"/></c>
	<x path="Bool"/>
</f></importFailedCallback>
		<_errorHandler set="method" line="95"><f a="error">
	<c path="hscript.Error"/>
	<x path="Void"/>
</f></_errorHandler>
		<setParent public="1" set="method" line="109" override="1"><f a="parent">
	<d/>
	<x path="Void"/>
</f></setParent>
		<onLoad public="1" set="method" line="113" override="1"><f a=""><x path="Void"/></f></onLoad>
		<reload public="1" set="method" line="122" override="1"><f a=""><x path="Void"/></f></reload>
		<onCall set="method" line="147" override="1"><f a="funcName:parameters">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></onCall>
		<get public="1" set="method" line="158" override="1"><f a="val">
	<c path="String"/>
	<d/>
</f></get>
		<set public="1" set="method" line="162" override="1"><f a="val:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></set>
		<trace public="1" set="method" line="166" override="1"><f a="v">
	<d/>
	<x path="Void"/>
</f></trace>
		<setPublicMap public="1" set="method" line="174" override="1"><f a="map">
	<t path="Map">
		<c path="String"/>
		<d/>
	</t>
	<x path="Void"/>
</f></setPublicMap>
		<new public="1" set="method" line="9"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.ModState" params="" file="source/funkin/backend/scripting/ModState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<lastName public="1" expr="null" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Name of HScript file in assets/data/states.</haxe_doc>
		</lastName>
		<lastData public="1" expr="null" line="12" static="1">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Last Optional extra data.</haxe_doc>
		</lastData>
		<data public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Optional extra data.</haxe_doc>
		</data>
		<new public="1" set="method" line="26">
			<f a="_stateName:?_data">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* ModState Constructor.
	* Inherits from MusicBeatState and allows the execution of an HScript from assets/data/states passed via parameters.
	*
	* @param _stateName Name or path to a HScript file from assets/data/states.
	* @param _data Optional extra Dynamic data passed from a previous state (JSON suggested).</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.ModSubState" params="" file="source/funkin/backend/scripting/ModSubState.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<lastName public="1" expr="null" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Name of HScript file in assets/data/states.</haxe_doc>
		</lastName>
		<lastData public="1" expr="null" line="12" static="1">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Last Optional extra data.</haxe_doc>
		</lastData>
		<data public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Optional extra data.</haxe_doc>
		</data>
		<new public="1" set="method" line="26">
			<f a="_stateName:?_data">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* ModSubState Constructor.
	* Inherits from MusicBeatSubstate and allows the execution of an HScript from assets/data/states passed via parameters.
	*
	* @param _stateName Name or path to a HScript file from assets/data/states.
	* @param _data Optional extra Dynamic data passed from a previous state (JSON suggested).</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.MultiThreadedScript" params="" file="source/funkin/backend/scripting/MultiThreadedScript.hx">
		<implements path="hscript.IHScriptCustomBehaviour"/>
		<implements path="flixel.util.IFlxDestroyable"/>
		<thread><x path="sys.thread.Thread"/></thread>
		<script public="1">
			<c path="funkin.backend.scripting.Script"/>
			<haxe_doc>* Script being ran.</haxe_doc>
		</script>
		<__variables><c path="Array"><c path="String"/></c></__variables>
		<returnValue public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Return value of the last call.</haxe_doc>
		</returnValue>
		<callEnded public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the current call has ended.</haxe_doc>
		</callEnded>
		<hget public="1" set="method" line="60"><f a="name">
	<c path="String"/>
	<d/>
</f></hget>
		<hset public="1" set="method" line="62"><f a="name:val">
	<c path="String"/>
	<d/>
	<d/>
</f></hset>
		<call public="1" set="method" line="70"><f a="func:args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></call>
		<destroy public="1" set="method" line="83"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="31"><f a="path:?parentScript">
	<c path="String"/>
	<c path="funkin.backend.scripting.Script"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.ScriptPack" params="" file="source/funkin/backend/scripting/ScriptPack.hx">
		<extends path="funkin.backend.scripting.Script"/>
		<scripts public="1" expr="[]">
			<c path="Array"><c path="funkin.backend.scripting.Script"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</scripts>
		<additionalDefaultVariables public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</additionalDefaultVariables>
		<publicVariables public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</publicVariables>
		<parent public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</parent>
		<load public="1" set="method" line="13" override="1"><f a=""><x path="Void"/></f></load>
		<contains public="1" set="method" line="19"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></contains>
		<getByPath public="1" set="method" line="30"><f a="name">
	<c path="String"/>
	<c path="funkin.backend.scripting.Script"/>
</f></getByPath>
		<getByName public="1" set="method" line="37"><f a="name">
	<c path="String"/>
	<c path="funkin.backend.scripting.Script"/>
</f></getByName>
		<importScript public="1" set="method" line="43"><f a="path">
	<c path="String"/>
	<c path="funkin.backend.scripting.Script"/>
</f></importScript>
		<call public="1" set="method" line="54" override="1"><f a="func:?parameters">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<event public="1" params="T" get="inline" set="null" line="67">
			<f a="func:event">
				<c path="String"/>
				<c path="event.T"/>
				<c path="event.T"/>
			</f>
			<haxe_doc>* Sends an event to every single script, and returns the event.
	 * @param func Function to call
	 * @param event Event (will be the first parameter of the function)
	 * @return (modified by scripts)</haxe_doc>
		</event>
		<get public="1" set="method" line="77" override="1"><f a="val">
	<c path="String"/>
	<d/>
</f></get>
		<reload public="1" set="method" line="85" override="1"><f a=""><x path="Void"/></f></reload>
		<set public="1" set="method" line="89" override="1"><f a="val:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></set>
		<setParent public="1" set="method" line="93" override="1"><f a="parent">
	<d/>
	<x path="Void"/>
</f></setParent>
		<destroy public="1" set="method" line="98" override="1"><f a=""><x path="Void"/></f></destroy>
		<onCreate public="1" set="method" line="103" override="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></onCreate>
		<add public="1" set="method" line="105"><f a="script">
	<c path="funkin.backend.scripting.Script"/>
	<x path="Void"/>
</f></add>
		<remove public="1" set="method" line="110"><f a="script">
	<c path="funkin.backend.scripting.Script"/>
	<x path="Void"/>
</f></remove>
		<insert public="1" set="method" line="114"><f a="pos:script">
	<x path="Int"/>
	<c path="funkin.backend.scripting.Script"/>
	<x path="Void"/>
</f></insert>
		<__configureNewScript set="method" line="119"><f a="script">
	<c path="funkin.backend.scripting.Script"/>
	<x path="Void"/>
</f></__configureNewScript>
		<toString public="1" set="method" line="125" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="25"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>CancellableEvent</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.CancellableEvent" params="" file="source/funkin/backend/scripting/events/CancellableEvent.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<cancelled public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</cancelled>
		<__continueCalls expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__continueCalls>
		<data public="1" expr="{ }">
			<d/>
			<meta><m n=":value"><e>{ }</e></m></meta>
			<haxe_doc>* Additional data if used in scripts</haxe_doc>
		</data>
		<preventDefault public="1" set="method" line="21">
			<f a="?c" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ c : false }</e></m></meta>
			<haxe_doc>* Prevents default action from occurring.
	 * @param c Whenever the scripts following this one should be called or not. (Defaults to `true`)</haxe_doc>
		</preventDefault>
		<cancel public="1" set="method" line="27">
			<f a="?c" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ c : true }</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</cancel>
		<recycleBase public="1" set="method" line="35"><f a=""><x path="Void"/></f></recycleBase>
		<toString public="1" set="method" line="47">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns a string representation of the event, in this format:
	 * `[CancellableEvent]`
	 * `[CancellableEvent (Cancelled)]`
	 * @return String</haxe_doc>
		</toString>
		<destroy public="1" set="method" line="54"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="33">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates a new cancellable event.
	 * This allows scripts to call `cancel()` to cancel the event.</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.backend.scripting.ScriptPack</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":noCustomClass"/>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.AmountEvent" params="" file="source/funkin/backend/scripting/events/AmountEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<amount public="1">
			<x path="Int"/>
			<haxe_doc>* Amount</haxe_doc>
		</amount>
		<psychUsersComplained public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Shows whether or not psych users complained about this class</haxe_doc>
		</psychUsersComplained>
		<recycle public="1" set="method" line="3">
			<f a="amount:?psychUsersComplained" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="funkin.backend.scripting.events.AmountEvent"/>
			</f>
			<meta><m n=":value"><e>{ psychUsersComplained : true }</e></m></meta>
		</recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.CamMoveEvent" params="" file="source/funkin/backend/scripting/events/CamMoveEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<position public="1">
			<x path="flixel.math.FlxPoint"/>
			<haxe_doc>* Final camera position.</haxe_doc>
		</position>
		<strumLine public="1">
			<c path="funkin.game.StrumLine"/>
			<haxe_doc>* Currently focused strumline.</haxe_doc>
		</strumLine>
		<focusedCharacters public="1">
			<x path="Int"/>
			<haxe_doc>* Number of focused characters</haxe_doc>
		</focusedCharacters>
		<recycle public="1" set="method" line="6"><f a="position:strumLine:focusedCharacters">
	<x path="flixel.math.FlxPoint"/>
	<c path="funkin.game.StrumLine"/>
	<x path="Int"/>
	<c path="funkin.backend.scripting.events.CamMoveEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.CharacterNodeEvent" params="" file="source/funkin/backend/scripting/events/CharacterNodeEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<character public="1">
			<c path="funkin.game.Character"/>
			<haxe_doc>* The character instance</haxe_doc>
		</character>
		<node public="1">
			<x path="haxe.xml.Access"/>
			<haxe_doc>* The node which is currently being parsed</haxe_doc>
		</node>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of the node, quicker access than e.node.name</haxe_doc>
		</name>
		<recycle public="1" set="method" line="6"><f a="character:node:name">
	<c path="funkin.game.Character"/>
	<x path="haxe.xml.Access"/>
	<c path="String"/>
	<c path="funkin.backend.scripting.events.CharacterNodeEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.CharacterXMLEvent" params="" file="source/funkin/backend/scripting/events/CharacterXMLEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<character public="1">
			<c path="funkin.game.Character"/>
			<haxe_doc>* The character instance</haxe_doc>
		</character>
		<xml public="1">
			<x path="haxe.xml.Access"/>
			<haxe_doc>* The xml</haxe_doc>
		</xml>
		<recycle public="1" set="method" line="6"><f a="character:xml">
	<c path="funkin.game.Character"/>
	<x path="haxe.xml.Access"/>
	<c path="funkin.backend.scripting.events.CharacterXMLEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.CountdownEvent" params="" file="source/funkin/backend/scripting/events/CountdownEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<swagCounter public="1">
			<x path="Int"/>
			<haxe_doc>* At which count the countdown is. Normally goes 0-1-2-3-4 unless `PlayState.instance.introLength` is changed.</haxe_doc>
		</swagCounter>
		<volume public="1">
			<x path="Float"/>
			<haxe_doc>* Volume at which the intro countdown sound will play.</haxe_doc>
		</volume>
		<soundPath public="1">
			<c path="String"/>
			<haxe_doc>* Path of the intro sound that'll be played.</haxe_doc>
		</soundPath>
		<spritePath public="1">
			<c path="String"/>
			<haxe_doc>* Path to the sprite path that'll be shown.</haxe_doc>
		</spritePath>
		<scale public="1">
			<x path="Float"/>
			<haxe_doc>* Scale of the sprite.</haxe_doc>
		</scale>
		<antialiasing public="1">
			<x path="Bool"/>
			<haxe_doc>* Whenever antialiasing is enabled or not.</haxe_doc>
		</antialiasing>
		<sprite public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Created sprite, only available in `onPostCountdown`</haxe_doc>
		</sprite>
		<spriteTween public="1">
			<c path="flixel.tweens.FlxTween"/>
			<haxe_doc>* Created tween for the sprite, only available in `onPostCountdown`</haxe_doc>
		</spriteTween>
		<sound public="1">
			<c path="flixel.sound.FlxSound"/>
			<haxe_doc>* Created sound, only available in `onPostCountdown`</haxe_doc>
		</sound>
		<recycle public="1" set="method" line="6"><f a="swagCounter:volume:soundPath:spritePath:scale:antialiasing:sprite:spriteTween:sound">
	<x path="Int"/>
	<x path="Float"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="flixel.FlxSprite"/>
	<c path="flixel.tweens.FlxTween"/>
	<c path="flixel.sound.FlxSound"/>
	<c path="funkin.backend.scripting.events.CountdownEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.DanceEvent" params="" file="source/funkin/backend/scripting/events/DanceEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<danced public="1"><x path="Bool"/></danced>
		<recycle public="1" set="method" line="3"><f a="danced">
	<x path="Bool"/>
	<c path="funkin.backend.scripting.events.DanceEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.DirectionAnimEvent" params="" file="source/funkin/backend/scripting/events/DirectionAnimEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<animName public="1">
			<c path="String"/>
			<haxe_doc>Default animation that will be played</haxe_doc>
		</animName>
		<direction public="1">
			<x path="Int"/>
			<haxe_doc>In which direction the animation will be played</haxe_doc>
		</direction>
		<suffix public="1">
			<c path="String"/>
			<haxe_doc>The suffix of the animation (ex: "-alt") - Defaults to ""</haxe_doc>
		</suffix>
		<context public="1">
			<x path="funkin.backend.scripting.events.PlayAnimContext"/>
			<haxe_doc>Context of the animation. Is either equal to `SING` or `MISS`.</haxe_doc>
		</context>
		<reversed public="1">
			<x path="Bool"/>
			<haxe_doc>Whenever the animation will play reversed or not.</haxe_doc>
		</reversed>
		<frame public="1">
			<x path="Int"/>
			<haxe_doc>At what frame the animation will start playing</haxe_doc>
		</frame>
		<force public="1">
			<x path="Null"><x path="Bool"/></x>
			<haxe_doc>Force the animation to replay even if it's already playing  (if it's null it will be forced based on the sprite's data xml, if it has one).</haxe_doc>
		</force>
		<recycle public="1" set="method" line="5"><f a="animName:direction:suffix:context:reversed:frame:force">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="funkin.backend.scripting.events.PlayAnimContext"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Null"><x path="Bool"/></x>
	<c path="funkin.backend.scripting.events.DirectionAnimEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.DiscordPresenceUpdateEvent" params="" file="source/funkin/backend/scripting/events/DiscordPresenceUpdateEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<presence public="1">
			<t path="funkin.backend.utils.DPresence"/>
			<haxe_doc>* Object containing all of the data for the presence. Can be altered.</haxe_doc>
		</presence>
		<recycle public="1" set="method" line="3"><f a="presence">
	<t path="funkin.backend.utils.DPresence"/>
	<c path="funkin.backend.scripting.events.DiscordPresenceUpdateEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.DrawEvent" params="" file="source/funkin/backend/scripting/events/DrawEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<recycle public="1" set="method" line="3"><f a=""><c path="funkin.backend.scripting.events.DrawEvent"/></f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.DynamicEvent" params="" file="source/funkin/backend/scripting/events/DynamicEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<value1 public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</value1>
		<value2 public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</value2>
		<value3 public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</value3>
		<value4 public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</value4>
		<value5 public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</value5>
		<recycle public="1" set="method" line="6">
			<f a="?value1:?value2:?value3:?value4:?value5" v="null:null:null:null:null">
				<d/>
				<d/>
				<d/>
				<d/>
				<d/>
				<c path="funkin.backend.scripting.events.DynamicEvent"/>
			</f>
			<meta><m n=":value"><e>{ value5 : null, value4 : null, value3 : null, value2 : null, value1 : null }</e></m></meta>
		</recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Event with random dynamic values useful for making your own custom events</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.EventGameEvent" params="" file="source/funkin/backend/scripting/events/EventGameEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<event public="1"><t path="funkin.backend.chart.ChartEvent"/></event>
		<recycle public="1" set="method" line="5"><f a="event">
	<t path="funkin.backend.chart.ChartEvent"/>
	<c path="funkin.backend.scripting.events.EventGameEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.FreeplayAlphaUpdateEvent" params="" file="source/funkin/backend/scripting/events/FreeplayAlphaUpdateEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<idleAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* The alpha when nothing is playing and isnt selected</haxe_doc>
		</idleAlpha>
		<idlePlayingAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* The alpha when something is playing and isnt selected</haxe_doc>
		</idlePlayingAlpha>
		<selectedAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* The alpha when nothing is playing and selected</haxe_doc>
		</selectedAlpha>
		<selectedPlayingAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* The alpha when something is playing and selected</haxe_doc>
		</selectedPlayingAlpha>
		<lerp public="1">
			<x path="Float"/>
			<haxe_doc>* The lerp of the alpha</haxe_doc>
		</lerp>
		<recycle public="1" set="method" line="3"><f a="idleAlpha:idlePlayingAlpha:selectedAlpha:selectedPlayingAlpha:lerp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.backend.scripting.events.FreeplayAlphaUpdateEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.FreeplaySongSelectEvent" params="" file="source/funkin/backend/scripting/events/FreeplaySongSelectEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<song public="1">
			<c path="String"/>
			<haxe_doc>* Song name that is about to be played</haxe_doc>
		</song>
		<difficulty public="1">
			<c path="String"/>
			<haxe_doc>* Difficulty name</haxe_doc>
		</difficulty>
		<opponentMode public="1">
			<x path="Bool"/>
			<haxe_doc>* Whenever opponent mode is enabled or not.</haxe_doc>
		</opponentMode>
		<coopMode public="1">
			<x path="Bool"/>
			<haxe_doc>* Whenever coop mode is enabled.</haxe_doc>
		</coopMode>
		<recycle public="1" set="method" line="3"><f a="song:difficulty:opponentMode:coopMode">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="funkin.backend.scripting.events.FreeplaySongSelectEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.GameOverCreationEvent" params="" file="source/funkin/backend/scripting/events/GameOverCreationEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<character public="1"><c path="String"/></character>
		<player public="1"><x path="Bool"/></player>
		<gameOverSong public="1"><c path="String"/></gameOverSong>
		<bpm public="1"><x path="Float"/></bpm>
		<lossSFX public="1"><c path="String"/></lossSFX>
		<retrySFX public="1"><c path="String"/></retrySFX>
		<recycle public="1" set="method" line="6"><f a="x:y:character:player:gameOverSong:bpm:lossSFX:retrySFX">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Float"/>
	<c path="String"/>
	<c path="String"/>
	<c path="funkin.backend.scripting.events.GameOverCreationEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* CANCEL this event to prevent default behaviour!</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.GameOverEvent" params="" file="source/funkin/backend/scripting/events/GameOverEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The X pos of where the gameover character will be.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The Y pos of where the gameover character will be.</haxe_doc>
		</y>
		<character public="1">
			<c path="funkin.game.Character"/>
			<haxe_doc>* Character which died. Default to `boyfriend`.</haxe_doc>
		</character>
		<deathCharID public="1">
			<c path="String"/>
			<haxe_doc>* Character ID (name) for game over. Default to whatever is specified in the character's XML.</haxe_doc>
		</deathCharID>
		<isPlayer public="1">
			<x path="Bool"/>
			<haxe_doc>* If the character has isPlayer</haxe_doc>
		</isPlayer>
		<gameOverSong public="1">
			<c path="String"/>
			<haxe_doc>* Song for the game over screen. Default to `this.gameOverSong` (`gameOver`)</haxe_doc>
		</gameOverSong>
		<lossSFX public="1">
			<c path="String"/>
			<haxe_doc>* SFX at the beginning of the game over (Mic drop). Default to `this.lossSFX` (`gameOverSFX`)</haxe_doc>
		</lossSFX>
		<retrySFX public="1">
			<c path="String"/>
			<haxe_doc>* SFX played whenever the player retries. Defaults to `retrySFX` (`gameOverEnd`)</haxe_doc>
		</retrySFX>
		<recycle public="1" set="method" line="5"><f a="x:y:character:deathCharID:isPlayer:gameOverSong:lossSFX:retrySFX">
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.game.Character"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="funkin.backend.scripting.events.GameOverEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.InputSystemEvent" params="" file="source/funkin/backend/scripting/events/InputSystemEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<pressed public="1">
			<c path="Array"><x path="Bool"/></c>
			<haxe_doc>* Array containing whenever a specific control is pressed or not.
	 * For example, `pressed[0]` will return whenever the left strum was pressed.</haxe_doc>
		</pressed>
		<justPressed public="1">
			<c path="Array"><x path="Bool"/></c>
			<haxe_doc>* Array containing whenever a specific control was pressed (not hold) this frame or not.
	 * For example, `justPressed[0]` will return whenever the left strum was just pressed.</haxe_doc>
		</justPressed>
		<justReleased public="1">
			<c path="Array"><x path="Bool"/></c>
			<haxe_doc>* Array containing whenever a specific control was released this frame or not.
	 * For example, `justReleased[0]` will return whenever the left strum was just released.</haxe_doc>
		</justReleased>
		<strumLine public="1">
			<c path="funkin.game.StrumLine"/>
			<haxe_doc>* Strumline which input is being processed.</haxe_doc>
		</strumLine>
		<strumLineID public="1">
			<x path="Int"/>
			<haxe_doc>* ID of the Strumline.</haxe_doc>
		</strumLineID>
		<recycle public="1" set="method" line="5"><f a="pressed:justPressed:justReleased:strumLine:strumLineID">
	<c path="Array"><x path="Bool"/></c>
	<c path="Array"><x path="Bool"/></c>
	<c path="Array"><x path="Bool"/></c>
	<c path="funkin.game.StrumLine"/>
	<x path="Int"/>
	<c path="funkin.backend.scripting.events.InputSystemEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.MenuChangeEvent" params="" file="source/funkin/backend/scripting/events/MenuChangeEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<oldValue public="1">
			<x path="Int"/>
			<haxe_doc>* Value before the change</haxe_doc>
		</oldValue>
		<value public="1">
			<x path="Int"/>
			<haxe_doc>* Value after the change</haxe_doc>
		</value>
		<change public="1">
			<x path="Int"/>
			<haxe_doc>* Amount of change</haxe_doc>
		</change>
		<playMenuSFX public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the menu SFX should be played.</haxe_doc>
		</playMenuSFX>
		<recycle public="1" set="method" line="3">
			<f a="oldValue:value:change:?playMenuSFX" v=":::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="funkin.backend.scripting.events.MenuChangeEvent"/>
			</f>
			<meta><m n=":value"><e>{ playMenuSFX : true }</e></m></meta>
		</recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.NameEvent" params="" file="source/funkin/backend/scripting/events/NameEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* Name</haxe_doc>
		</name>
		<recycle public="1" set="method" line="3"><f a="name">
	<c path="String"/>
	<c path="funkin.backend.scripting.events.NameEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.NoteCreationEvent" params="" file="source/funkin/backend/scripting/events/NoteCreationEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<note public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>* Note that is being created</haxe_doc>
		</note>
		<strumID public="1">
			<x path="Int"/>
			<haxe_doc>* ID of the strum (from 0 to 3)</haxe_doc>
		</strumID>
		<noteType public="1">
			<c path="String"/>
			<haxe_doc>* Note Type (ex: "My Super Cool Note", or "Mine")</haxe_doc>
		</noteType>
		<noteTypeID public="1">
			<x path="Int"/>
			<haxe_doc>* ID of the note type.</haxe_doc>
		</noteTypeID>
		<strumLineID public="1">
			<x path="Int"/>
			<haxe_doc>* ID of the player.</haxe_doc>
		</strumLineID>
		<mustHit public="1">
			<x path="Bool"/>
			<haxe_doc>* Whenever the note will need to be hit by the player</haxe_doc>
		</mustHit>
		<noteSprite public="1">
			<c path="String"/>
			<haxe_doc>* Note sprite, if you only want to replace the sprite.</haxe_doc>
		</noteSprite>
		<noteScale public="1">
			<x path="Float"/>
			<haxe_doc>* Note scale, if you only want to replace the scale.</haxe_doc>
		</noteScale>
		<animSuffix public="1">
			<c path="String"/>
			<haxe_doc>* Sing animation suffix. "-alt" for alt anim or "" for normal notes.</haxe_doc>
		</animSuffix>
		<recycle public="1" set="method" line="5"><f a="note:strumID:noteType:noteTypeID:strumLineID:mustHit:noteSprite:noteScale:animSuffix">
	<c path="funkin.game.Note"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Float"/>
	<c path="String"/>
	<c path="funkin.backend.scripting.events.NoteCreationEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.NoteHitEvent" params="" file="source/funkin/backend/scripting/events/NoteHitEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<animCancelled public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</animCancelled>
		<strumGlowCancelled public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</strumGlowCancelled>
		<deleteNote public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</deleteNote>
		<unmuteVocals public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</unmuteVocals>
		<enableCamZooming public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</enableCamZooming>
		<autoHitLastSustain public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</autoHitLastSustain>
		<misses public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever a miss should be added.</haxe_doc>
		</misses>
		<countAsCombo public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether this hit increases combo.</haxe_doc>
		</countAsCombo>
		<countScore public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether this hit increases the score</haxe_doc>
		</countScore>
		<showRating public="1" expr="null">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Whenever ratings should be shown or not.</haxe_doc>
		</showRating>
		<note public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>* Note that has been pressed</haxe_doc>
		</note>
		<character public="1" get="accessor" set="accessor">
			<c path="funkin.game.Character"/>
			<haxe_doc>* Character that pressed the note.</haxe_doc>
		</character>
		<characters public="1">
			<c path="Array"><c path="funkin.game.Character"/></c>
			<haxe_doc>* Characters that pressed the note.</haxe_doc>
		</characters>
		<player public="1">
			<x path="Bool"/>
			<haxe_doc>* Whenever the Character is a player</haxe_doc>
		</player>
		<noteType public="1">
			<c path="String"/>
			<haxe_doc>* Note Type name (null if default note)</haxe_doc>
		</noteType>
		<animSuffix public="1">
			<c path="String"/>
			<haxe_doc>* Suffix of the animation. "-alt" for alt notes, "" for normal ones.</haxe_doc>
		</animSuffix>
		<ratingPrefix public="1">
			<c path="String"/>
			<haxe_doc>* Prefix of the rating sprite path. Defaults to "game/score/"</haxe_doc>
		</ratingPrefix>
		<ratingSuffix public="1">
			<c path="String"/>
			<haxe_doc>* Suffix of the rating sprite path.</haxe_doc>
		</ratingSuffix>
		<direction public="1">
			<x path="Int"/>
			<haxe_doc>* Direction of the press (0 = Left, 1 = Down, 2 = Up, 3 = Right)</haxe_doc>
		</direction>
		<score public="1">
			<x path="Int"/>
			<haxe_doc>* Score gained after note press.</haxe_doc>
		</score>
		<accuracy public="1">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>* Accuracy gained from pressing this note. From 0 to 1. null means no accuracy is gained.</haxe_doc>
		</accuracy>
		<healthGain public="1">
			<x path="Float"/>
			<haxe_doc>* The amount of health that'll be gained from pressing that note. If called from `onPlayerMiss`, the value will be negative.</haxe_doc>
		</healthGain>
		<rating public="1" expr="&quot;sick&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"sick"</e></m></meta>
			<haxe_doc>* Rating name. Defaults to "sick", "good", "bad" and "shit". Customisable.</haxe_doc>
		</rating>
		<showSplash public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever a splash should be shown when the note is hit.</haxe_doc>
		</showSplash>
		<numScale public="1" expr="0.5">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
			<haxe_doc>* Scale of combo numbers.</haxe_doc>
		</numScale>
		<numAntialiasing public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever antialiasing should be enabled on combo number.</haxe_doc>
		</numAntialiasing>
		<ratingScale public="1" expr="0.7">
			<x path="Float"/>
			<meta><m n=":value"><e>0.7</e></m></meta>
			<haxe_doc>* Scale of ratings.</haxe_doc>
		</ratingScale>
		<ratingAntialiasing public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever antialiasing should be enabled on ratings.</haxe_doc>
		</ratingAntialiasing>
		<forceAnim public="1" expr="true">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the animation should be forced to play (if it's null it will be forced based on the sprite's data xml, if it has one).</haxe_doc>
		</forceAnim>
		<preventAnim public="1" set="method" line="110">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the default sing animation from being played.</haxe_doc>
		</preventAnim>
		<cancelAnim public="1" set="method" line="115">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelAnim>
		<preventDeletion public="1" set="method" line="120">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the note from being deleted.</haxe_doc>
		</preventDeletion>
		<cancelDeletion public="1" set="method" line="124">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelDeletion>
		<preventVocalsUnmute public="1" set="method" line="129">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the vocals volume from being set to 1 after pressing the note.</haxe_doc>
		</preventVocalsUnmute>
		<cancelVocalsUnmute public="1" set="method" line="133">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelVocalsUnmute>
		<preventVocalsMute public="1" set="method" line="138">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the vocals volume from being muted in case its a parameter of `onPlayerMiss`</haxe_doc>
		</preventVocalsMute>
		<cancelVocalsMute public="1" set="method" line="142">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelVocalsMute>
		<preventCamZooming public="1" set="method" line="147">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the camera zoom every 4 beats from enabling.</haxe_doc>
		</preventCamZooming>
		<cancelCamZooming public="1" set="method" line="151">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelCamZooming>
		<preventLastSustainHit public="1" set="method" line="156">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the sustain tail (the last one) from being automatically hit when the sustain before it is hit.</haxe_doc>
		</preventLastSustainHit>
		<cancelLastSustainHit public="1" set="method" line="160">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelLastSustainHit>
		<preventStrumGlow public="1" set="method" line="165">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the strum from glowing after this note has been pressed.</haxe_doc>
		</preventStrumGlow>
		<cancelStrumGlow public="1" set="method" line="169">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelStrumGlow>
		<get_character get="inline" set="null" line="172"><f a=""><c path="funkin.game.Character"/></f></get_character>
		<set_character set="method" line="173"><f a="char">
	<c path="funkin.game.Character"/>
	<c path="funkin.game.Character"/>
</f></set_character>
		<recycle public="1" set="method" line="6">
			<f a="?misses:?countAsCombo:?countScore:?showRating:note:characters:player:noteType:animSuffix:ratingPrefix:ratingSuffix:direction:score:accuracy:healthGain:?rating:?showSplash:?numScale:?numAntialiasing:?ratingScale:?ratingAntialiasing:?forceAnim" v="true:true:true:null::::::::::::&quot;sick&quot;:false:0.5:true:0.7:true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="funkin.game.Note"/>
				<c path="Array"><c path="funkin.game.Character"/></c>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Null"><x path="Float"/></x>
				<x path="Float"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="funkin.backend.scripting.events.NoteHitEvent"/>
			</f>
			<meta><m n=":value"><e>{ forceAnim : true, ratingAntialiasing : true, ratingScale : 0.7, numAntialiasing : true, numScale : 0.5, showSplash : false, rating : "sick", showRating : null, countScore : true, countAsCombo : true, misses : true }</e></m></meta>
		</recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.NoteMissEvent" params="" file="source/funkin/backend/scripting/events/NoteMissEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<animCancelled public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</animCancelled>
		<deleteNote public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</deleteNote>
		<stunned public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</stunned>
		<resetCombo public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</resetCombo>
		<playMissSound public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</playMissSound>
		<note public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>* Note that has been missed</haxe_doc>
		</note>
		<score public="1"><x path="Int"/></score>
		<misses public="1"><x path="Int"/></misses>
		<muteVocals public="1"><x path="Bool"/></muteVocals>
		<healthGain public="1">
			<x path="Float"/>
			<haxe_doc>* The amount of health that'll be gained from missing that note. If called from `onPlayerMiss`, the value will be negative.</haxe_doc>
		</healthGain>
		<missSound public="1"><c path="String"/></missSound>
		<missVolume public="1"><x path="Float"/></missVolume>
		<ghostMiss public="1"><x path="Bool"/></ghostMiss>
		<gfSad public="1"><x path="Bool"/></gfSad>
		<gfSadAnim public="1"><c path="String"/></gfSadAnim>
		<forceGfAnim public="1"><x path="Bool"/></forceGfAnim>
		<forceAnim public="1">
			<x path="Null"><x path="Bool"/></x>
			<haxe_doc>* Whenever the animation should be forced to play (if it's null it will be forced based on the sprite's data xml, if it has one).</haxe_doc>
		</forceAnim>
		<animSuffix public="1">
			<c path="String"/>
			<haxe_doc>* Suffix of the animation. "miss" for miss notes, "-alt" for alt notes, "" for normal ones.</haxe_doc>
		</animSuffix>
		<character public="1" get="accessor" set="accessor">
			<c path="funkin.game.Character"/>
			<haxe_doc>* Character that pressed the note.</haxe_doc>
		</character>
		<characters public="1">
			<c path="Array"><c path="funkin.game.Character"/></c>
			<haxe_doc>* Characters that pressed the note.</haxe_doc>
		</characters>
		<playerID public="1">
			<x path="Int"/>
			<haxe_doc>* Whenever the Character is a player</haxe_doc>
		</playerID>
		<noteType public="1">
			<c path="String"/>
			<haxe_doc>* Note Type name (null if default note)</haxe_doc>
		</noteType>
		<direction public="1">
			<x path="Int"/>
			<haxe_doc>* Direction of the press (0 = Left, 1 = Down, 2 = Up, 3 = Right)</haxe_doc>
		</direction>
		<accuracy public="1">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>* Accuracy gained from pressing this note. From 0 to 1. null means no accuracy is gained.</haxe_doc>
		</accuracy>
		<preventMissSound public="1" set="method" line="68">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the miss sound from played.</haxe_doc>
		</preventMissSound>
		<cancelMissSound public="1" set="method" line="73">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelMissSound>
		<preventResetCombo public="1" set="method" line="78">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the combo from being reset.</haxe_doc>
		</preventResetCombo>
		<cancelResetCombo public="1" set="method" line="83">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelResetCombo>
		<preventStunned public="1" set="method" line="88">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the default sing animation from being played.</haxe_doc>
		</preventStunned>
		<cancelStunned public="1" set="method" line="93">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelStunned>
		<preventAnim public="1" set="method" line="98">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the default sing animation from being played.</haxe_doc>
		</preventAnim>
		<cancelAnim public="1" set="method" line="103">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelAnim>
		<preventDeletion public="1" set="method" line="108">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the note from being deleted.</haxe_doc>
		</preventDeletion>
		<cancelDeletion public="1" set="method" line="112">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelDeletion>
		<preventVocalsUnmute public="1" set="method" line="117">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the vocals volume from being set to 1 after pressing the note.</haxe_doc>
		</preventVocalsUnmute>
		<cancelVocalsUnmute public="1" set="method" line="121">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelVocalsUnmute>
		<preventVocalsMute public="1" set="method" line="126">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the vocals volume from being muted in case its a parameter of `onPlayerMiss`</haxe_doc>
		</preventVocalsMute>
		<cancelVocalsMute public="1" set="method" line="130">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelVocalsMute>
		<get_character get="inline" set="null" line="133"><f a=""><c path="funkin.game.Character"/></f></get_character>
		<set_character set="method" line="134"><f a="char">
	<c path="funkin.game.Character"/>
	<c path="funkin.game.Character"/>
</f></set_character>
		<recycle public="1" set="method" line="6"><f a="note:score:misses:muteVocals:healthGain:missSound:missVolume:ghostMiss:gfSad:gfSadAnim:forceGfAnim:forceAnim:animSuffix:characters:playerID:noteType:direction:accuracy">
	<c path="funkin.game.Note"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Null"><x path="Bool"/></x>
	<c path="String"/>
	<c path="Array"><c path="funkin.game.Character"/></c>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Null"><x path="Float"/></x>
	<c path="funkin.backend.scripting.events.NoteMissEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.NoteUpdateEvent" params="" file="source/funkin/backend/scripting/events/NoteUpdateEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<__updateHitWindow public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__updateHitWindow>
		<__autoCPUHit public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__autoCPUHit>
		<__reposNote public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__reposNote>
		<note public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>* Note that is being updated</haxe_doc>
		</note>
		<elapsed public="1">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>* Time elapsed since last frame</haxe_doc>
		</elapsed>
		<strum public="1">
			<c path="funkin.game.Strum"/>
			<haxe_doc>* Note's strum (can be changed)</haxe_doc>
		</strum>
		<cancelWindowUpdate public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cancels the hit window update.</haxe_doc>
		</cancelWindowUpdate>
		<preventWindowUpdate public="1" set="method" line="31">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</preventWindowUpdate>
		<cancelAutoCPUHit public="1" set="method" line="36">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cancels the automatic CPU hit.</haxe_doc>
		</cancelAutoCPUHit>
		<preventAutoCPUHit public="1" set="method" line="39">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</preventAutoCPUHit>
		<cancelPositionUpdate public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cancels the note position update (note will freeze).</haxe_doc>
		</cancelPositionUpdate>
		<preventPositionUpdate public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</preventPositionUpdate>
		<recycle public="1" set="method" line="6"><f a="note:elapsed:strum">
	<c path="funkin.game.Note"/>
	<x path="Null"><x path="Float"/></x>
	<c path="funkin.game.Strum"/>
	<c path="funkin.backend.scripting.events.NoteUpdateEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.PauseCreationEvent" params="" file="source/funkin/backend/scripting/events/PauseCreationEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<music public="1">
			<c path="String"/>
			<haxe_doc>* Music that is going to be played</haxe_doc>
		</music>
		<options public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* All option names</haxe_doc>
		</options>
		<recycle public="1" set="method" line="6"><f a="music:options">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="funkin.backend.scripting.events.PauseCreationEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* CANCEL this event to prevent default behaviour!</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.PlayAnimEvent" params="" file="source/funkin/backend/scripting/events/PlayAnimEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<animName public="1">
			<c path="String"/>
			<haxe_doc>Name of the animation that's going to be played.</haxe_doc>
		</animName>
		<force public="1">
			<x path="Null"><x path="Bool"/></x>
			<haxe_doc>Whenever the animation will be forced or not (if it's null it will be forced based on the sprite's data xml, if it has one).</haxe_doc>
		</force>
		<reverse public="1">
			<x path="Bool"/>
			<haxe_doc>Whenever the animation will play in reverse or not</haxe_doc>
		</reverse>
		<startingFrame public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>The frame at which the animation will start playing</haxe_doc>
		</startingFrame>
		<context public="1">
			<x path="funkin.backend.scripting.events.PlayAnimContext"/>
			<haxe_doc>Context of the animation</haxe_doc>
		</context>
		<recycle public="1" set="method" line="3">
			<f a="animName:force:reverse:?startingFrame:context" v=":::0:">
				<c path="String"/>
				<x path="Null"><x path="Bool"/></x>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="funkin.backend.scripting.events.PlayAnimContext"/>
				<c path="funkin.backend.scripting.events.PlayAnimEvent"/>
			</f>
			<meta><m n=":value"><e>{ startingFrame : 0 }</e></m></meta>
		</recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<abstract path="funkin.backend.scripting.events.PlayAnimContext" params="" file="source/funkin/backend/scripting/events/PlayAnimEvent.hx" module="funkin.backend.scripting.events.PlayAnimEvent">
		<this><c path="String"/></this>
		<haxe_doc>Contains all contexts possible for `PlayAnimEvent`.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.scripting.events._PlayAnimEvent.PlayAnimContext_Impl_" params="" file="source/funkin/backend/scripting/events/PlayAnimEvent.hx" private="1" module="funkin.backend.scripting.events.PlayAnimEvent" extern="1" final="1">
	<NONE public="1" get="inline" set="null" expr="cast null" line="38" static="1">
		<x path="funkin.backend.scripting.events.PlayAnimContext"/>
		<meta>
			<m n=":value"><e>cast null</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>No context was given for the animation.
		The character won't dance until the animation is finished</haxe_doc>
	</NONE>
	<SING public="1" get="inline" set="null" expr="cast &quot;SING&quot;" line="44" static="1">
		<x path="funkin.backend.scripting.events.PlayAnimContext"/>
		<meta>
			<m n=":value"><e>cast "SING"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Whenever a note is hit and a sing animation will be played.
		The character will only dance after their holdTime is reached.</haxe_doc>
	</SING>
	<DANCE public="1" get="inline" set="null" expr="cast &quot;DANCE&quot;" line="50" static="1">
		<x path="funkin.backend.scripting.events.PlayAnimContext"/>
		<meta>
			<m n=":value"><e>cast "DANCE"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Whenever a dance animation is played.
		The character's dancing wont be blocked.</haxe_doc>
	</DANCE>
	<MISS public="1" get="inline" set="null" expr="cast &quot;MISS&quot;" line="56" static="1">
		<x path="funkin.backend.scripting.events.PlayAnimContext"/>
		<meta>
			<m n=":value"><e>cast "MISS"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Whenever a note is missed and a miss animation will be played.
		Only for scripting, since it has the same effects as SING.</haxe_doc>
	</MISS>
	<LOCK public="1" get="inline" set="null" expr="cast &quot;LOCK&quot;" line="62" static="1">
		<x path="funkin.backend.scripting.events.PlayAnimContext"/>
		<meta>
			<m n=":value"><e>cast "LOCK"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Locks the character's animation.
		Prevents the character from dancing, even if the animation ended.</haxe_doc>
	</LOCK>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.scripting.events._PlayAnimEvent.PlayAnimContext_Impl_" params="" file="source/funkin/backend/scripting/events/PlayAnimEvent.hx" private="1" module="funkin.backend.scripting.events.PlayAnimEvent" extern="1" final="1">
		<NONE public="1" get="inline" set="null" expr="cast null" line="38" static="1">
			<x path="funkin.backend.scripting.events.PlayAnimContext"/>
			<meta>
				<m n=":value"><e>cast null</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>No context was given for the animation.
		The character won't dance until the animation is finished</haxe_doc>
		</NONE>
		<SING public="1" get="inline" set="null" expr="cast &quot;SING&quot;" line="44" static="1">
			<x path="funkin.backend.scripting.events.PlayAnimContext"/>
			<meta>
				<m n=":value"><e>cast "SING"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Whenever a note is hit and a sing animation will be played.
		The character will only dance after their holdTime is reached.</haxe_doc>
		</SING>
		<DANCE public="1" get="inline" set="null" expr="cast &quot;DANCE&quot;" line="50" static="1">
			<x path="funkin.backend.scripting.events.PlayAnimContext"/>
			<meta>
				<m n=":value"><e>cast "DANCE"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Whenever a dance animation is played.
		The character's dancing wont be blocked.</haxe_doc>
		</DANCE>
		<MISS public="1" get="inline" set="null" expr="cast &quot;MISS&quot;" line="56" static="1">
			<x path="funkin.backend.scripting.events.PlayAnimContext"/>
			<meta>
				<m n=":value"><e>cast "MISS"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Whenever a note is missed and a miss animation will be played.
		Only for scripting, since it has the same effects as SING.</haxe_doc>
		</MISS>
		<LOCK public="1" get="inline" set="null" expr="cast &quot;LOCK&quot;" line="62" static="1">
			<x path="funkin.backend.scripting.events.PlayAnimContext"/>
			<meta>
				<m n=":value"><e>cast "LOCK"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Locks the character's animation.
		Prevents the character from dancing, even if the animation ended.</haxe_doc>
		</LOCK>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.backend.scripting.events.PointEvent" params="" file="source/funkin/backend/scripting/events/PointEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>X position</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>Y position</haxe_doc>
		</y>
		<recycle public="1" set="method" line="3"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.backend.scripting.events.PointEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.RatingUpdateEvent" params="" file="source/funkin/backend/scripting/events/RatingUpdateEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<rating public="1">
			<c path="funkin.game.ComboRating"/>
			<haxe_doc>New combo</haxe_doc>
		</rating>
		<oldRating public="1">
			<c path="funkin.game.ComboRating"/>
			<haxe_doc>Old combo (may be null)</haxe_doc>
		</oldRating>
		<recycle public="1" set="method" line="3"><f a="rating:oldRating">
	<c path="funkin.game.ComboRating"/>
	<c path="funkin.game.ComboRating"/>
	<c path="funkin.backend.scripting.events.RatingUpdateEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.ResizeEvent" params="" file="source/funkin/backend/scripting/events/ResizeEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<width public="1">
			<x path="Int"/>
			<haxe_doc>* New width</haxe_doc>
		</width>
		<height public="1">
			<x path="Int"/>
			<haxe_doc>* New height</haxe_doc>
		</height>
		<oldWidth public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>* Old width (may be null)</haxe_doc>
		</oldWidth>
		<oldHeight public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>* Old height (may be null)</haxe_doc>
		</oldHeight>
		<recycle public="1" set="method" line="3"><f a="width:height:oldWidth:oldHeight">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<c path="funkin.backend.scripting.events.ResizeEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.SimpleNoteEvent" params="" file="source/funkin/backend/scripting/events/SimpleNoteEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<note public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>Note that is affected.</haxe_doc>
		</note>
		<recycle public="1" set="method" line="5"><f a="note">
	<c path="funkin.game.Note"/>
	<c path="funkin.backend.scripting.events.SimpleNoteEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.StageNodeEvent" params="" file="source/funkin/backend/scripting/events/StageNodeEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<stage public="1">
			<c path="funkin.game.Stage"/>
			<haxe_doc>* The stage instance</haxe_doc>
		</stage>
		<node public="1">
			<x path="haxe.xml.Access"/>
			<haxe_doc>* The node which is currently being parsed</haxe_doc>
		</node>
		<sprite public="1">
			<d/>
			<haxe_doc>* The sprite which was parsed</haxe_doc>
		</sprite>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of the node, quicker access than e.node.name</haxe_doc>
		</name>
		<recycle public="1" set="method" line="6"><f a="stage:node:sprite:name">
	<c path="funkin.game.Stage"/>
	<x path="haxe.xml.Access"/>
	<d/>
	<c path="String"/>
	<c path="funkin.backend.scripting.events.StageNodeEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.StageXMLEvent" params="" file="source/funkin/backend/scripting/events/StageXMLEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<stage public="1">
			<c path="funkin.game.Stage"/>
			<haxe_doc>* The stage instance</haxe_doc>
		</stage>
		<xml public="1">
			<x path="haxe.xml.Access"/>
			<haxe_doc>* The xml</haxe_doc>
		</xml>
		<elems public="1">
			<c path="Array"><x path="haxe.xml.Access"/></c>
			<haxe_doc>* The object which was parsed</haxe_doc>
		</elems>
		<recycle public="1" set="method" line="6"><f a="stage:xml:elems">
	<c path="funkin.game.Stage"/>
	<x path="haxe.xml.Access"/>
	<c path="Array"><x path="haxe.xml.Access"/></c>
	<c path="funkin.backend.scripting.events.StageXMLEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.StateEvent" params="" file="source/funkin/backend/scripting/events/StateEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<substate public="1">
			<c path="flixel.FlxState"/>
			<haxe_doc>* Substate that is about to be opened/closed</haxe_doc>
		</substate>
		<recycle public="1" set="method" line="5"><f a="substate">
	<c path="flixel.FlxState"/>
	<c path="funkin.backend.scripting.events.StateEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.StrumCreationEvent" params="" file="source/funkin/backend/scripting/events/StrumCreationEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<__doAnimation public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__doAnimation>
		<strum public="1">
			<c path="funkin.game.Strum"/>
			<haxe_doc>* The strum that is being created</haxe_doc>
		</strum>
		<player public="1">
			<x path="Int"/>
			<haxe_doc>s
	 * Player ID</haxe_doc>
		</player>
		<strumID public="1">
			<x path="Int"/>
			<haxe_doc>* Strum ID, for the sprite.</haxe_doc>
		</strumID>
		<animPrefix public="1">
			<c path="String"/>
			<haxe_doc>* Animation prefix (`left` = `arrowLEFT`, `left press`, `left confirm`).</haxe_doc>
		</animPrefix>
		<sprite public="1" expr="&quot;game/notes/default&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"game/notes/default"</e></m></meta>
			<haxe_doc>* Sprite path, in case you only want to change the sprite.</haxe_doc>
		</sprite>
		<cancelAnimation public="1" set="method" line="37">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cancels the animation that makes the strum "land" in the strumline.</haxe_doc>
		</cancelAnimation>
		<preventAnimation public="1" set="method" line="38">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</preventAnimation>
		<recycle public="1" set="method" line="5">
			<f a="strum:player:strumID:animPrefix:?sprite" v="::::&quot;game/notes/default&quot;">
				<c path="funkin.game.Strum"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
				<c path="funkin.backend.scripting.events.StrumCreationEvent"/>
			</f>
			<meta><m n=":value"><e>{ sprite : "game/notes/default" }</e></m></meta>
		</recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.WeekSelectEvent" params="" file="source/funkin/backend/scripting/events/WeekSelectEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<week public="1">
			<t path="funkin.menus.WeekData"/>
			<haxe_doc>* Week that is going to be selected</haxe_doc>
		</week>
		<difficulty public="1">
			<c path="String"/>
			<haxe_doc>* The difficulty that has been selected</haxe_doc>
		</difficulty>
		<weekID public="1">
			<x path="Int"/>
			<haxe_doc>* At which emplacement the week is. Goes from 0 to the number of weeks - 1.</haxe_doc>
		</weekID>
		<difficultyID public="1">
			<x path="Int"/>
			<haxe_doc>* At which emplacement the difficulty is. Goes from 0 to the number of weeks - 1.</haxe_doc>
		</difficultyID>
		<recycle public="1" set="method" line="5"><f a="week:difficulty:weekID:difficultyID">
	<t path="funkin.menus.WeekData"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="funkin.backend.scripting.events.WeekSelectEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueBoxCharPopupEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueBoxCharPopupEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<char public="1"><c path="funkin.game.cutscenes.dialogue.DialogueCharacter"/></char>
		<force public="1"><x path="Bool"/></force>
		<recycle public="1" set="method" line="5"><f a="char:force">
	<c path="funkin.game.cutscenes.dialogue.DialogueCharacter"/>
	<x path="Bool"/>
	<c path="funkin.backend.scripting.events.dialogue.DialogueBoxCharPopupEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueBoxPlayBubbleEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueBoxPlayBubbleEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<bubble public="1"><c path="String"/></bubble>
		<suffix public="1"><c path="String"/></suffix>
		<text public="1"><c path="String"/></text>
		<format public="1"><c path="Array"><t path="funkin.backend.utils.TextFormat"/></c></format>
		<speed public="1"><x path="Float"/></speed>
		<customSFX public="1"><c path="flixel.sound.FlxSound"/></customSFX>
		<customTypeSFX public="1"><c path="Array"><c path="flixel.sound.FlxSound"/></c></customTypeSFX>
		<setTextAfter public="1"><x path="Bool"/></setTextAfter>
		<allowDefault public="1"><x path="Bool"/></allowDefault>
		<recycle public="1" set="method" line="6"><f a="bubble:suffix:text:format:speed:customSFX:customTypeSFX:setTextAfter:allowDefault">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
	<x path="Float"/>
	<c path="flixel.sound.FlxSound"/>
	<c path="Array"><c path="flixel.sound.FlxSound"/></c>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="funkin.backend.scripting.events.dialogue.DialogueBoxPlayBubbleEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueBoxSetTextEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueBoxSetTextEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<text public="1"><c path="String"/></text>
		<format public="1"><c path="Array"><t path="funkin.backend.utils.TextFormat"/></c></format>
		<speed public="1"><x path="Null"><x path="Float"/></x></speed>
		<customTypeSFX public="1"><c path="Array"><c path="flixel.sound.FlxSound"/></c></customTypeSFX>
		<recycle public="1" set="method" line="6"><f a="text:format:speed:customTypeSFX">
	<c path="String"/>
	<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
	<x path="Null"><x path="Float"/></x>
	<c path="Array"><c path="flixel.sound.FlxSound"/></c>
	<c path="funkin.backend.scripting.events.dialogue.DialogueBoxSetTextEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueBoxStructureEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueBoxStructureEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<name public="1"><c path="String"/></name>
		<textTypeSFX public="1"><c path="String"/></textTypeSFX>
		<dialogueBoxData public="1"><x path="haxe.xml.Access"/></dialogueBoxData>
		<recycle public="1" set="method" line="8"><f a="name:textTypeSFX:dialogueBoxData">
	<c path="String"/>
	<c path="String"/>
	<x path="haxe.xml.Access"/>
	<c path="funkin.backend.scripting.events.dialogue.DialogueBoxStructureEvent"/>
</f></recycle>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* CANCEL this event to customize from 0 the xml structure part!</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueCharHideEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueCharHideEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<animation public="1"><c path="String"/></animation>
		<lastAnimContext public="1"><x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/></lastAnimContext>
		<recycle public="1" set="method" line="5"><f a="animation:lastAnimContext">
	<c path="String"/>
	<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
	<c path="funkin.backend.scripting.events.dialogue.DialogueCharHideEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueCharShowEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueCharShowEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<animation public="1"><c path="String"/></animation>
		<lastAnimContext public="1"><x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/></lastAnimContext>
		<recycle public="1" set="method" line="5"><f a="x:y:animation:lastAnimContext">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
	<c path="funkin.backend.scripting.events.dialogue.DialogueCharShowEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueCharStructureEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueCharStructureEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<name public="1"><c path="String"/></name>
		<position public="1"><c path="String"/></position>
		<charData public="1"><x path="haxe.xml.Access"/></charData>
		<recycle public="1" set="method" line="8"><f a="name:position:charData">
	<c path="String"/>
	<c path="String"/>
	<x path="haxe.xml.Access"/>
	<c path="funkin.backend.scripting.events.dialogue.DialogueCharStructureEvent"/>
</f></recycle>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* CANCEL this event to customize from 0 the xml structure part!</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueStructureEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueStructureEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<dialogueData public="1"><x path="haxe.xml.Access"/></dialogueData>
		<recycle public="1" set="method" line="8"><f a="dialogueData">
	<x path="haxe.xml.Access"/>
	<c path="funkin.backend.scripting.events.dialogue.DialogueStructureEvent"/>
</f></recycle>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* CANCEL this event to customize from 0 the xml structure part!</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<typedef path="funkin.backend.shaders.BlendModeShader" params="" file="source/funkin/backend/shaders/BlendModeEffect.hx" module="funkin.backend.shaders.BlendModeEffect"><a><uBlendColor><c path="openfl.display.ShaderParameter_Float"/></uBlendColor></a></typedef>
	<class path="funkin.backend.shaders.BlendModeEffect" params="" file="source/funkin/backend/shaders/BlendModeEffect.hx">
		<shader public="1" set="null"><t path="funkin.backend.shaders.BlendModeShader"/></shader>
		<color public="1" set="accessor">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":isVar"/></meta>
		</color>
		<set_color set="method" line="26"><f a="color">
	<x path="flixel.util.FlxColor"/>
	<x path="flixel.util.FlxColor"/>
</f></set_color>
		<new public="1" set="method" line="19"><f a="shader:color">
	<t path="funkin.backend.shaders.BlendModeShader"/>
	<x path="flixel.util.FlxColor"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="funkin.backend.shaders.FunkinShader" params="" file="source/funkin/backend/shaders/FunkinShader.hx">
		<extends path="flixel.graphics.tile.FlxGraphicsShader"/>
		<implements path="hscript.IHScriptCustomBehaviour"/>
		<__instanceFields expr="Type.getInstanceFields(FunkinShader)" line="26" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>Type.getInstanceFields(FunkinShader)</e></m></meta>
		</__instanceFields>
		<glslVer public="1" expr="&quot;120&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"120"</e></m></meta>
		</glslVer>
		<set_glFragmentSource set="method" line="48" override="1">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_glFragmentSource>
		<set_glVertexSource set="method" line="61" override="1">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_glVertexSource>
		<__initGL set="method" line="74" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__initGL>
		<__processGLData set="method" line="188" override="1">
			<f a="source:storageType">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__processGLData>
		<hget public="1" set="method" line="365"><f a="name">
	<c path="String"/>
	<d/>
</f></hget>
		<hset public="1" set="method" line="388"><f a="name:val">
	<c path="String"/>
	<d/>
	<d/>
</f></hset>
		<new public="1" set="method" line="37">
			<f a="frag:vert:?glslVer" v="::&quot;120&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ glslVer : "120" }</e></m></meta>
			<haxe_doc>* Creates a new shader from the specified fragment and vertex source.
	 * Accepts `#pragma header`.
	 * @param frag Fragment source (pass `null` to use default)
	 * @param vert Vertex source (pass `null` to use default)
	 * @param glslVer Version of GLSL to use (defaults to 120)</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
			<m n=":access"><e>openfl.display3D.Context3D</e></m>
			<m n=":access"><e>openfl.display3D.Program3D</e></m>
			<m n=":access"><e>openfl.display.ShaderInput</e></m>
			<m n=":access"><e>openfl.display.ShaderParameter</e></m>
		</meta>
	</class>
	<class path="funkin.backend.shaders.CustomShader" params="" file="source/funkin/backend/shaders/CustomShader.hx">
		<extends path="funkin.backend.shaders.FunkinShader"/>
		<path public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</path>
		<new public="1" set="method" line="24">
			<f a="name:?glslVersion" v=":&quot;120&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ glslVersion : "120" }</e></m></meta>
			<haxe_doc>* Creates a new custom shader
	 * @param name Name of the frag and vert files.
	 * @param glslVersion GLSL version to use. Defaults to `120`.</haxe_doc>
		</new>
		<haxe_doc>* Class for custom shaders.
 *
 * To create one, create a `shaders` folder in your assets/mod folder, then add a file named `my-shader.frag` or/and `my-shader.vert`.
 *
 * Non-existent shaders will only load the default one, and throw a warning in the console.
 *
 * To access the shader's uniform variables, use `shader.variable`</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.shaders.ShaderTemplates" params="" file="source/funkin/backend/shaders/FunkinShader.hx" module="funkin.backend.shaders.FunkinShader">
		<fragHeader final="1" public="1" set="null" expr="&quot;varying float openfl_Alphav;\r\nvarying vec4 openfl_ColorMultiplierv;\r\nvarying vec4 openfl_ColorOffsetv;\r\nvarying vec2 openfl_TextureCoordv;\r\n\r\nuniform bool openfl_HasColorTransform;\r\nuniform vec2 openfl_TextureSize;\r\nuniform sampler2D bitmap;\r\n\r\nuniform bool hasTransform;\r\nuniform bool hasColorTransform;\r\n\r\nvec4 flixel_texture2D(sampler2D bitmap, vec2 coord)\r\n{\r\n\tvec4 color = texture2D(bitmap, coord);\r\n\tif (!hasTransform)\r\n\t{\r\n\t\treturn color;\r\n\t}\r\n\r\n\tif (color.a == 0.0)\r\n\t{\r\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\r\n\t}\r\n\r\n\tif (!hasColorTransform)\r\n\t{\r\n\t\treturn color * openfl_Alphav;\r\n\t}\r\n\r\n\tcolor = vec4(color.rgb / color.a, color.a);\r\n\r\n\tmat4 colorMultiplier = mat4(0);\r\n\tcolorMultiplier[0][0] = openfl_ColorMultiplierv.x;\r\n\tcolorMultiplier[1][1] = openfl_ColorMultiplierv.y;\r\n\tcolorMultiplier[2][2] = openfl_ColorMultiplierv.z;\r\n\tcolorMultiplier[3][3] = openfl_ColorMultiplierv.w;\r\n\r\n\tcolor = clamp(openfl_ColorOffsetv + (color * colorMultiplier), 0.0, 1.0);\r\n\r\n\tif (color.a &gt; 0.0)\r\n\t{\r\n\t\treturn vec4(color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);\r\n\t}\r\n\treturn vec4(0.0, 0.0, 0.0, 0.0);\r\n}\r\n\r\nuniform vec4 _camSize;\r\n\r\nfloat map(float value, float min1, float max1, float min2, float max2) {\r\n\treturn min2 + (value - min1) * (max2 - min2) / (max1 - min1);\r\n}\r\n\r\nvec2 getCamPos(vec2 pos) {\r\n\tvec4 size = _camSize / vec4(openfl_TextureSize, openfl_TextureSize);\r\n\treturn vec2(map(pos.x, size.x, size.x + size.z, 0.0, 1.0), map(pos.y, size.y, size.y + size.w, 0.0, 1.0));\r\n}\r\nvec2 camToOg(vec2 pos) {\r\n\tvec4 size = _camSize / vec4(openfl_TextureSize, openfl_TextureSize);\r\n\treturn vec2(map(pos.x, 0.0, 1.0, size.x, size.x + size.z), map(pos.y, 0.0, 1.0, size.y, size.y + size.w));\r\n}\r\nvec4 textureCam(sampler2D bitmap, vec2 pos) {\r\n\treturn flixel_texture2D(bitmap, camToOg(pos));\r\n}&quot;" line="443" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"varying float openfl_Alphav;\r\nvarying vec4 openfl_ColorMultiplierv;\r\nvarying vec4 openfl_ColorOffsetv;\r\nvarying vec2 openfl_TextureCoordv;\r\n\r\nuniform bool openfl_HasColorTransform;\r\nuniform vec2 openfl_TextureSize;\r\nuniform sampler2D bitmap;\r\n\r\nuniform bool hasTransform;\r\nuniform bool hasColorTransform;\r\n\r\nvec4 flixel_texture2D(sampler2D bitmap, vec2 coord)\r\n{\r\n\tvec4 color = texture2D(bitmap, coord);\r\n\tif (!hasTransform)\r\n\t{\r\n\t\treturn color;\r\n\t}\r\n\r\n\tif (color.a == 0.0)\r\n\t{\r\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\r\n\t}\r\n\r\n\tif (!hasColorTransform)\r\n\t{\r\n\t\treturn color * openfl_Alphav;\r\n\t}\r\n\r\n\tcolor = vec4(color.rgb / color.a, color.a);\r\n\r\n\tmat4 colorMultiplier = mat4(0);\r\n\tcolorMultiplier[0][0] = openfl_ColorMultiplierv.x;\r\n\tcolorMultiplier[1][1] = openfl_ColorMultiplierv.y;\r\n\tcolorMultiplier[2][2] = openfl_ColorMultiplierv.z;\r\n\tcolorMultiplier[3][3] = openfl_ColorMultiplierv.w;\r\n\r\n\tcolor = clamp(openfl_ColorOffsetv + (color * colorMultiplier), 0.0, 1.0);\r\n\r\n\tif (color.a &gt; 0.0)\r\n\t{\r\n\t\treturn vec4(color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);\r\n\t}\r\n\treturn vec4(0.0, 0.0, 0.0, 0.0);\r\n}\r\n\r\nuniform vec4 _camSize;\r\n\r\nfloat map(float value, float min1, float max1, float min2, float max2) {\r\n\treturn min2 + (value - min1) * (max2 - min2) / (max1 - min1);\r\n}\r\n\r\nvec2 getCamPos(vec2 pos) {\r\n\tvec4 size = _camSize / vec4(openfl_TextureSize, openfl_TextureSize);\r\n\treturn vec2(map(pos.x, size.x, size.x + size.z, 0.0, 1.0), map(pos.y, size.y, size.y + size.w, 0.0, 1.0));\r\n}\r\nvec2 camToOg(vec2 pos) {\r\n\tvec4 size = _camSize / vec4(openfl_TextureSize, openfl_TextureSize);\r\n\treturn vec2(map(pos.x, 0.0, 1.0, size.x, size.x + size.z), map(pos.y, 0.0, 1.0, size.y, size.y + size.w));\r\n}\r\nvec4 textureCam(sampler2D bitmap, vec2 pos) {\r\n\treturn flixel_texture2D(bitmap, camToOg(pos));\r\n}"</e></m></meta>
		</fragHeader>
		<fragBody final="1" public="1" set="null" expr="&quot;vec4 color = texture2D (bitmap, openfl_TextureCoordv);\r\n\r\nif (color.a == 0.0) {\r\n\r\n\tgl_FragColor = vec4 (0.0, 0.0, 0.0, 0.0);\r\n\r\n} else if (openfl_HasColorTransform) {\r\n\r\n\tcolor = vec4 (color.rgb / color.a, color.a);\r\n\r\n\tmat4 colorMultiplier = mat4 (0);\r\n\tcolorMultiplier[0][0] = openfl_ColorMultiplierv.x;\r\n\tcolorMultiplier[1][1] = openfl_ColorMultiplierv.y;\r\n\tcolorMultiplier[2][2] = openfl_ColorMultiplierv.z;\r\n\tcolorMultiplier[3][3] = 1.0; // openfl_ColorMultiplierv.w;\r\n\r\n\tcolor = clamp (openfl_ColorOffsetv + (color * colorMultiplier), 0.0, 1.0);\r\n\r\n\tif (color.a &gt; 0.0) {\r\n\r\n\t\tgl_FragColor = vec4 (color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);\r\n\r\n\t} else {\r\n\r\n\t\tgl_FragColor = vec4 (0.0, 0.0, 0.0, 0.0);\r\n\r\n\t}\r\n\r\n} else {\r\n\r\n\tgl_FragColor = color * openfl_Alphav;\r\n\r\n}&quot;" line="508" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"vec4 color = texture2D (bitmap, openfl_TextureCoordv);\r\n\r\nif (color.a == 0.0) {\r\n\r\n\tgl_FragColor = vec4 (0.0, 0.0, 0.0, 0.0);\r\n\r\n} else if (openfl_HasColorTransform) {\r\n\r\n\tcolor = vec4 (color.rgb / color.a, color.a);\r\n\r\n\tmat4 colorMultiplier = mat4 (0);\r\n\tcolorMultiplier[0][0] = openfl_ColorMultiplierv.x;\r\n\tcolorMultiplier[1][1] = openfl_ColorMultiplierv.y;\r\n\tcolorMultiplier[2][2] = openfl_ColorMultiplierv.z;\r\n\tcolorMultiplier[3][3] = 1.0; // openfl_ColorMultiplierv.w;\r\n\r\n\tcolor = clamp (openfl_ColorOffsetv + (color * colorMultiplier), 0.0, 1.0);\r\n\r\n\tif (color.a &gt; 0.0) {\r\n\r\n\t\tgl_FragColor = vec4 (color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);\r\n\r\n\t} else {\r\n\r\n\t\tgl_FragColor = vec4 (0.0, 0.0, 0.0, 0.0);\r\n\r\n\t}\r\n\r\n} else {\r\n\r\n\tgl_FragColor = color * openfl_Alphav;\r\n\r\n}"</e></m></meta>
		</fragBody>
		<vertHeader final="1" public="1" set="null" expr="&quot;attribute float openfl_Alpha;\r\nattribute vec4 openfl_ColorMultiplier;\r\nattribute vec4 openfl_ColorOffset;\r\nattribute vec4 openfl_Position;\r\nattribute vec2 openfl_TextureCoord;\r\n\r\nvarying float openfl_Alphav;\r\nvarying vec4 openfl_ColorMultiplierv;\r\nvarying vec4 openfl_ColorOffsetv;\r\nvarying vec2 openfl_TextureCoordv;\r\n\r\nuniform mat4 openfl_Matrix;\r\nuniform bool openfl_HasColorTransform;\r\nuniform vec2 openfl_TextureSize;&quot;" line="541" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"attribute float openfl_Alpha;\r\nattribute vec4 openfl_ColorMultiplier;\r\nattribute vec4 openfl_ColorOffset;\r\nattribute vec4 openfl_Position;\r\nattribute vec2 openfl_TextureCoord;\r\n\r\nvarying float openfl_Alphav;\r\nvarying vec4 openfl_ColorMultiplierv;\r\nvarying vec4 openfl_ColorOffsetv;\r\nvarying vec2 openfl_TextureCoordv;\r\n\r\nuniform mat4 openfl_Matrix;\r\nuniform bool openfl_HasColorTransform;\r\nuniform vec2 openfl_TextureSize;"</e></m></meta>
		</vertHeader>
		<vertBody final="1" public="1" set="null" expr="&quot;openfl_Alphav = openfl_Alpha;\r\nopenfl_TextureCoordv = openfl_TextureCoord;\r\n\r\nif (openfl_HasColorTransform) {\r\n\r\n\topenfl_ColorMultiplierv = openfl_ColorMultiplier;\r\n\topenfl_ColorOffsetv = openfl_ColorOffset / 255.0;\r\n\r\n}\r\n\r\ngl_Position = openfl_Matrix * openfl_Position;&quot;" line="556" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"openfl_Alphav = openfl_Alpha;\r\nopenfl_TextureCoordv = openfl_TextureCoord;\r\n\r\nif (openfl_HasColorTransform) {\r\n\r\n\topenfl_ColorMultiplierv = openfl_ColorMultiplier;\r\n\topenfl_ColorOffsetv = openfl_ColorOffset / 255.0;\r\n\r\n}\r\n\r\ngl_Position = openfl_Matrix * openfl_Position;"</e></m></meta>
		</vertBody>
		<defaultVertexSource final="1" public="1" set="null" expr="&quot;#pragma header\r\n\r\nattribute float alpha;\r\nattribute vec4 colorMultiplier;\r\nattribute vec4 colorOffset;\r\nuniform bool hasColorTransform;\r\n\r\nvoid main(void)\r\n{\r\n\t#pragma body\r\n\r\n\topenfl_Alphav = openfl_Alpha * alpha;\r\n\r\n\tif (hasColorTransform)\r\n\t{\r\n\t\topenfl_ColorOffsetv = colorOffset / 255.0;\r\n\t\topenfl_ColorMultiplierv = colorMultiplier;\r\n\t}\r\n}&quot;" line="569" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"#pragma header\r\n\r\nattribute float alpha;\r\nattribute vec4 colorMultiplier;\r\nattribute vec4 colorOffset;\r\nuniform bool hasColorTransform;\r\n\r\nvoid main(void)\r\n{\r\n\t#pragma body\r\n\r\n\topenfl_Alphav = openfl_Alpha * alpha;\r\n\r\n\tif (hasColorTransform)\r\n\t{\r\n\t\topenfl_ColorOffsetv = colorOffset / 255.0;\r\n\t\topenfl_ColorMultiplierv = colorMultiplier;\r\n\t}\r\n}"</e></m></meta>
		</defaultVertexSource>
		<defaultFragmentSource final="1" public="1" set="null" expr="&quot;#pragma header\r\n\r\nvoid main(void)\r\n{\r\n\tgl_FragColor = flixel_texture2D(bitmap, openfl_TextureCoordv);\r\n}&quot;" line="591" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"#pragma header\r\n\r\nvoid main(void)\r\n{\r\n\tgl_FragColor = flixel_texture2D(bitmap, openfl_TextureCoordv);\r\n}"</e></m></meta>
		</defaultFragmentSource>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.shaders.ShaderTypeException" params="" file="source/funkin/backend/shaders/FunkinShader.hx" module="funkin.backend.shaders.FunkinShader">
		<extends path="haxe.Exception"/>
		<has><x path="Class"><d/></x></has>
		<want><x path="Class"><d/></x></want>
		<name><c path="String"/></name>
		<new public="1" set="method" line="604"><f a="name:has:want">
	<c path="String"/>
	<x path="Class"><d/></x>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.shaders.OverlayShader" params="" file="source/funkin/backend/shaders/OverlayShader.hx">
		<extends path="flixel.graphics.tile.FlxGraphicsShader"/>
		<uBlendColor public="1">
			<c path="openfl.display.ShaderParameter_Float"/>
			<meta><m n=":keep"/></meta>
		</uBlendColor>
		<new public="1" set="method" line="30">
			<f a=""><x path="Void"/></f>
			<meta><m n=":glFragmentSource"><e>"\r\n#pragma header\r\nuniform vec4 uBlendColor;\r\n\r\nvec3 blendLighten(base:Vec3, blend:Vec3) : Vec3 {\r\n\treturn mix(\r\n\t\t1.0 - 2.0 * (1.0 - base) * (1.0 - blend),\r\n\t\t2.0 * base * blend,\r\n\t\tstep( base, vec3(0.5) )\r\n\t);\r\n}\r\n\r\nvec4 blendLighten(vec4 base, vec4 blend, float opacity)\r\n{\r\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\r\n}\r\n\r\nvoid main()\r\n{\r\n\tvec4 base = texture2D(bitmap, openfl_TextureCoordv);\r\n\tgl_FragColor = blendLighten(base, uBlendColor, uBlendColor.a);\r\n}"</e></m></meta>
		</new>
		<meta>
			<m n=":build"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
		</meta>
	</class>
	<enum path="funkin.backend.shaders.WiggleEffectType" params="" file="source/funkin/backend/shaders/WiggleEffect.hx" module="funkin.backend.shaders.WiggleEffect">
		<DREAMY/>
		<WAVY/>
		<HEAT_WAVE_HORIZONTAL/>
		<HEAT_WAVE_VERTICAL/>
		<FLAG/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="funkin.backend.shaders.WiggleEffect" params="" file="source/funkin/backend/shaders/WiggleEffect.hx">
		<shader public="1" set="null" expr="new WiggleShader()">
			<c path="funkin.backend.shaders.WiggleShader"/>
			<meta><m n=":value"><e>new WiggleShader()</e></m></meta>
		</shader>
		<effectType public="1" set="accessor" expr="DREAMY">
			<e path="funkin.backend.shaders.WiggleEffectType"/>
			<meta><m n=":value"><e>DREAMY</e></m></meta>
		</effectType>
		<waveSpeed public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</waveSpeed>
		<waveFrequency public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</waveFrequency>
		<waveAmplitude public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</waveAmplitude>
		<update public="1" set="method" line="29"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<set_effectType set="method" line="34"><f a="v">
	<e path="funkin.backend.shaders.WiggleEffectType"/>
	<e path="funkin.backend.shaders.WiggleEffectType"/>
</f></set_effectType>
		<set_waveSpeed set="method" line="41"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_waveSpeed>
		<set_waveFrequency set="method" line="48"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_waveFrequency>
		<set_waveAmplitude set="method" line="55"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_waveAmplitude>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="funkin.backend.shaders.WiggleShader" params="" file="source/funkin/backend/shaders/WiggleEffect.hx" module="funkin.backend.shaders.WiggleEffect">
		<extends path="flixel.graphics.tile.FlxGraphicsShader"/>
		<tx public="1">
			<c path="openfl.display.ShaderParameter_Float"/>
			<meta><m n=":keep"/></meta>
		</tx>
		<uTime public="1">
			<c path="openfl.display.ShaderParameter_Float"/>
			<meta><m n=":keep"/></meta>
		</uTime>
		<effectType public="1">
			<c path="openfl.display.ShaderParameter_Int"/>
			<meta><m n=":keep"/></meta>
		</effectType>
		<uSpeed public="1">
			<c path="openfl.display.ShaderParameter_Float"/>
			<meta><m n=":keep"/></meta>
		</uSpeed>
		<uFrequency public="1">
			<c path="openfl.display.ShaderParameter_Float"/>
			<meta><m n=":keep"/></meta>
		</uFrequency>
		<uWaveAmplitude public="1">
			<c path="openfl.display.ShaderParameter_Float"/>
			<meta><m n=":keep"/></meta>
		</uWaveAmplitude>
		<new public="1" set="method" line="130">
			<f a=""><x path="Void"/></f>
			<meta><m n=":glFragmentSource"><e>"\r\n#pragma header\r\n//uniform float tx, ty; // x,y waves phase\r\nuniform float uTime;\r\n\r\nconst int EFFECT_TYPE_DREAMY = 0;\r\nconst int EFFECT_TYPE_WAVY = 1;\r\nconst int EFFECT_TYPE_HEAT_WAVE_HORIZONTAL = 2;\r\nconst int EFFECT_TYPE_HEAT_WAVE_VERTICAL = 3;\r\nconst int EFFECT_TYPE_FLAG = 4;\r\n\r\nuniform int effectType;\r\n\r\n/**\r\n\t* How fast the waves move over time\r\n\t*/\r\nuniform float uSpeed;\r\n\r\n/**\r\n\t* Number of waves over time\r\n\t*/\r\nuniform float uFrequency;\r\n\r\n/**\r\n\t* How much the pixels are going to stretch over the waves\r\n\t*/\r\nuniform float uWaveAmplitude;\r\n\r\nvec2 sineWave(vec2 pt)\r\n{\r\n\tfloat x = 0.0;\r\n\tfloat y = 0.0;\r\n\r\n\tif (effectType == EFFECT_TYPE_DREAMY)\r\n\t{\r\n\t\tfloat offsetX = sin(pt.y * uFrequency + uTime * uSpeed) * uWaveAmplitude;\r\n\t\tpt.x += offsetX; // * (pt.y - 1.0); // &lt;- Uncomment to stop bottom part of the screen from moving\r\n\t}\r\n\telse if (effectType == EFFECT_TYPE_WAVY)\r\n\t{\r\n\t\tfloat offsetY = sin(pt.x * uFrequency + uTime * uSpeed) * uWaveAmplitude;\r\n\t\tpt.y += offsetY; // * (pt.y - 1.0); // &lt;- Uncomment to stop bottom part of the screen from moving\r\n\t}\r\n\telse if (effectType == EFFECT_TYPE_HEAT_WAVE_HORIZONTAL)\r\n\t{\r\n\t\tx = sin(pt.x * uFrequency + uTime * uSpeed) * uWaveAmplitude;\r\n\t}\r\n\telse if (effectType == EFFECT_TYPE_HEAT_WAVE_VERTICAL)\r\n\t{\r\n\t\ty = sin(pt.y * uFrequency + uTime * uSpeed) * uWaveAmplitude;\r\n\t}\r\n\telse if (effectType == EFFECT_TYPE_FLAG)\r\n\t{\r\n\t\ty = sin(pt.y * uFrequency + 10.0 * pt.x + uTime * uSpeed) * uWaveAmplitude;\r\n\t\tx = sin(pt.x * uFrequency + 5.0 * pt.y + uTime * uSpeed) * uWaveAmplitude;\r\n\t}\r\n\r\n\treturn vec2(pt.x + x, pt.y + y);\r\n}\r\n\r\nvoid main()\r\n{\r\n\tvec2 uv = sineWave(openfl_TextureCoordv);\r\n\tgl_FragColor = texture2D(bitmap, uv);\r\n}"</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.CommandLineHandler" params="" file="source/funkin/backend/system/CommandLineHandler.hx">
		<parseCommandLine public="1" set="method" line="6" static="1"><f a="cmd">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></parseCommandLine>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.system.BPMChangeEvent" params="" file="source/funkin/backend/system/Conductor.hx" module="funkin.backend.system.Conductor"><a>
	<stepTime><x path="Float"/></stepTime>
	<songTime><x path="Float"/></songTime>
	<bpm><x path="Float"/></bpm>
</a></typedef>
	<class path="funkin.backend.system.Conductor" params="" file="source/funkin/backend/system/Conductor.hx">
		<onMeasureHit public="1" expr="new FlxTypedSignal()" line="20" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal()</e></m></meta>
			<haxe_doc>* FlxSignals</haxe_doc>
		</onMeasureHit>
		<onBeatHit public="1" expr="new FlxTypedSignal()" line="21" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal()</e></m></meta>
		</onBeatHit>
		<onStepHit public="1" expr="new FlxTypedSignal()" line="22" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal()</e></m></meta>
		</onStepHit>
		<onBPMChange public="1" expr="new FlxTypedSignal()" line="23" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<x path="Float"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal()</e></m></meta>
		</onBPMChange>
		<bpm public="1" expr="100" line="28" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>100</e></m></meta>
			<haxe_doc>* Current BPM</haxe_doc>
		</bpm>
		<crochet public="1" expr="((60 / bpm) * 1000)" line="33" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>((60 / bpm) * 1000)</e></m></meta>
			<haxe_doc>* Current Crochet (time per beat), in milliseconds.</haxe_doc>
		</crochet>
		<stepCrochet public="1" expr="crochet / 4" line="38" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>crochet / 4</e></m></meta>
			<haxe_doc>* Current StepCrochet (time per step), in milliseconds.</haxe_doc>
		</stepCrochet>
		<beatsPerMeasure public="1" expr="4" line="43" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>4</e></m></meta>
			<haxe_doc>* Number of beats per mesure (top number in time signature). Defaults to 4.</haxe_doc>
		</beatsPerMeasure>
		<stepsPerBeat public="1" expr="4" line="48" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>4</e></m></meta>
			<haxe_doc>* Number of steps per beat (bottom number in time signature). Defaults to 4.</haxe_doc>
		</stepsPerBeat>
		<songPosition public="1" get="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Current position of the song, in milliseconds.</haxe_doc>
		</songPosition>
		<get_songPosition set="method" line="55" static="1"><f a=""><x path="Float"/></f></get_songPosition>
		<songOffset public="1" expr="0" line="63" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Offset of the song</haxe_doc>
		</songOffset>
		<curStep public="1" expr="0" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current step</haxe_doc>
		</curStep>
		<curBeat public="1" expr="0" line="73" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current beat</haxe_doc>
		</curBeat>
		<curMeasure public="1" expr="0" line="78" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current measure</haxe_doc>
		</curMeasure>
		<curStepFloat public="1" expr="0" line="84" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current step, as a `Float` (ex: 4.94, instead of 4)</haxe_doc>
		</curStepFloat>
		<curBeatFloat public="1" expr="0" line="89" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current beat, as a `Float` (ex: 1.24, instead of 1)</haxe_doc>
		</curBeatFloat>
		<curMeasureFloat public="1" expr="0" line="94" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current measure, as a `Float` (ex: 1.24, instead of 1)</haxe_doc>
		</curMeasureFloat>
		<lastSongPos public="1" expr="0" line="97" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</lastSongPos>
		<offset public="1" expr="0" line="98" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</offset>
		<bpmChangeMap public="1" expr="[]" line="103" static="1">
			<c path="Array"><t path="funkin.backend.system.BPMChangeEvent"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Array of all BPM changes that have been mapped.</haxe_doc>
		</bpmChangeMap>
		<reset public="1" set="method" line="107" static="1"><f a=""><x path="Void"/></f></reset>
		<setupSong public="1" set="method" line="113" static="1"><f a="SONG">
	<t path="funkin.backend.chart.ChartData"/>
	<x path="Void"/>
</f></setupSong>
		<mapBPMChanges public="1" set="method" line="123" static="1">
			<f a="song">
				<t path="funkin.backend.chart.ChartData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Maps BPM changes from a song.
	 * @param song Song to map BPM changes from.</haxe_doc>
		</mapBPMChanges>
		<elapsed static="1"><x path="Float"/></elapsed>
		<init public="1" set="method" line="155" static="1"><f a=""><x path="Void"/></f></init>
		<__updateSongPos set="method" line="161" static="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></__updateSongPos>
		<onStateSwitch set="method" line="175" static="1"><f a="newState">
	<c path="flixel.FlxState"/>
	<x path="Void"/>
</f></onStateSwitch>
		<__lastChange static="1"><t path="funkin.backend.system.BPMChangeEvent"/></__lastChange>
		<__updateBeat static="1"><x path="Bool"/></__updateBeat>
		<__updateMeasure static="1"><x path="Bool"/></__updateMeasure>
		<update set="method" line="183" static="1"><f a=""><x path="Void"/></f></update>
		<changeBPM public="1" set="method" line="262" static="1">
			<f a="newBpm:?beatsPerMeasure:?stepsPerBeat" v=":4:4">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ stepsPerBeat : 4, beatsPerMeasure : 4 }</e></m></meta>
		</changeBPM>
		<getTimeForStep public="1" set="method" line="274" static="1"><f a="step">
	<x path="Float"/>
	<x path="Float"/>
</f></getTimeForStep>
		<getStepForTime public="1" set="method" line="288" static="1"><f a="time">
	<x path="Float"/>
	<x path="Float"/>
</f></getStepForTime>
		<getMeasureLength public="1" get="inline" set="null" line="303" static="1"><f a=""><x path="Float"/></f></getMeasureLength>
		<getMeasuresLength public="1" get="inline" set="null" line="305" static="1"><f a=""><x path="Float"/></f></getMeasuresLength>
		<new public="1" set="method" line="105">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="funkin.backend.system.Action" params="" file="source/funkin/backend/system/Controls.hx" module="funkin.backend.system.Controls">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.system._Controls.Action_Impl_" params="" file="source/funkin/backend/system/Controls.hx" private="1" module="funkin.backend.system.Controls" extern="1" final="1">
	<UP public="1" get="inline" set="null" expr="cast &quot;up&quot;" line="14" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "up"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UP>
	<LEFT public="1" get="inline" set="null" expr="cast &quot;left&quot;" line="15" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "left"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFT>
	<RIGHT public="1" get="inline" set="null" expr="cast &quot;right&quot;" line="16" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "right"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHT>
	<DOWN public="1" get="inline" set="null" expr="cast &quot;down&quot;" line="17" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "down"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DOWN>
	<UP_P public="1" get="inline" set="null" expr="cast &quot;up-press&quot;" line="18" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "up-press"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UP_P>
	<LEFT_P public="1" get="inline" set="null" expr="cast &quot;left-press&quot;" line="19" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "left-press"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFT_P>
	<RIGHT_P public="1" get="inline" set="null" expr="cast &quot;right-press&quot;" line="20" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "right-press"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHT_P>
	<DOWN_P public="1" get="inline" set="null" expr="cast &quot;down-press&quot;" line="21" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "down-press"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DOWN_P>
	<UP_R public="1" get="inline" set="null" expr="cast &quot;up-release&quot;" line="22" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "up-release"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UP_R>
	<LEFT_R public="1" get="inline" set="null" expr="cast &quot;left-release&quot;" line="23" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "left-release"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFT_R>
	<RIGHT_R public="1" get="inline" set="null" expr="cast &quot;right-release&quot;" line="24" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "right-release"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHT_R>
	<DOWN_R public="1" get="inline" set="null" expr="cast &quot;down-release&quot;" line="25" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "down-release"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DOWN_R>
	<NOTE_UP public="1" get="inline" set="null" expr="cast &quot;note-up&quot;" line="28" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "note-up"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOTE_UP>
	<NOTE_LEFT public="1" get="inline" set="null" expr="cast &quot;note-left&quot;" line="29" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "note-left"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOTE_LEFT>
	<NOTE_RIGHT public="1" get="inline" set="null" expr="cast &quot;note-right&quot;" line="30" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "note-right"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOTE_RIGHT>
	<NOTE_DOWN public="1" get="inline" set="null" expr="cast &quot;note-down&quot;" line="31" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "note-down"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOTE_DOWN>
	<NOTE_UP_P public="1" get="inline" set="null" expr="cast &quot;note-up-press&quot;" line="32" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "note-up-press"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOTE_UP_P>
	<NOTE_LEFT_P public="1" get="inline" set="null" expr="cast &quot;note-left-press&quot;" line="33" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "note-left-press"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOTE_LEFT_P>
	<NOTE_RIGHT_P public="1" get="inline" set="null" expr="cast &quot;note-right-press&quot;" line="34" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "note-right-press"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOTE_RIGHT_P>
	<NOTE_DOWN_P public="1" get="inline" set="null" expr="cast &quot;note-down-press&quot;" line="35" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "note-down-press"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOTE_DOWN_P>
	<NOTE_UP_R public="1" get="inline" set="null" expr="cast &quot;note-up-release&quot;" line="36" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "note-up-release"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOTE_UP_R>
	<NOTE_LEFT_R public="1" get="inline" set="null" expr="cast &quot;note-left-release&quot;" line="37" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "note-left-release"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOTE_LEFT_R>
	<NOTE_RIGHT_R public="1" get="inline" set="null" expr="cast &quot;note-right-release&quot;" line="38" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "note-right-release"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOTE_RIGHT_R>
	<NOTE_DOWN_R public="1" get="inline" set="null" expr="cast &quot;note-down-release&quot;" line="39" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "note-down-release"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOTE_DOWN_R>
	<ACCEPT public="1" get="inline" set="null" expr="cast &quot;accept&quot;" line="41" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "accept"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ACCEPT>
	<BACK public="1" get="inline" set="null" expr="cast &quot;back&quot;" line="42" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "back"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BACK>
	<PAUSE public="1" get="inline" set="null" expr="cast &quot;pause&quot;" line="43" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "pause"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PAUSE>
	<RESET public="1" get="inline" set="null" expr="cast &quot;reset&quot;" line="44" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "reset"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RESET>
	<CHEAT public="1" get="inline" set="null" expr="cast &quot;cheat&quot;" line="45" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "cheat"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CHEAT>
	<SWITCHMOD public="1" get="inline" set="null" expr="cast &quot;switchmod&quot;" line="46" static="1">
		<x path="funkin.backend.system.Action"/>
		<meta>
			<m n=":value"><e>cast "switchmod"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SWITCHMOD>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.system._Controls.Action_Impl_" params="" file="source/funkin/backend/system/Controls.hx" private="1" module="funkin.backend.system.Controls" extern="1" final="1">
		<UP public="1" get="inline" set="null" expr="cast &quot;up&quot;" line="14" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "up"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UP>
		<LEFT public="1" get="inline" set="null" expr="cast &quot;left&quot;" line="15" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "left"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" expr="cast &quot;right&quot;" line="16" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "right"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHT>
		<DOWN public="1" get="inline" set="null" expr="cast &quot;down&quot;" line="17" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "down"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DOWN>
		<UP_P public="1" get="inline" set="null" expr="cast &quot;up-press&quot;" line="18" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "up-press"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UP_P>
		<LEFT_P public="1" get="inline" set="null" expr="cast &quot;left-press&quot;" line="19" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "left-press"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFT_P>
		<RIGHT_P public="1" get="inline" set="null" expr="cast &quot;right-press&quot;" line="20" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "right-press"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHT_P>
		<DOWN_P public="1" get="inline" set="null" expr="cast &quot;down-press&quot;" line="21" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "down-press"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DOWN_P>
		<UP_R public="1" get="inline" set="null" expr="cast &quot;up-release&quot;" line="22" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "up-release"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UP_R>
		<LEFT_R public="1" get="inline" set="null" expr="cast &quot;left-release&quot;" line="23" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "left-release"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFT_R>
		<RIGHT_R public="1" get="inline" set="null" expr="cast &quot;right-release&quot;" line="24" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "right-release"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHT_R>
		<DOWN_R public="1" get="inline" set="null" expr="cast &quot;down-release&quot;" line="25" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "down-release"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DOWN_R>
		<NOTE_UP public="1" get="inline" set="null" expr="cast &quot;note-up&quot;" line="28" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "note-up"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOTE_UP>
		<NOTE_LEFT public="1" get="inline" set="null" expr="cast &quot;note-left&quot;" line="29" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "note-left"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOTE_LEFT>
		<NOTE_RIGHT public="1" get="inline" set="null" expr="cast &quot;note-right&quot;" line="30" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "note-right"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOTE_RIGHT>
		<NOTE_DOWN public="1" get="inline" set="null" expr="cast &quot;note-down&quot;" line="31" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "note-down"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOTE_DOWN>
		<NOTE_UP_P public="1" get="inline" set="null" expr="cast &quot;note-up-press&quot;" line="32" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "note-up-press"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOTE_UP_P>
		<NOTE_LEFT_P public="1" get="inline" set="null" expr="cast &quot;note-left-press&quot;" line="33" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "note-left-press"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOTE_LEFT_P>
		<NOTE_RIGHT_P public="1" get="inline" set="null" expr="cast &quot;note-right-press&quot;" line="34" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "note-right-press"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOTE_RIGHT_P>
		<NOTE_DOWN_P public="1" get="inline" set="null" expr="cast &quot;note-down-press&quot;" line="35" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "note-down-press"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOTE_DOWN_P>
		<NOTE_UP_R public="1" get="inline" set="null" expr="cast &quot;note-up-release&quot;" line="36" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "note-up-release"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOTE_UP_R>
		<NOTE_LEFT_R public="1" get="inline" set="null" expr="cast &quot;note-left-release&quot;" line="37" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "note-left-release"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOTE_LEFT_R>
		<NOTE_RIGHT_R public="1" get="inline" set="null" expr="cast &quot;note-right-release&quot;" line="38" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "note-right-release"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOTE_RIGHT_R>
		<NOTE_DOWN_R public="1" get="inline" set="null" expr="cast &quot;note-down-release&quot;" line="39" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "note-down-release"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOTE_DOWN_R>
		<ACCEPT public="1" get="inline" set="null" expr="cast &quot;accept&quot;" line="41" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "accept"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ACCEPT>
		<BACK public="1" get="inline" set="null" expr="cast &quot;back&quot;" line="42" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "back"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BACK>
		<PAUSE public="1" get="inline" set="null" expr="cast &quot;pause&quot;" line="43" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "pause"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PAUSE>
		<RESET public="1" get="inline" set="null" expr="cast &quot;reset&quot;" line="44" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "reset"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RESET>
		<CHEAT public="1" get="inline" set="null" expr="cast &quot;cheat&quot;" line="45" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "cheat"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CHEAT>
		<SWITCHMOD public="1" get="inline" set="null" expr="cast &quot;switchmod&quot;" line="46" static="1">
			<x path="funkin.backend.system.Action"/>
			<meta>
				<m n=":value"><e>cast "switchmod"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SWITCHMOD>
		<meta><m n=":enum"/></meta>
	</class>
	<enum path="funkin.backend.system.Device" params="" file="source/funkin/backend/system/Controls.hx" module="funkin.backend.system.Controls">
		<Keys/>
		<Gamepad a="id"><x path="Int"/></Gamepad>
	</enum>
	<enum path="funkin.backend.system.Control" params="" file="source/funkin/backend/system/Controls.hx" module="funkin.backend.system.Controls">
		<UP/>
		<LEFT/>
		<RIGHT/>
		<DOWN/>
		<NOTE_UP/>
		<NOTE_LEFT/>
		<NOTE_RIGHT/>
		<NOTE_DOWN/>
		<RESET/>
		<ACCEPT/>
		<BACK/>
		<PAUSE/>
		<CHEAT/>
		<SWITCHMOD/>
		<haxe_doc>* Since, in many cases multiple actions should use similar keys, we don't want the
 * rebinding UI to list every action. ActionBinders are what the user perceives as
 * an input so, for instance, they can't set jump-press and jump-release to different keys.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="funkin.backend.system.KeyboardScheme" params="" file="source/funkin/backend/system/Controls.hx" module="funkin.backend.system.Controls">
		<Solo/>
		<Duo a="first"><x path="Bool"/></Duo>
		<None/>
		<Custom/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="funkin.backend.system.Controls" params="" file="source/funkin/backend/system/Controls.hx">
		<extends path="flixel.input.actions.FlxActionSet"/>
		<init set="method" line="476" static="1"><f a=""><x path="Void"/></f></init>
		<addKeys get="inline" set="null" line="651" static="1"><f a="action:keys:state">
	<c path="flixel.input.actions.FlxActionDigital"/>
	<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
	<x path="flixel.input.FlxInputState"/>
	<x path="Void"/>
</f></addKeys>
		<removeKeys set="method" line="657" static="1"><f a="action:keys">
	<c path="flixel.input.actions.FlxActionDigital"/>
	<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
	<x path="Void"/>
</f></removeKeys>
		<addButtons get="inline" set="null" line="836" static="1"><f a="action:buttons:state:id">
	<c path="flixel.input.actions.FlxActionDigital"/>
	<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
	<x path="flixel.input.FlxInputState"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addButtons>
		<removeButtons set="method" line="842" static="1"><f a="action:gamepadID:buttons">
	<c path="flixel.input.actions.FlxActionDigital"/>
	<x path="Int"/>
	<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
	<x path="Void"/>
</f></removeButtons>
		<isDevice set="method" line="887" static="1"><f a="input:device">
	<c path="flixel.input.actions.FlxActionInput"/>
	<e path="funkin.backend.system.Device"/>
	<x path="Bool"/>
</f></isDevice>
		<isGamepad get="inline" set="null" line="896" static="1"><f a="input:deviceID">
	<c path="flixel.input.actions.FlxActionInput"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></isGamepad>
		<_up expr="new FlxActionDigital(Action.UP)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.UP)</e></m></meta>
		</_up>
		<_left expr="new FlxActionDigital(Action.LEFT)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.LEFT)</e></m></meta>
		</_left>
		<_right expr="new FlxActionDigital(Action.RIGHT)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.RIGHT)</e></m></meta>
		</_right>
		<_down expr="new FlxActionDigital(Action.DOWN)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.DOWN)</e></m></meta>
		</_down>
		<_upP expr="new FlxActionDigital(Action.UP_P)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.UP_P)</e></m></meta>
		</_upP>
		<_leftP expr="new FlxActionDigital(Action.LEFT_P)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.LEFT_P)</e></m></meta>
		</_leftP>
		<_rightP expr="new FlxActionDigital(Action.RIGHT_P)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.RIGHT_P)</e></m></meta>
		</_rightP>
		<_downP expr="new FlxActionDigital(Action.DOWN_P)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.DOWN_P)</e></m></meta>
		</_downP>
		<_upR expr="new FlxActionDigital(Action.UP_R)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.UP_R)</e></m></meta>
		</_upR>
		<_leftR expr="new FlxActionDigital(Action.LEFT_R)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.LEFT_R)</e></m></meta>
		</_leftR>
		<_rightR expr="new FlxActionDigital(Action.RIGHT_R)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.RIGHT_R)</e></m></meta>
		</_rightR>
		<_downR expr="new FlxActionDigital(Action.DOWN_R)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.DOWN_R)</e></m></meta>
		</_downR>
		<_noteUp expr="new FlxActionDigital(Action.NOTE_UP)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.NOTE_UP)</e></m></meta>
		</_noteUp>
		<_noteLeft expr="new FlxActionDigital(Action.NOTE_LEFT)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.NOTE_LEFT)</e></m></meta>
		</_noteLeft>
		<_noteRight expr="new FlxActionDigital(Action.NOTE_RIGHT)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.NOTE_RIGHT)</e></m></meta>
		</_noteRight>
		<_noteDown expr="new FlxActionDigital(Action.NOTE_DOWN)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.NOTE_DOWN)</e></m></meta>
		</_noteDown>
		<_noteUpP expr="new FlxActionDigital(Action.NOTE_UP_P)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.NOTE_UP_P)</e></m></meta>
		</_noteUpP>
		<_noteLeftP expr="new FlxActionDigital(Action.NOTE_LEFT_P)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.NOTE_LEFT_P)</e></m></meta>
		</_noteLeftP>
		<_noteRightP expr="new FlxActionDigital(Action.NOTE_RIGHT_P)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.NOTE_RIGHT_P)</e></m></meta>
		</_noteRightP>
		<_noteDownP expr="new FlxActionDigital(Action.NOTE_DOWN_P)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.NOTE_DOWN_P)</e></m></meta>
		</_noteDownP>
		<_noteUpR expr="new FlxActionDigital(Action.NOTE_UP_R)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.NOTE_UP_R)</e></m></meta>
		</_noteUpR>
		<_noteLeftR expr="new FlxActionDigital(Action.NOTE_LEFT_R)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.NOTE_LEFT_R)</e></m></meta>
		</_noteLeftR>
		<_noteRightR expr="new FlxActionDigital(Action.NOTE_RIGHT_R)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.NOTE_RIGHT_R)</e></m></meta>
		</_noteRightR>
		<_noteDownR expr="new FlxActionDigital(Action.NOTE_DOWN_R)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.NOTE_DOWN_R)</e></m></meta>
		</_noteDownR>
		<_accept expr="new FlxActionDigital(Action.ACCEPT)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.ACCEPT)</e></m></meta>
		</_accept>
		<_back expr="new FlxActionDigital(Action.BACK)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.BACK)</e></m></meta>
		</_back>
		<_pause expr="new FlxActionDigital(Action.PAUSE)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.PAUSE)</e></m></meta>
		</_pause>
		<_reset expr="new FlxActionDigital(Action.RESET)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.RESET)</e></m></meta>
		</_reset>
		<_cheat expr="new FlxActionDigital(Action.CHEAT)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.CHEAT)</e></m></meta>
		</_cheat>
		<_switchMod expr="new FlxActionDigital(Action.SWITCHMOD)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital(Action.SWITCHMOD)</e></m></meta>
		</_switchMod>
		<byName expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="flixel.input.actions.FlxActionDigital"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</byName>
		<gamepadsAdded public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</gamepadsAdded>
		<keyboardScheme public="1" expr="KeyboardScheme.None">
			<e path="funkin.backend.system.KeyboardScheme"/>
			<meta><m n=":value"><e>KeyboardScheme.None</e></m></meta>
		</keyboardScheme>
		<UP public="1" get="accessor" set="accessor"><x path="Bool"/></UP>
		<get_UP get="inline" set="null" line="138"><f a=""><x path="Bool"/></f></get_UP>
		<set_UP get="inline" set="null" line="141"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_UP>
		<LEFT public="1" get="accessor" set="accessor"><x path="Bool"/></LEFT>
		<get_LEFT get="inline" set="null" line="146"><f a=""><x path="Bool"/></f></get_LEFT>
		<set_LEFT get="inline" set="null" line="149"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_LEFT>
		<RIGHT public="1" get="accessor" set="accessor"><x path="Bool"/></RIGHT>
		<get_RIGHT get="inline" set="null" line="154"><f a=""><x path="Bool"/></f></get_RIGHT>
		<set_RIGHT get="inline" set="null" line="157"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_RIGHT>
		<DOWN public="1" get="accessor" set="accessor"><x path="Bool"/></DOWN>
		<get_DOWN get="inline" set="null" line="162"><f a=""><x path="Bool"/></f></get_DOWN>
		<set_DOWN get="inline" set="null" line="165"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DOWN>
		<UP_P public="1" get="accessor" set="accessor"><x path="Bool"/></UP_P>
		<get_UP_P get="inline" set="null" line="170"><f a=""><x path="Bool"/></f></get_UP_P>
		<set_UP_P get="inline" set="null" line="173"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_UP_P>
		<LEFT_P public="1" get="accessor" set="accessor"><x path="Bool"/></LEFT_P>
		<get_LEFT_P get="inline" set="null" line="178"><f a=""><x path="Bool"/></f></get_LEFT_P>
		<set_LEFT_P get="inline" set="null" line="181"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_LEFT_P>
		<RIGHT_P public="1" get="accessor" set="accessor"><x path="Bool"/></RIGHT_P>
		<get_RIGHT_P get="inline" set="null" line="186"><f a=""><x path="Bool"/></f></get_RIGHT_P>
		<set_RIGHT_P get="inline" set="null" line="189"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_RIGHT_P>
		<DOWN_P public="1" get="accessor" set="accessor"><x path="Bool"/></DOWN_P>
		<get_DOWN_P get="inline" set="null" line="194"><f a=""><x path="Bool"/></f></get_DOWN_P>
		<set_DOWN_P get="inline" set="null" line="197"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DOWN_P>
		<UP_R public="1" get="accessor" set="accessor"><x path="Bool"/></UP_R>
		<get_UP_R get="inline" set="null" line="202"><f a=""><x path="Bool"/></f></get_UP_R>
		<set_UP_R get="inline" set="null" line="205"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_UP_R>
		<LEFT_R public="1" get="accessor" set="accessor"><x path="Bool"/></LEFT_R>
		<get_LEFT_R get="inline" set="null" line="210"><f a=""><x path="Bool"/></f></get_LEFT_R>
		<set_LEFT_R get="inline" set="null" line="213"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_LEFT_R>
		<RIGHT_R public="1" get="accessor" set="accessor"><x path="Bool"/></RIGHT_R>
		<get_RIGHT_R get="inline" set="null" line="218"><f a=""><x path="Bool"/></f></get_RIGHT_R>
		<set_RIGHT_R get="inline" set="null" line="221"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_RIGHT_R>
		<DOWN_R public="1" get="accessor" set="accessor"><x path="Bool"/></DOWN_R>
		<get_DOWN_R get="inline" set="null" line="226"><f a=""><x path="Bool"/></f></get_DOWN_R>
		<set_DOWN_R get="inline" set="null" line="229"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DOWN_R>
		<NOTE_UP public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_UP>
		<get_NOTE_UP get="inline" set="null" line="234"><f a=""><x path="Bool"/></f></get_NOTE_UP>
		<set_NOTE_UP get="inline" set="null" line="237"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_UP>
		<NOTE_LEFT public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_LEFT>
		<get_NOTE_LEFT get="inline" set="null" line="242"><f a=""><x path="Bool"/></f></get_NOTE_LEFT>
		<set_NOTE_LEFT get="inline" set="null" line="245"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_LEFT>
		<NOTE_RIGHT public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_RIGHT>
		<get_NOTE_RIGHT get="inline" set="null" line="250"><f a=""><x path="Bool"/></f></get_NOTE_RIGHT>
		<set_NOTE_RIGHT get="inline" set="null" line="253"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_RIGHT>
		<NOTE_DOWN public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_DOWN>
		<get_NOTE_DOWN get="inline" set="null" line="258"><f a=""><x path="Bool"/></f></get_NOTE_DOWN>
		<set_NOTE_DOWN get="inline" set="null" line="261"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_DOWN>
		<NOTE_UP_P public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_UP_P>
		<get_NOTE_UP_P get="inline" set="null" line="266"><f a=""><x path="Bool"/></f></get_NOTE_UP_P>
		<set_NOTE_UP_P get="inline" set="null" line="269"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_UP_P>
		<NOTE_LEFT_P public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_LEFT_P>
		<get_NOTE_LEFT_P get="inline" set="null" line="274"><f a=""><x path="Bool"/></f></get_NOTE_LEFT_P>
		<set_NOTE_LEFT_P get="inline" set="null" line="277"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_LEFT_P>
		<NOTE_RIGHT_P public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_RIGHT_P>
		<get_NOTE_RIGHT_P get="inline" set="null" line="282"><f a=""><x path="Bool"/></f></get_NOTE_RIGHT_P>
		<set_NOTE_RIGHT_P get="inline" set="null" line="285"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_RIGHT_P>
		<NOTE_DOWN_P public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_DOWN_P>
		<get_NOTE_DOWN_P get="inline" set="null" line="290"><f a=""><x path="Bool"/></f></get_NOTE_DOWN_P>
		<set_NOTE_DOWN_P get="inline" set="null" line="293"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_DOWN_P>
		<NOTE_UP_R public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_UP_R>
		<get_NOTE_UP_R get="inline" set="null" line="298"><f a=""><x path="Bool"/></f></get_NOTE_UP_R>
		<set_NOTE_UP_R get="inline" set="null" line="301"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_UP_R>
		<NOTE_LEFT_R public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_LEFT_R>
		<get_NOTE_LEFT_R get="inline" set="null" line="306"><f a=""><x path="Bool"/></f></get_NOTE_LEFT_R>
		<set_NOTE_LEFT_R get="inline" set="null" line="309"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_LEFT_R>
		<NOTE_RIGHT_R public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_RIGHT_R>
		<get_NOTE_RIGHT_R get="inline" set="null" line="314"><f a=""><x path="Bool"/></f></get_NOTE_RIGHT_R>
		<set_NOTE_RIGHT_R get="inline" set="null" line="317"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_RIGHT_R>
		<NOTE_DOWN_R public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_DOWN_R>
		<get_NOTE_DOWN_R get="inline" set="null" line="322"><f a=""><x path="Bool"/></f></get_NOTE_DOWN_R>
		<set_NOTE_DOWN_R get="inline" set="null" line="325"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_DOWN_R>
		<ACCEPT public="1" get="accessor" set="accessor"><x path="Bool"/></ACCEPT>
		<get_ACCEPT get="inline" set="null" line="330"><f a=""><x path="Bool"/></f></get_ACCEPT>
		<set_ACCEPT get="inline" set="null" line="333"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ACCEPT>
		<BACK public="1" get="accessor" set="accessor"><x path="Bool"/></BACK>
		<get_BACK get="inline" set="null" line="338"><f a=""><x path="Bool"/></f></get_BACK>
		<set_BACK get="inline" set="null" line="341"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_BACK>
		<PAUSE public="1" get="accessor" set="accessor"><x path="Bool"/></PAUSE>
		<get_PAUSE get="inline" set="null" line="346"><f a=""><x path="Bool"/></f></get_PAUSE>
		<set_PAUSE get="inline" set="null" line="349"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_PAUSE>
		<RESET public="1" get="accessor" set="accessor"><x path="Bool"/></RESET>
		<get_RESET get="inline" set="null" line="354"><f a=""><x path="Bool"/></f></get_RESET>
		<set_RESET get="inline" set="null" line="357"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_RESET>
		<CHEAT public="1" get="accessor" set="accessor"><x path="Bool"/></CHEAT>
		<get_CHEAT get="inline" set="null" line="362"><f a=""><x path="Bool"/></f></get_CHEAT>
		<set_CHEAT get="inline" set="null" line="365"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_CHEAT>
		<SWITCHMOD public="1" get="accessor" set="accessor"><x path="Bool"/></SWITCHMOD>
		<get_SWITCHMOD get="inline" set="null" line="370"><f a=""><x path="Bool"/></f></get_SWITCHMOD>
		<set_SWITCHMOD get="inline" set="null" line="373"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_SWITCHMOD>
		<update public="1" set="method" line="419" override="1"><f a=""><x path="Void"/></f></update>
		<checkByName public="1" set="method" line="425"><f a="name">
	<x path="funkin.backend.system.Action"/>
	<x path="Bool"/>
</f></checkByName>
		<getKeyName public="1" set="method" line="434"><f a="control">
	<e path="funkin.backend.system.Control"/>
	<c path="String"/>
</f></getKeyName>
		<getDialogueName public="1" set="method" line="439"><f a="action">
	<c path="flixel.input.actions.FlxActionDigital"/>
	<c path="String"/>
</f></getDialogueName>
		<getDialogueNameFromToken public="1" set="method" line="450"><f a="token">
	<c path="String"/>
	<c path="String"/>
</f></getDialogueNameFromToken>
		<getActionFromControl set="method" line="455"><f a="control">
	<e path="funkin.backend.system.Control"/>
	<c path="flixel.input.actions.FlxActionDigital"/>
</f></getActionFromControl>
		<forEachBound set="method" line="488">
			<f a="control:func">
				<e path="funkin.backend.system.Control"/>
				<f a=":">
					<c path="flixel.input.actions.FlxActionDigital"/>
					<x path="flixel.input.FlxInputState"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Calls a function passing each action bound by the specified control
	 * @param control
	 * @param func
	 * @return -&gt;Void)</haxe_doc>
		</forEachBound>
		<replaceBinding public="1" set="method" line="539"><f a="control:device:?toAdd:?toRemove">
	<e path="funkin.backend.system.Control"/>
	<e path="funkin.backend.system.Device"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></replaceBinding>
		<copyFrom public="1" set="method" line="560"><f a="controls:?device">
	<c path="funkin.backend.system.Controls"/>
	<e path="funkin.backend.system.Device"/>
	<x path="Void"/>
</f></copyFrom>
		<copyTo public="1" get="inline" set="null" line="606"><f a="controls:?device">
	<c path="funkin.backend.system.Controls"/>
	<e path="funkin.backend.system.Device"/>
	<x path="Void"/>
</f></copyTo>
		<mergeKeyboardScheme set="method" line="611"><f a="scheme">
	<e path="funkin.backend.system.KeyboardScheme"/>
	<x path="Void"/>
</f></mergeKeyboardScheme>
		<bindKeys public="1" set="method" line="629">
			<f a="control:keys">
				<e path="funkin.backend.system.Control"/>
				<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets all actions that pertain to the binder to trigger when the supplied keys are used.
	 * If binder is a literal you can inline this</haxe_doc>
		</bindKeys>
		<unbindKeys public="1" set="method" line="642">
			<f a="control:keys">
				<e path="funkin.backend.system.Control"/>
				<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets all actions that pertain to the binder to trigger when the supplied keys are used.
	 * If binder is a literal you can inline this</haxe_doc>
		</unbindKeys>
		<setKeyboardScheme public="1" set="method" line="668">
			<f a="scheme:?reset" v=":true">
				<e path="funkin.backend.system.KeyboardScheme"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ reset : true }</e></m></meta>
		</setKeyboardScheme>
		<removeKeyboard set="method" line="724"><f a=""><x path="Void"/></f></removeKeyboard>
		<addGamepad public="1" set="method" line="738"><f a="id:?buttonMap">
	<x path="Int"/>
	<t path="Map">
		<e path="funkin.backend.system.Control"/>
		<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
	</t>
	<x path="Void"/>
</f></addGamepad>
		<addGamepadLiteral get="inline" set="null" line="751"><f a="id:?buttonMap">
	<x path="Int"/>
	<t path="Map">
		<e path="funkin.backend.system.Control"/>
		<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
	</t>
	<x path="Void"/>
</f></addGamepadLiteral>
		<removeGamepad public="1" set="method" line="764">
			<f a="?deviceID" v="FlxInputDeviceID.ALL">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ deviceID : FlxInputDeviceID.ALL }</e></m></meta>
		</removeGamepad>
		<addDefaultGamepad public="1" set="method" line="780"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></addDefaultGamepad>
		<bindButtons public="1" set="method" line="814">
			<f a="control:id:buttons">
				<e path="funkin.backend.system.Control"/>
				<x path="Int"/>
				<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets all actions that pertain to the binder to trigger when the supplied keys are used.
	 * If binder is a literal you can inline this</haxe_doc>
		</bindButtons>
		<unbindButtons public="1" set="method" line="827">
			<f a="control:gamepadID:buttons">
				<e path="funkin.backend.system.Control"/>
				<x path="Int"/>
				<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets all actions that pertain to the binder to trigger when the supplied keys are used.
	 * If binder is a literal you can inline this</haxe_doc>
		</unbindButtons>
		<getInputsFor public="1" set="method" line="853"><f a="control:device:?list">
	<e path="funkin.backend.system.Control"/>
	<e path="funkin.backend.system.Device"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></getInputsFor>
		<removeDevice public="1" set="method" line="876"><f a="device">
	<e path="funkin.backend.system.Device"/>
	<x path="Void"/>
</f></removeDevice>
		<new public="1" set="method" line="375">
			<f a="name:?scheme" v=":None">
				<c path="String"/>
				<e path="funkin.backend.system.KeyboardScheme"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scheme : None }</e></m></meta>
		</new>
		<haxe_doc>* A list of actions that a player would invoke via some input device.
 * Uses FlxActions to funnel various inputs to a single action.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noCustomClass"/>
		</meta>
	</class>
	<abstract path="funkin.backend.system.ErrorCode" params="" file="source/funkin/backend/system/ErrorCode.hx">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.system._ErrorCode.ErrorCode_Impl_" params="" file="source/funkin/backend/system/ErrorCode.hx" private="1" module="funkin.backend.system.ErrorCode" extern="1" final="1">
	<OK public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
		<x path="funkin.backend.system.ErrorCode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</OK>
	<FAILED public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="funkin.backend.system.ErrorCode"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</FAILED>
	<MISSING_PROPERTY public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
		<x path="funkin.backend.system.ErrorCode"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MISSING_PROPERTY>
	<TYPE_INCORRECT public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="funkin.backend.system.ErrorCode"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TYPE_INCORRECT>
	<VALUE_NULL public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
		<x path="funkin.backend.system.ErrorCode"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VALUE_NULL>
	<REFLECT_ERROR public="1" get="inline" set="null" expr="cast 5" line="9" static="1">
		<x path="funkin.backend.system.ErrorCode"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</REFLECT_ERROR>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.system._ErrorCode.ErrorCode_Impl_" params="" file="source/funkin/backend/system/ErrorCode.hx" private="1" module="funkin.backend.system.ErrorCode" extern="1" final="1">
		<OK public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
			<x path="funkin.backend.system.ErrorCode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</OK>
		<FAILED public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="funkin.backend.system.ErrorCode"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</FAILED>
		<MISSING_PROPERTY public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
			<x path="funkin.backend.system.ErrorCode"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MISSING_PROPERTY>
		<TYPE_INCORRECT public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="funkin.backend.system.ErrorCode"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TYPE_INCORRECT>
		<VALUE_NULL public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
			<x path="funkin.backend.system.ErrorCode"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VALUE_NULL>
		<REFLECT_ERROR public="1" get="inline" set="null" expr="cast 5" line="9" static="1">
			<x path="funkin.backend.system.ErrorCode"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</REFLECT_ERROR>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.backend.system.FunkinGame" params="" file="source/funkin/backend/system/FunkinGame.hx">
		<extends path="flixel.FlxGame"/>
		<skipNextTickUpdate expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skipNextTickUpdate>
		<switchState public="1" set="method" line="7" override="1"><f a=""><x path="Void"/></f></switchState>
		<onEnterFrame public="1" set="method" line="15" override="1"><f a="t">
	<c path="openfl.events.Event"/>
	<x path="Void"/>
</f></onEnterFrame>
		<new public="1" set="method" line="5"><f a="?gameWidth:?gameHeight:?initialState:?updateFramerate:?drawFramerate:?skipSplash:?startFullscreen">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Class"><c path="flixel.FlxState"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.FunkinRatioScaleMode" params="" file="source/funkin/backend/system/FunkinRatioScaleMode.hx">
		<extends path="flixel.system.scaleModes.RatioScaleMode"/>
		<width public="1" get="accessor" set="accessor" expr="null">
			<x path="Null"><x path="Int"/></x>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":isVar"/>
			</meta>
		</width>
		<height public="1" get="accessor" set="accessor" expr="null">
			<x path="Null"><x path="Int"/></x>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":isVar"/>
			</meta>
		</height>
		<updateGameSize public="1" set="method" line="10" override="1"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateGameSize>
		<resetSize public="1" set="method" line="45"><f a=""><x path="Void"/></f></resetSize>
		<get_width get="inline" set="null" line="50"><f a=""><x path="Null"><x path="Int"/></x></f></get_width>
		<get_height get="inline" set="null" line="52"><f a=""><x path="Null"><x path="Int"/></x></f></get_height>
		<set_width get="inline" set="null" line="53"><f a="v">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_width>
		<set_height get="inline" set="null" line="59"><f a="v">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_height>
		<new public="1" set="method" line="5"><f a="?fillScreen">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.GraphicCacheSprite" params="" file="source/funkin/backend/system/GraphicCacheSprite.hx">
		<extends path="flixel.FlxSprite"/>
		<cachedGraphics public="1" expr="[]">
			<c path="Array"><c path="flixel.graphics.FlxGraphic"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Array containing all of the graphics cached by this sprite.</haxe_doc>
		</cachedGraphics>
		<nonRenderedCachedGraphics public="1" expr="[]">
			<c path="Array"><c path="flixel.graphics.FlxGraphic"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Array containing all of the non rendered (not sent to GPU) cached graphics.</haxe_doc>
		</nonRenderedCachedGraphics>
		<cache public="1" set="method" line="27">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Caches a graphic at specified path.
	 * @param path Path to the graphic.</haxe_doc>
		</cache>
		<cacheGraphic public="1" set="method" line="35">
			<f a="graphic">
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Caches a graphic.
	 * @param graphic The FlxGraphic</haxe_doc>
		</cacheGraphic>
		<destroy public="1" set="method" line="45" override="1"><f a=""><x path="Void"/></f></destroy>
		<draw public="1" set="method" line="54" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Dummy FlxSprite that allows you to cache FlxGraphics, and immediatly send them to GPU memory.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.Logs" params="" file="source/funkin/backend/system/Logs.hx">
		<__showing expr="false" line="10" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__showing>
		<nativeTrace public="1" expr="Log.trace" line="12" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>Log.trace</e></m></meta>
		</nativeTrace>
		<init public="1" set="method" line="13" static="1"><f a=""><x path="Void"/></f></init>
		<prepareColoredTrace public="1" set="method" line="52" static="1">
			<f a="text:?level" v=":INFO">
				<c path="Array"><t path="funkin.backend.system.LogText"/></c>
				<x path="funkin.backend.system.Level"/>
				<c path="Array"><t path="funkin.backend.system.LogText"/></c>
			</f>
			<meta><m n=":value"><e>{ level : INFO }</e></m></meta>
		</prepareColoredTrace>
		<logText public="1" set="method" line="72" static="1">
			<f a="text:?color" v=":LIGHTGRAY">
				<c path="String"/>
				<x path="funkin.backend.utils.ConsoleColor"/>
				<t path="funkin.backend.system.LogText"/>
			</f>
			<meta><m n=":value"><e>{ color : LIGHTGRAY }</e></m></meta>
		</logText>
		<__showInConsole public="1" set="method" line="79" static="1"><f a="text">
	<c path="Array"><t path="funkin.backend.system.LogText"/></c>
	<x path="Void"/>
</f></__showInConsole>
		<traceColored public="1" set="method" line="98" static="1">
			<f a="text:?level" v=":INFO">
				<c path="Array"><t path="funkin.backend.system.LogText"/></c>
				<x path="funkin.backend.system.Level"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ level : INFO }</e></m></meta>
		</traceColored>
		<trace public="1" set="method" line="101" static="1">
			<f a="text:?level:?color" v=":INFO:LIGHTGRAY">
				<c path="String"/>
				<x path="funkin.backend.system.Level"/>
				<x path="funkin.backend.utils.ConsoleColor"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : LIGHTGRAY, level : INFO }</e></m></meta>
		</trace>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="funkin.backend.system.Level" params="" file="source/funkin/backend/system/Logs.hx" module="funkin.backend.system.Logs">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.system._Logs.Level_Impl_" params="" file="source/funkin/backend/system/Logs.hx" private="1" module="funkin.backend.system.Logs" extern="1" final="1">
	<INFO public="1" get="inline" set="null" expr="cast 0" line="110" static="1">
		<x path="funkin.backend.system.Level"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INFO>
	<WARNING public="1" get="inline" set="null" expr="cast 1" line="111" static="1">
		<x path="funkin.backend.system.Level"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</WARNING>
	<ERROR public="1" get="inline" set="null" expr="cast 2" line="112" static="1">
		<x path="funkin.backend.system.Level"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ERROR>
	<TRACE public="1" get="inline" set="null" expr="cast 3" line="113" static="1">
		<x path="funkin.backend.system.Level"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TRACE>
	<VERBOSE public="1" get="inline" set="null" expr="cast 4" line="114" static="1">
		<x path="funkin.backend.system.Level"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VERBOSE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.system._Logs.Level_Impl_" params="" file="source/funkin/backend/system/Logs.hx" private="1" module="funkin.backend.system.Logs" extern="1" final="1">
		<INFO public="1" get="inline" set="null" expr="cast 0" line="110" static="1">
			<x path="funkin.backend.system.Level"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INFO>
		<WARNING public="1" get="inline" set="null" expr="cast 1" line="111" static="1">
			<x path="funkin.backend.system.Level"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</WARNING>
		<ERROR public="1" get="inline" set="null" expr="cast 2" line="112" static="1">
			<x path="funkin.backend.system.Level"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ERROR>
		<TRACE public="1" get="inline" set="null" expr="cast 3" line="113" static="1">
			<x path="funkin.backend.system.Level"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TRACE>
		<VERBOSE public="1" get="inline" set="null" expr="cast 4" line="114" static="1">
			<x path="funkin.backend.system.Level"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VERBOSE>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="funkin.backend.system.LogText" params="" file="source/funkin/backend/system/Logs.hx" module="funkin.backend.system.Logs"><a>
	<text><c path="String"/></text>
	<color><x path="funkin.backend.utils.ConsoleColor"/></color>
</a></typedef>
	<class path="funkin.backend.system.MainState" params="" file="source/funkin/backend/system/MainState.hx">
		<extends path="flixel.FlxState"/>
		<initiated public="1" expr="false" line="16" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</initiated>
		<betaWarningShown public="1" expr="false" line="17" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</betaWarningShown>
		<create public="1" set="method" line="18" override="1"><f a=""><x path="Void"/></f></create>
		<new public="1" set="method" line="15"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Simple state used for loading the game</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.OptimizedBitmapData" params="" file="source/funkin/backend/system/OptimizedBitmapData.hx">
		<extends path="openfl.display.BitmapData"/>
		<__fromImage set="method" line="11" override="1">
			<f a="image">
				<c path="lime.graphics.Image"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n="SuppressWarnings"><e>"checkstyle:Dynamic"</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__fromImage>
		<getSurface public="1" set="method" line="50" override="1">
			<f a=""><x path="lime.graphics.cairo.CairoImageSurface"/></f>
			<meta>
				<m n="SuppressWarnings"><e>"checkstyle:Dynamic"</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</getSurface>
		<new public="1" set="method" line="8"><f a="width:height:?transparent:?fillColor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.embedBitmap()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.RotatingSpriteGroup" params="" file="source/funkin/backend/system/RotatingSpriteGroup.hx">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<recycleLoop public="1" set="method" line="6">
			<f a="?ObjectClass:?ObjectFactory:?Force:?Revive" v="::false:true">
				<x path="Class"><c path="flixel.FlxSprite"/></x>
				<f a=""><c path="flixel.FlxSprite"/></f>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ Revive : true, Force : false }</e></m></meta>
		</recycleLoop>
		<new public="1" set="method" line="5"><f a="?X:?Y:?MaxSize">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.framerate.FramerateCategory" params="" file="source/funkin/backend/system/framerate/FramerateCategory.hx">
		<extends path="openfl.display.Sprite"/>
		<title public="1"><c path="openfl.text.TextField"/></title>
		<text public="1"><c path="openfl.text.TextField"/></text>
		<bgSprite public="1"><c path="openfl.display.Bitmap"/></bgSprite>
		<_text expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</_text>
		<__enterFrame public="1" set="method" line="43" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="16">
			<f a="title:?text" v=":&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ text : "" }</e></m></meta>
		</new>
		<meta>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.framerate.AssetTreeInfo" params="" file="source/funkin/backend/system/framerate/AssetTreeInfo.hx">
		<extends path="funkin.backend.system.framerate.FramerateCategory"/>
		<__enterFrame public="1" set="method" line="11" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.framerate.CodenameBuildField" params="" file="source/funkin/backend/system/framerate/CodenameBuildField.hx">
		<extends path="openfl.text.TextField"/>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.framerate.ConductorInfo" params="" file="source/funkin/backend/system/framerate/ConductorInfo.hx">
		<extends path="funkin.backend.system.framerate.FramerateCategory"/>
		<__enterFrame public="1" set="method" line="9" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.framerate.FlixelInfo" params="" file="source/funkin/backend/system/framerate/FlixelInfo.hx">
		<extends path="funkin.backend.system.framerate.FramerateCategory"/>
		<__enterFrame public="1" set="method" line="8" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="4"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.framerate.Framerate" params="" file="source/funkin/backend/system/framerate/Framerate.hx">
		<extends path="openfl.display.Sprite"/>
		<instance public="1" static="1"><c path="funkin.backend.system.framerate.Framerate"/></instance>
		<isLoaded public="1" expr="false" line="15" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isLoaded>
		<textFormat public="1" static="1"><c path="openfl.text.TextFormat"/></textFormat>
		<fpsCounter public="1" static="1"><c path="funkin.backend.system.framerate.FramerateCounter"/></fpsCounter>
		<memoryCounter public="1" static="1"><c path="funkin.backend.system.framerate.MemoryCounter"/></memoryCounter>
		<codenameBuildField public="1" static="1"><c path="funkin.backend.system.framerate.CodenameBuildField"/></codenameBuildField>
		<fontName public="1" expr="&quot;${Sys.getEnv(\&quot;windir\&quot;)}\\Fonts\\consola.ttf&quot;" line="24" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"${Sys.getEnv(\"windir\")}\\Fonts\\consola.ttf"</e></m></meta>
		</fontName>
		<debugMode public="1" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* 0: FPS INVISIBLE
	 * 1: FPS VISIBLE
	 * 2: FPS &amp; DEBUG INFO VISIBLE</haxe_doc>
		</debugMode>
		<offset public="1" expr="new FlxPoint()" line="32" static="1">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</offset>
		<__bitmap public="1" get="accessor" set="null" expr="null" line="38" static="1">
			<c path="openfl.display.BitmapData"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":isVar"/>
			</meta>
		</__bitmap>
		<get___bitmap set="method" line="40" static="1"><f a=""><c path="openfl.display.BitmapData"/></f></get___bitmap>
		<bgSprite public="1"><c path="openfl.display.Bitmap"/></bgSprite>
		<categories public="1" expr="[]">
			<c path="Array"><c path="funkin.backend.system.framerate.FramerateCategory"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</categories>
		<__addCategory set="method" line="86"><f a="category">
	<c path="funkin.backend.system.framerate.FramerateCategory"/>
	<x path="Void"/>
</f></__addCategory>
		<__lastAddedSprite expr="null">
			<c path="openfl.display.DisplayObject"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</__lastAddedSprite>
		<__addToList set="method" line="91"><f a="spr">
	<c path="openfl.display.DisplayObject"/>
	<x path="Void"/>
</f></__addToList>
		<debugAlpha expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</debugAlpha>
		<__enterFrame public="1" set="method" line="101" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="46"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.framerate.FramerateCounter" params="" file="source/funkin/backend/system/framerate/FramerateCounter.hx">
		<extends path="openfl.display.Sprite"/>
		<fpsNum public="1"><c path="openfl.text.TextField"/></fpsNum>
		<fpsLabel public="1"><c path="openfl.text.TextField"/></fpsLabel>
		<lastFPS public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastFPS>
		<__enterFrame public="1" set="method" line="30" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.framerate.MemoryCounter" params="" file="source/funkin/backend/system/framerate/MemoryCounter.hx">
		<extends path="openfl.display.Sprite"/>
		<memoryText public="1"><c path="openfl.text.TextField"/></memoryText>
		<memoryPeakText public="1"><c path="openfl.text.TextField"/></memoryPeakText>
		<memory public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</memory>
		<memoryPeak public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</memoryPeak>
		<__enterFrame public="1" set="method" line="33" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.framerate.SystemInfo" params="" file="source/funkin/backend/system/framerate/SystemInfo.hx">
		<extends path="funkin.backend.system.framerate.FramerateCategory"/>
		<osInfo public="1" expr="&quot;Unknown&quot;" line="10" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Unknown"</e></m></meta>
		</osInfo>
		<gpuName public="1" expr="&quot;Unknown&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Unknown"</e></m></meta>
		</gpuName>
		<vRAM public="1" expr="&quot;Unknown&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Unknown"</e></m></meta>
		</vRAM>
		<cpuName public="1" expr="&quot;Unknown&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Unknown"</e></m></meta>
		</cpuName>
		<totalMem public="1" expr="&quot;Unknown&quot;" line="14" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Unknown"</e></m></meta>
		</totalMem>
		<memType public="1" expr="&quot;Unknown&quot;" line="15" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Unknown"</e></m></meta>
		</memType>
		<gpuMaxSize public="1" expr="&quot;Unknown&quot;" line="16" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Unknown"</e></m></meta>
		</gpuMaxSize>
		<__formattedSysText expr="&quot;&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</__formattedSysText>
		<init public="1" get="inline" set="null" line="20" static="1"><f a=""><x path="Void"/></f></init>
		<formatSysInfo set="method" line="118" static="1"><f a=""><x path="Void"/></f></formatSysInfo>
		<__enterFrame public="1" set="method" line="140" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="136"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.github.GitHub" params="" file="source/funkin/backend/system/github/GitHub.hx">
		<getReleases public="1" set="method" line="17" static="1">
			<f a="user:repository:?onError">
				<c path="String"/>
				<c path="String"/>
				<f a="">
					<c path="haxe.Exception"/>
					<x path="Void"/>
				</f>
				<c path="Array"><t path="funkin.backend.system.github.GitHubRelease"/></c>
			</f>
			<haxe_doc>* Gets all the releases from a specific GitHub repository using the GitHub API.
	 * @param user The user/organization that owns the repository
	 * @param repository The repository name
	 * @param onError Error Callback
	 * @return Releases</haxe_doc>
		</getReleases>
		<getContributors public="1" set="method" line="40" static="1">
			<f a="user:repository:?onError">
				<c path="String"/>
				<c path="String"/>
				<f a="">
					<c path="haxe.Exception"/>
					<x path="Void"/>
				</f>
				<c path="Array"><t path="funkin.backend.system.github.GitHubContributor"/></c>
			</f>
			<haxe_doc>* Gets the contributors list from a specific GitHub repository using the GitHub API.
	 * @param user The user/organization that owns the repository
	 * @param repository The repository name
	 * @param onError Error Callback
	 * @return Contributors List</haxe_doc>
		</getContributors>
		<getOrganization public="1" set="method" line="62" static="1">
			<f a="org:?onError">
				<c path="String"/>
				<f a="">
					<c path="haxe.Exception"/>
					<x path="Void"/>
				</f>
				<t path="funkin.backend.system.github.GitHubOrganization"/>
			</f>
			<haxe_doc>* Gets a specific GitHub organization using the GitHub API.
	 * @param org The organization to get
	 * @param onError Error Callback
	 * @return Organization</haxe_doc>
		</getOrganization>
		<getOrganizationMembers public="1" set="method" line="85" static="1">
			<f a="org:?onError">
				<c path="String"/>
				<f a="">
					<c path="haxe.Exception"/>
					<x path="Void"/>
				</f>
				<c path="Array"><t path="funkin.backend.system.github.GitHubContributor"/></c>
			</f>
			<haxe_doc>* Gets the members list from a specific GitHub organization using the GitHub API.
	 * NOTE: Members use Contributors' structure!
	 * @param org The organization to get the members from
	 * @param onError Error Callback
	 * @return Members List</haxe_doc>
		</getOrganizationMembers>
		<getUser public="1" set="method" line="108" static="1">
			<f a="user:?onError">
				<c path="String"/>
				<f a="">
					<c path="haxe.Exception"/>
					<x path="Void"/>
				</f>
				<t path="funkin.backend.system.github.GitHubUser"/>
			</f>
			<haxe_doc>* Gets a specific GitHub user/organization using the GitHub API.
	 * NOTE: If organization, it will be returned with the structure of a normal user; use `getOrganization` if you specifically want an organization!
	 * @param user The user/organization to get
	 * @param onError Error Callback
	 * @return User/Organization</haxe_doc>
		</getUser>
		<filterReleases public="1" get="inline" set="null" line="134" static="1">
			<f a="releases:?keepPrereleases:?keepDrafts" v=":true:false">
				<c path="Array"><t path="funkin.backend.system.github.GitHubRelease"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><t path="funkin.backend.system.github.GitHubRelease"/></c>
			</f>
			<meta><m n=":value"><e>{ keepDrafts : false, keepPrereleases : true }</e></m></meta>
			<haxe_doc>* Filters all releases gotten by `getReleases`
	 * @param releases Releases
	 * @param keepPrereleases Whenever to keep Pre-Releases.
	 * @param keepDrafts Whenever to keep Drafts.
	 * @return Filtered releases.</haxe_doc>
		</filterReleases>
		<__parseGitHubException set="method" line="136" static="1"><f a="obj">
	<d/>
	<c path="funkin.backend.system.github.GitHubException"/>
</f></__parseGitHubException>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.system.github.GitHubAsset" params="" file="source/funkin/backend/system/github/GitHubAsset.hx"><a>
	<url><c path="String"/></url>
	<uploader><t path="funkin.backend.system.github.GitHubUser"/></uploader>
	<updated_at><c path="String"/></updated_at>
	<state><c path="String"/></state>
	<size><x path="UInt"/></size>
	<node_id><c path="String"/></node_id>
	<name><c path="String"/></name>
	<label><c path="String"/></label>
	<id><x path="Int"/></id>
	<download_count><x path="Int"/></download_count>
	<created_at><c path="String"/></created_at>
	<content_type><c path="String"/></content_type>
	<browser_download_url><c path="String"/></browser_download_url>
</a></typedef>
	<typedef path="funkin.backend.system.github.GitHubContributor" params="" file="source/funkin/backend/system/github/GitHubContributor.hx"><a>
	<url><c path="String"/></url>
	<type><c path="String"/></type>
	<subscriptions_url><c path="String"/></subscriptions_url>
	<starred_url><c path="String"/></starred_url>
	<site_admin><x path="Bool"/></site_admin>
	<repos_url><c path="String"/></repos_url>
	<received_events_url><c path="String"/></received_events_url>
	<organizations_url><c path="String"/></organizations_url>
	<node_id><c path="String"/></node_id>
	<login><c path="String"/></login>
	<id><x path="Int"/></id>
	<html_url><c path="String"/></html_url>
	<gravatar_id><c path="String"/></gravatar_id>
	<gists_url><c path="String"/></gists_url>
	<following_url><c path="String"/></following_url>
	<followers_url><c path="String"/></followers_url>
	<events_url><c path="String"/></events_url>
	<contributions><x path="Int"/></contributions>
	<avatar_url><c path="String"/></avatar_url>
</a></typedef>
	<class path="funkin.backend.system.github.GitHubException" params="" file="source/funkin/backend/system/github/GitHubException.hx">
		<extends path="haxe.Exception"/>
		<apiMessage public="1"><c path="String"/></apiMessage>
		<documentationUrl public="1"><c path="String"/></documentationUrl>
		<new public="1" set="method" line="10"><f a="apiMessage:documentationUrl">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.system.github.GitHubOrganization" params="" file="source/funkin/backend/system/github/GitHubOrganization.hx"><a>
	<url><c path="String"/></url>
	<updated_at><c path="String"/></updated_at>
	<type><x path="funkin.backend.system.github.GitHubUserType"/></type>
	<twitter_username><c path="String"/></twitter_username>
	<repos_url><c path="String"/></repos_url>
	<public_repos><x path="Int"/></public_repos>
	<public_members_url><c path="String"/></public_members_url>
	<public_gists><x path="Int"/></public_gists>
	<node_id><c path="String"/></node_id>
	<name><c path="String"/></name>
	<members_url><c path="String"/></members_url>
	<login><c path="String"/></login>
	<location><c path="String"/></location>
	<issues_url><c path="String"/></issues_url>
	<is_verified><x path="Bool"/></is_verified>
	<id><x path="Int"/></id>
	<html_url><c path="String"/></html_url>
	<hooks_url><c path="String"/></hooks_url>
	<has_repository_projects><x path="Bool"/></has_repository_projects>
	<has_organization_projects><x path="Bool"/></has_organization_projects>
	<following><x path="Int"/></following>
	<followers><x path="Int"/></followers>
	<events_url><c path="String"/></events_url>
	<email><c path="String"/></email>
	<description><c path="String"/></description>
	<created_at><c path="String"/></created_at>
	<company><c path="String"/></company>
	<blog><c path="String"/></blog>
	<avatar_url><c path="String"/></avatar_url>
	<archived_at><c path="String"/></archived_at>
</a></typedef>
	<typedef path="funkin.backend.system.github.GitHubReactions" params="" file="source/funkin/backend/system/github/GitHubReactions.hx"><a>
	<url><c path="String"/></url>
	<total_count><x path="Int"/></total_count>
	<rocket><x path="Int"/></rocket>
	<laugh><x path="Int"/></laugh>
	<hooray><x path="Int"/></hooray>
	<heart><x path="Int"/></heart>
	<eyes><x path="Int"/></eyes>
	<confused><x path="Int"/></confused>
</a></typedef>
	<typedef path="funkin.backend.system.github.GitHubRelease" params="" file="source/funkin/backend/system/github/GitHubRelease.hx"><a>
	<zipball_url><c path="String"/></zipball_url>
	<url>
		<c path="String"/>
		<haxe_doc>* Url of the release (GitHub API)</haxe_doc>
	</url>
	<upload_url>
		<c path="String"/>
		<haxe_doc>* Template URL for asset download link.</haxe_doc>
	</upload_url>
	<target_commitish><c path="String"/></target_commitish>
	<tarball_url><c path="String"/></tarball_url>
	<tag_name><c path="String"/></tag_name>
	<reactions><t path="funkin.backend.system.github.GitHubReactions"/></reactions>
	<published_at><c path="String"/></published_at>
	<prerelease><x path="Bool"/></prerelease>
	<node_id><c path="String"/></node_id>
	<name><c path="String"/></name>
	<id>
		<x path="Int"/>
		<haxe_doc>* ID of the release.</haxe_doc>
	</id>
	<html_url>
		<c path="String"/>
		<haxe_doc>* Link to the release on the GitHub website.</haxe_doc>
	</html_url>
	<draft><x path="Bool"/></draft>
	<created_at><c path="String"/></created_at>
	<body>
		<c path="String"/>
		<haxe_doc>* Body of the GitHub request (Markdown)</haxe_doc>
	</body>
	<author>
		<t path="funkin.backend.system.github.GitHubUser"/>
		<haxe_doc>* Author of the release</haxe_doc>
	</author>
	<assets_url>
		<c path="String"/>
		<haxe_doc>* Url for the assets JSON. Also accessible via `GitHubRelease.assets`</haxe_doc>
	</assets_url>
	<assets><c path="Array"><t path="funkin.backend.system.github.GitHubAsset"/></c></assets>
</a></typedef>
	<typedef path="funkin.backend.system.github.GitHubUser" params="" file="source/funkin/backend/system/github/GitHubUser.hx"><a>
	<url>
		<c path="String"/>
		<haxe_doc>* URL to the user on GitHub's servers.</haxe_doc>
	</url>
	<updated_at>
		<c path="String"/>
		<haxe_doc>* Date of last account update.</haxe_doc>
	</updated_at>
	<type>
		<x path="funkin.backend.system.github.GitHubUserType"/>
		<haxe_doc>* Type of the user.</haxe_doc>
	</type>
	<twitter_username>
		<c path="String"/>
		<haxe_doc>* Twitter username of the user. Can be null.</haxe_doc>
	</twitter_username>
	<starred_url>
		<c path="String"/>
		<haxe_doc>* URL on GitHub's API to access this user's starred repositories.</haxe_doc>
	</starred_url>
	<site_admin>
		<x path="Bool"/>
		<haxe_doc>* Whenever the user is a GitHub administrator.</haxe_doc>
	</site_admin>
	<public_repos>
		<x path="Int"/>
		<haxe_doc>* Number of public repos this user own.</haxe_doc>
	</public_repos>
	<public_gists>
		<x path="Int"/>
		<haxe_doc>* Number of public gists this user own.</haxe_doc>
	</public_gists>
	<node_id>
		<c path="String"/>
		<haxe_doc>* ID of the current node on the GitHub database.</haxe_doc>
	</node_id>
	<name>
		<c path="String"/>
		<haxe_doc>* Name of the user.</haxe_doc>
	</name>
	<login>
		<c path="String"/>
		<haxe_doc>* Username of the user.</haxe_doc>
	</login>
	<location><c path="String"/></location>
	<id>
		<x path="Int"/>
		<haxe_doc>* ID of the user.</haxe_doc>
	</id>
	<html_url>
		<c path="String"/>
		<haxe_doc>* URL to the user on GitHub's website.</haxe_doc>
	</html_url>
	<hireable><x path="Null"><x path="Bool"/></x></hireable>
	<gravatar_id>
		<c path="String"/>
		<haxe_doc>* Unknown</haxe_doc>
	</gravatar_id>
	<gists_url>
		<c path="String"/>
		<haxe_doc>* URL on GitHub's API to access this user's gists.</haxe_doc>
	</gists_url>
	<following_url>
		<c path="String"/>
		<haxe_doc>* URL on GitHub's API to access the accounts this user is following.</haxe_doc>
	</following_url>
	<following>
		<x path="Int"/>
		<haxe_doc>* Number of accounts this user follows.</haxe_doc>
	</following>
	<followers_url>
		<c path="String"/>
		<haxe_doc>* URL on GitHub's API to access this user's followers.</haxe_doc>
	</followers_url>
	<followers>
		<x path="Int"/>
		<haxe_doc>* Number of followers this user have</haxe_doc>
	</followers>
	<email><c path="String"/></email>
	<created_at>
		<c path="String"/>
		<haxe_doc>* Date of creation of the account</haxe_doc>
	</created_at>
	<company>
		<c path="String"/>
		<haxe_doc>* The company this user belongs to. Can be `null`.</haxe_doc>
	</company>
	<blog><c path="String"/></blog>
	<bio><c path="String"/></bio>
	<avatar_url>
		<c path="String"/>
		<haxe_doc>* Link to the avatar (profile picture).</haxe_doc>
	</avatar_url>
</a></typedef>
	<abstract path="funkin.backend.system.github.GitHubUserType" params="" file="source/funkin/backend/system/github/GitHubUser.hx" module="funkin.backend.system.github.GitHubUser">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.system.github._GitHubUser.GitHubUserType_Impl_" params="" file="source/funkin/backend/system/github/GitHubUser.hx" private="1" module="funkin.backend.system.github.GitHubUser" extern="1" final="1">
	<USER public="1" get="inline" set="null" expr="cast &quot;User&quot;" line="129" static="1">
		<x path="funkin.backend.system.github.GitHubUserType"/>
		<meta>
			<m n=":value"><e>cast "User"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</USER>
	<ORGANIZATION public="1" get="inline" set="null" expr="cast &quot;Organization&quot;" line="130" static="1">
		<x path="funkin.backend.system.github.GitHubUserType"/>
		<meta>
			<m n=":value"><e>cast "Organization"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ORGANIZATION>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.system.github._GitHubUser.GitHubUserType_Impl_" params="" file="source/funkin/backend/system/github/GitHubUser.hx" private="1" module="funkin.backend.system.github.GitHubUser" extern="1" final="1">
		<USER public="1" get="inline" set="null" expr="cast &quot;User&quot;" line="129" static="1">
			<x path="funkin.backend.system.github.GitHubUserType"/>
			<meta>
				<m n=":value"><e>cast "User"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</USER>
		<ORGANIZATION public="1" get="inline" set="null" expr="cast &quot;Organization&quot;" line="130" static="1">
			<x path="funkin.backend.system.github.GitHubUserType"/>
			<meta>
				<m n=":value"><e>cast "Organization"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ORGANIZATION>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.backend.system.macros.DefinesMacro" params="" file="source/funkin/backend/system/macros/DefinesMacro.hx">
		<defines public="1" get="accessor" set="null" static="1">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<haxe_doc>* Returns the defined values</haxe_doc>
		</defines>
		<get_defines get="inline" set="null" line="17" static="1"><f a=""><x path="haxe.ds.Map">
	<c path="String"/>
	<c path="String"/>
</x></f></get_defines>
	</class>
	<class path="funkin.backend.system.macros.GitCommitMacro" params="" file="source/funkin/backend/system/macros/GitCommitMacro.hx">
		<commitNumber public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>* Returns the current commit number</haxe_doc>
		</commitNumber>
		<commitHash public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* Returns the current commit hash</haxe_doc>
		</commitHash>
		<get_commitNumber get="inline" set="null" line="20" static="1"><f a=""><x path="Int"/></f></get_commitNumber>
		<get_commitHash get="inline" set="null" line="23" static="1"><f a=""><c path="String"/></f></get_commitHash>
	</class>
	<class path="funkin.backend.system.macros.HashLinkFixer" params="" file="source/funkin/backend/system/macros/HashLinkFixer.hx"/>
	<class path="funkin.backend.system.macros.Utils" params="" file="source/funkin/backend/system/macros/Utils.hx"/>
	<class path="funkin.backend.system.modules.AudioSwitchFix" params="" file="source/funkin/backend/system/modules/AudioSwitchFix.hx">
		<onStateSwitch set="method" line="16" static="1">
			<f a="state">
				<c path="flixel.FlxState"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onStateSwitch>
		<init public="1" set="method" line="57" static="1"><f a=""><x path="Void"/></f></init>
		<haxe_doc>* if youre stealing this keep this comment at least please lol
 *
 * hi gray itsa me yoshicrafter29 i fixed it hehe</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<typedef path="funkin.backend.system.modules.PlayingSound" params="" file="source/funkin/backend/system/modules/AudioSwitchFix.hx" module="funkin.backend.system.modules.AudioSwitchFix">
		<a>
			<time><x path="Float"/></time>
			<sound><c path="flixel.sound.FlxSound"/></sound>
		</a>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<class path="funkin.backend.system.modules.CrashHandler" params="" file="source/funkin/backend/system/modules/CrashHandler.hx">
		<init public="1" set="method" line="13" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</init>
		<onUncaughtError public="1" set="method" line="22" static="1"><f a="e">
	<c path="openfl.events.UncaughtErrorEvent"/>
	<x path="Void"/>
</f></onUncaughtError>
		<onError set="method" line="64" static="1"><f a="message">
	<d/>
	<x path="Void"/>
</f></onError>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.modules.FunkinCache" params="" file="source/funkin/backend/system/modules/FunkinCache.hx">
		<extends path="openfl.utils.AssetCache"/>
		<instance public="1" static="1"><c path="funkin.backend.system.modules.FunkinCache"/></instance>
		<init public="1" set="method" line="35" static="1"><f a=""><x path="Void"/></f></init>
		<bitmapData2 public="1">
			<t path="Map">
				<c path="String"/>
				<c path="openfl.display.BitmapData"/>
			</t>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
			<haxe_doc>Internal</haxe_doc>
		</bitmapData2>
		<font2 public="1">
			<t path="Map">
				<c path="String"/>
				<c path="openfl.text.Font"/>
			</t>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
			<haxe_doc>Internal</haxe_doc>
		</font2>
		<sound2 public="1">
			<t path="Map">
				<c path="String"/>
				<c path="openfl.media.Sound"/>
			</t>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
			<haxe_doc>Internal</haxe_doc>
		</sound2>
		<moveToSecondLayer public="1" set="method" line="47"><f a=""><x path="Void"/></f></moveToSecondLayer>
		<clearSecondLayer public="1" set="method" line="56"><f a=""><x path="Void"/></f></clearSecondLayer>
		<getBitmapData public="1" set="method" line="80" override="1">
			<f a="id">
				<c path="String"/>
				<c path="openfl.display.BitmapData"/>
			</f>
			<haxe_doc>Retrieves a cached BitmapData.

		@param	id	The ID of the cached BitmapData
		@return	The cached BitmapData instance</haxe_doc>
		</getBitmapData>
		<getFont public="1" set="method" line="99" override="1">
			<f a="id">
				<c path="String"/>
				<c path="openfl.text.Font"/>
			</f>
			<haxe_doc>Retrieves a cached Font.

		@param	id	The ID of the cached Font
		@return	The cached Font instance</haxe_doc>
		</getFont>
		<getSound public="1" set="method" line="118" override="1">
			<f a="id">
				<c path="String"/>
				<c path="openfl.media.Sound"/>
			</f>
			<haxe_doc>Retrieves a cached Sound.

		@param	id	The ID of the cached Sound
		@return	The cached Sound instance</haxe_doc>
		</getSound>
		<hasBitmapData public="1" set="method" line="137" override="1">
			<f a="id">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a BitmapData asset is cached.

		@param	id	The ID of a BitmapData asset
		@return	Whether the object has been cached</haxe_doc>
		</hasBitmapData>
		<hasFont public="1" set="method" line="148" override="1">
			<f a="id">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a Font asset is cached.

		@param	id	The ID of a Font asset
		@return	Whether the object has been cached</haxe_doc>
		</hasFont>
		<hasSound public="1" set="method" line="159" override="1">
			<f a="id">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a Sound asset is cached.

		@param	id	The ID of a Sound asset
		@return	Whether the object has been cached</haxe_doc>
		</hasSound>
		<removeBitmapData public="1" set="method" line="169" override="1">
			<f a="id">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a BitmapData from the cache.

		@param	id	The ID of a BitmapData asset
		@return	`true` if the asset was removed, `false` if it was not in the cache</haxe_doc>
		</removeBitmapData>
		<removeFont public="1" set="method" line="183" override="1">
			<f a="id">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a Font from the cache.

		@param	id	The ID of a Font asset
		@return	`true` if the asset was removed, `false` if it was not in the cache</haxe_doc>
		</removeFont>
		<removeSound public="1" set="method" line="197" override="1">
			<f a="id">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a Sound from the cache.

		@param	id	The ID of a Sound asset
		@return	`true` if the asset was removed, `false` if it was not in the cache</haxe_doc>
		</removeSound>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.net.Socket" params="" file="source/funkin/backend/system/net/Socket.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<socket public="1"><t path="sys.net._Socket.SysSocket"/></socket>
		<read public="1" set="method" line="19"><f a=""><c path="String"/></f></read>
		<write public="1" set="method" line="28"><f a="str">
	<c path="String"/>
	<x path="Bool"/>
</f></write>
		<host public="1" set="method" line="38">
			<f a="host:port:?nbConnections" v="::1">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nbConnections : 1 }</e></m></meta>
		</host>
		<hostAndWait public="1" set="method" line="44"><f a="h:port">
	<c path="sys.net.Host"/>
	<x path="Int"/>
	<c path="funkin.backend.system.net.Socket"/>
</f></hostAndWait>
		<acceptConnection public="1" set="method" line="49"><f a=""><c path="funkin.backend.system.net.Socket"/></f></acceptConnection>
		<connect public="1" set="method" line="56"><f a="host:port">
	<c path="sys.net.Host"/>
	<x path="Int"/>
	<x path="Void"/>
</f></connect>
		<destroy public="1" set="method" line="60"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="11"><f a="?socket">
	<t path="sys.net._Socket.SysSocket"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="funkin.backend.utils.AudioAnalyzer" params="" file="source/funkin/backend/utils/AudioAnalyzer.hx">
		<buffer public="1"><c path="lime.media.AudioBuffer"/></buffer>
		<__peakByte expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__peakByte>
		<__timeMulti expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__timeMulti>
		<analyze public="1" set="method" line="23"><f a="startPos:endPos">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></analyze>
		<new public="1" set="method" line="13"><f a="sound">
	<c path="flixel.sound.FlxSound"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.BitmapUtil" params="" file="source/funkin/backend/utils/BitmapUtil.hx">
		<getMostPresentColor public="1" set="method" line="12" static="1">
			<f a="bmap">
				<c path="openfl.display.BitmapData"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<haxe_doc>* Returns the most present color in a Bitmap.
	 * @param bmap Bitmap
	 * @return FlxColor Color that is the most present.</haxe_doc>
		</getMostPresentColor>
		<getMostPresentSaturatedColor public="1" set="method" line="43" static="1">
			<f a="bmap">
				<c path="openfl.display.BitmapData"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<haxe_doc>* Returns the most present saturated color in a Bitmap.
	 * @param bmap Bitmap
	 * @return FlxColor Color that is the most present.</haxe_doc>
		</getMostPresentSaturatedColor>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.CoolUtil" params="" file="source/funkin/backend/utils/CoolUtil.hx">
		<getLastExceptionStack public="1" set="method" line="32" static="1"><f a=""><c path="String"/></f></getLastExceptionStack>
		<isNotNull public="1" get="inline" set="null" line="41" static="1"><f a="v">
	<x path="Null"><d/></x>
	<x path="Bool"/>
</f></isNotNull>
		<getDefault public="1" params="T" get="inline" set="null" line="51" static="1"><f a="v:defaultValue">
	<x path="Null"><c path="getDefault.T"/></x>
	<c path="getDefault.T"/>
	<c path="getDefault.T"/>
</f></getDefault>
		<parseJson public="1" set="method" line="59" static="1">
			<f a="assetPath">
				<c path="String"/>
				<unknown/>
			</f>
			<haxe_doc>* Shortcut to parse JSON from an Asset path
	 * @param assetPath Path to the JSON asset.</haxe_doc>
		</parseJson>
		<deleteFolder public="1" set="method" line="67" static="1">
			<f a="delete">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Deletes a folder recursively
	 * @param delete Path to the folder.</haxe_doc>
		</deleteFolder>
		<safeSaveFile public="1" set="method" line="88" static="1">
			<f a="path:content:?showErrorBox" v="::true">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfTwo">
					<c path="String"/>
					<c path="haxe.io.Bytes"/>
				</x>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ showErrorBox : true }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Safe saves a file (even adding eventual missing folders) and shows a warning box instead of making the program crash
	 * @param path Path to save the file at.
	 * @param content Content of the file to save (as String or Bytes).</haxe_doc>
		</safeSaveFile>
		<safeGetAttributes public="1" get="inline" set="null" line="109" static="1">
			<f a="path:?useAbsol" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="funkin.backend.utils.FileAttributeWrapper"/>
			</f>
			<meta>
				<m n=":value"><e>{ useAbsol : true }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Gets file attributes from a file or a folder adding eventual missing folders in the path
	 * (WARNING: Only works on `windows` for now. On other platforms the attributes' value it's always going to be `0` -thanks to the wrapper you can also use `isNothing` for checking- but still creates eventual missing folders if the platforms allows it to).
	 * @param path Path to the file or folder
	 * @param useAbsol If it should use the absolute path (By default it's `true` but if it's `false` you can use files outside from this program's directory for example)
	 * @return The attributes through the `FileAttributeWrapper`</haxe_doc>
		</safeGetAttributes>
		<safeSetAttributes public="1" get="inline" set="null" line="125" static="1">
			<f a="path:attrib:?useAbsol" v="::true">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfThree">
					<x path="funkin.backend.utils.FileAttribute"/>
					<c path="funkin.backend.utils.FileAttributeWrapper"/>
					<x path="Int"/>
				</x>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":value"><e>{ useAbsol : true }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Sets file attributes to a file or a folder adding eventual missing folders in the path
	 * (WARNING: Only works on `windows` for now. On other platforms the return code it's always going to be `0` but still creates eventual missing folders if the platforms allows it to).
	 * @param path Path to the file or folder
	 * @param attrib The attribute(s) to set (WARNING: There are some non settable attributes, such as the `COMPRESSED` one)
	 * @param useAbsol If it should use the absolute path (By default it's `true` but if it's `false` you can use files outside from this program's directory for example)
	 * @return The result code: `0` means that it failed setting</haxe_doc>
		</safeSetAttributes>
		<safeAddAttributes public="1" get="inline" set="null" line="142" static="1">
			<f a="path:attrib:?useAbsol" v="::true">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfTwo">
					<x path="funkin.backend.utils.FileAttribute"/>
					<x path="Int"/>
				</x>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":value"><e>{ useAbsol : true }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Adds one (or more) file attributes to a file or a folder adding eventual missing folders in the path
	 * (WARNING: Only works on `windows` for now. On other platforms the return code it's always going to be `0` but still creates eventual missing folders if the platforms allows it to).
	 * @param path Path to the file or folder
	 * @param attrib The attribute(s) to add (WARNING: There are some non settable attributes, such as the `COMPRESSED` one)
	 * @param useAbsol If it should use the absolute path (By default it's `true` but if it's `false` you can use files outside from this program's directory for example)
	 * @return The result code: `0` means that it failed setting</haxe_doc>
		</safeAddAttributes>
		<safeRemoveAttributes public="1" get="inline" set="null" line="158" static="1">
			<f a="path:attrib:?useAbsol" v="::true">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfTwo">
					<x path="funkin.backend.utils.FileAttribute"/>
					<x path="Int"/>
				</x>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":value"><e>{ useAbsol : true }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Removes one (or more) file attributes to a file or a folder adding eventual missing folders in the path
	 * (WARNING: Only works on `windows` for now. On other platforms the return code it's always going to be `0` but still creates eventual missing folders if the platforms allows it to).
	 * @param path Path to the file or folder
	 * @param attrib The attribute(s) to remove (WARNING: There are some non settable attributes, such as the `COMPRESSED` one)
	 * @param useAbsol If it should use the absolute path (By default it's `true` but if it's `false` you can use files outside from this program's directory for example)
	 * @return The result code: `0` means that it failed setting</haxe_doc>
		</safeRemoveAttributes>
		<addMissingFolders public="1" set="method" line="174" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Creates eventual missing folders to the specified `path`
	 *
	 * WARNING: eventual files in `path` will be considered as folders! Just to make possible folders be named as `songs.json` for example
	 *
	 * @param path Path to check.
	 * @return The initial Path.</haxe_doc>
		</addMissingFolders>
		<parseJsonString public="1" get="inline" set="null" line="194" static="1">
			<f a="str">
				<c path="String"/>
				<unknown/>
			</f>
			<haxe_doc>* Shortcut to parse a JSON string
	 * @param str Path to the JSON string
	 * @return Parsed JSON</haxe_doc>
		</parseJsonString>
		<isNaN public="1" get="inline" set="null" line="200" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Whenever a value is NaN or not.
	 * @param v Value</haxe_doc>
		</isNaN>
		<last public="1" params="T" get="inline" set="null" line="211" static="1">
			<f a="array">
				<c path="Array"><c path="last.T"/></c>
				<c path="last.T"/>
			</f>
			<haxe_doc>* Returns the last of an Array
	 * @param array Array
	 * @return T Last element</haxe_doc>
		</last>
		<setFieldDefault public="1" params="T" set="method" line="222" static="1">
			<f a="v:name:defaultValue">
				<d/>
				<c path="String"/>
				<c path="setFieldDefault.T"/>
				<c path="setFieldDefault.T"/>
			</f>
			<haxe_doc>* Sets a field's default value, and returns it. In case it already exists, returns the existing one.
	 * @param v Dynamic to set the default value to
	 * @param name Name of the value
	 * @param defaultValue Default value
	 * @return T New/old value.</haxe_doc>
		</setFieldDefault>
		<addZeros public="1" get="inline" set="null" line="237" static="1">
			<f a="str:num">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Add several zeros at the beginning of a string, so that `2` becomes `02`.
	 * @param str String to add zeros
	 * @param num The length required</haxe_doc>
		</addZeros>
		<addEndZeros public="1" get="inline" set="null" line="247" static="1">
			<f a="str:num">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Add several zeros at the end of a string, so that `2` becomes `20`, useful for ms.
	 * @param str String to add zeros
	 * @param num The length required</haxe_doc>
		</addEndZeros>
		<getSizeString public="1" set="method" line="257" static="1">
			<f a="size">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Returns a string representation of a size, following this format: `1.02 GB`, `134.00 MB`
	 * @param size Size to convert to string
	 * @return String Result string representation</haxe_doc>
		</getSizeString>
		<removeIP public="1" get="inline" set="null" line="273" static="1">
			<f a="msg">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Replaces in a string any kind of IP with `[Your IP]` making the string safer to trace.
	 * @param msg String to check and edit
	 * @return String Result without any kind of IP</haxe_doc>
		</removeIP>
		<fpsLerp public="1" get="inline" set="null" line="284" static="1">
			<f a="v1:v2:ratio">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Alternative linear interpolation function for each frame use, without worrying about framerate changes.
	 * @param v1 Begin value
	 * @param v2 End value
	 * @param ratio Ratio
	 * @return Float Final value</haxe_doc>
		</fpsLerp>
		<lerpColor public="1" get="inline" set="null" line="294" static="1">
			<f a="color1:color2:ratio:?fpsSensitive" v=":::false">
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta>
				<m n=":value"><e>{ fpsSensitive : false }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Lerps from color1 into color2 (Shortcut to `FlxColor.interpolate`)
	 * @param color1 Color 1
	 * @param color2 Color 2
	 * @param ratio Ratio
	 * @param fpsSensitive Whenever the ratio should be fps sensitive (adapted when game is running at 120 instead of 60)</haxe_doc>
		</lerpColor>
		<getFPSRatio public="1" get="inline" set="null" line="305" static="1">
			<f a="ratio">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Modifies a lerp ratio based on current FPS to keep a stable speed on higher framerate.
	 * @param ratio Ratio
	 * @return FPS-Modified Ratio</haxe_doc>
		</getFPSRatio>
		<getColorFromDynamic public="1" set="method" line="313" static="1">
			<f a="c">
				<d/>
				<x path="Null"><x path="flixel.util.FlxColor"/></x>
			</f>
			<haxe_doc>* Tries to get a color from a `Dynamic` variable.
	 * @param c `Dynamic` color.
	 * @return The result color, or `null` if invalid.</haxe_doc>
		</getColorFromDynamic>
		<playMenuSong public="1" set="method" line="349" static="1">
			<f a="?fadeIn" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ fadeIn : false }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Plays the main menu theme.
	 * @param fadeIn</haxe_doc>
		</playMenuSong>
		<preloadCharacter public="1" set="method" line="364" static="1">
			<f a="name:?spriteName">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Preloads a character.
	 * @param name Character name
	 * @param spriteName (Optional) sprite name.</haxe_doc>
		</preloadCharacter>
		<playMusic public="1" set="method" line="381" static="1">
			<f a="path:?Persist:?Volume:?Looped:?DefaultBPM:?Group" v=":false:1:true:102:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="flixel.sound.FlxSoundGroup"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ DefaultBPM : 102, Looped : true, Volume : 1, Persist : false }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Plays music, while resetting the Conductor, and taking info from INI in count.
	 * @param path Path to the music
	 * @param Persist Whenever the music should persist while switching states
	 * @param DefaultBPM Default BPM of the music (102)
	 * @param Volume Volume of the music (1)
	 * @param Looped Whenever the music loops (true)
	 * @param Group A group that this music belongs to (default)</haxe_doc>
		</playMusic>
		<playMenuSFX public="1" get="inline" set="null" line="416" static="1">
			<f a="?menuSFX:?volume" v="SCROLL:1">
				<x path="funkin.backend.utils.CoolSfx"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ volume : 1, menuSFX : SCROLL }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Plays a specified Menu SFX.
	 * @param menuSFX Menu SFX to play
	 * @param volume At which volume it should play</haxe_doc>
		</playMenuSFX>
		<coolTextFile public="1" set="method" line="439" static="1">
			<f a="path">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Allows you to split a text file from a path, into a "cool text file", AKA a list. Allows for comments. For example,
	 * `# comment`
	 * `test1`
	 * ` `
	 * `test2`
	 * will return `["test1", "test2"]`
	 * @param path
	 * @return Array&lt;String&gt;</haxe_doc>
		</coolTextFile>
		<numberArray public="1" get="inline" set="null" line="451" static="1">
			<f a="max:?min" v=":0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta>
				<m n=":value"><e>{ min : 0 }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Returns an array of number from min to max. Equivalent of `[for (i in min...max) i]`.
	 * @param max Max value
	 * @param min Minimal value (0)
	 * @return Array&lt;Int&gt; Final array</haxe_doc>
		</numberArray>
		<switchAnimFrames public="1" set="method" line="460" static="1">
			<f a="anim1:anim2">
				<c path="flixel.animation.FlxAnimation"/>
				<c path="flixel.animation.FlxAnimation"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Switches frames from 2 FlxAnimations.
	 * @param anim1 First animation
	 * @param anim2 Second animation</haxe_doc>
		</switchAnimFrames>
		<setUnstretchedGraphicSize public="1" get="inline" set="null" line="475" static="1">
			<f a="sprite:width:height:?fill:?maxScale" v=":::true:0">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ maxScale : 0, fill : true }</e></m></meta>
			<haxe_doc>* Allows you to set a graphic size (ex: 150x150), with proper hitbox without a stretched sprite.
	 * @param sprite Sprite to apply the new graphic size to
	 * @param width Width
	 * @param height Height
	 * @param fill Whenever the sprite should fill instead of shrinking (true)
	 * @param maxScale Maximum scale (0 / none)</haxe_doc>
		</setUnstretchedGraphicSize>
		<keyToString public="1" get="inline" set="null" line="488" static="1">
			<f a="key">
				<x path="Null"><x path="flixel.input.keyboard.FlxKey"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>* Returns a simple string representation of a FlxKey. Used in Controls options.
	 * @param key Key
	 * @return Simple representation</haxe_doc>
		</keyToString>
		<cameraCenter public="1" get="inline" set="null" line="531" static="1">
			<f a="obj:cam:?axes" v="::XY">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxCamera"/>
				<x path="flixel.util.FlxAxes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ axes : XY }</e></m></meta>
			<haxe_doc>* Centers an object in a camera's field, basically `screenCenter()` but `camera.width` and `camera.height` are used instead of `FlxG.width` and `FlxG.height`.
	 * @param obj Sprite to center
	 * @param cam Camera
	 * @param axes Axes (XY)</haxe_doc>
		</cameraCenter>
		<setSpriteSize public="1" get="inline" set="null" line="550" static="1">
			<f a="sprite:width:height">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Equivalent of `setGraphicSize`, except that it can accept floats and automatically updates the hitbox.
	 * @param sprite Sprite to set the size of
	 * @param width Width
	 * @param height Height</haxe_doc>
		</setSpriteSize>
		<getAtt public="1" get="inline" set="null" line="561" static="1">
			<f a="xml:name">
				<x path="haxe.xml.Access"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an XML attribute from an `Access` abstract, without throwing an exception if invalid.
	 * Example: `xml.getAtt("test").getDefault("Hello, World!");`
	 * @param xml XML to get the attribute from
	 * @param name Name of the attribute</haxe_doc>
		</getAtt>
		<autoSetFormat public="1" set="method" line="573" static="1">
			<f a="text:formats">
				<c path="flixel.text.FlxText"/>
				<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
				<c path="flixel.text.FlxText"/>
			</f>
			<haxe_doc>* Sets automatically all the compatible formats to a text.
	 *
	 * WARNING: These are dependant from the font, so if the font doesn't support for example the `bold` format it won't work!
	 * @param text Text to set the format for
	 * @param formats Array of the formats (to get the formats from a node, you can use `XMLUtil.getTextFormats(node)`)</haxe_doc>
		</autoSetFormat>
		<loadAnimatedGraphic public="1" set="method" line="612" static="1">
			<f a="spr:path">
				<c path="flixel.FlxSprite"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Loads an animated graphic, and automatically animates it.
	 * @param spr Sprite to load the graphic for
	 * @param path Path to the graphic</haxe_doc>
		</loadAnimatedGraphic>
		<copyColorTransform public="1" get="inline" set="null" line="628" static="1">
			<f a="color1:color2">
				<c path="openfl.geom.ColorTransform"/>
				<c path="openfl.geom.ColorTransform"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Copies a color transform from color1 to color2
	 * @param color1 Color transform to copy to
	 * @param color2 Color transform to copy from</haxe_doc>
		</copyColorTransform>
		<resetSprite public="1" set="method" line="645" static="1">
			<f a="spr:x:y">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resets an FlxSprite
	 * @param spr Sprite to reset
	 * @param x New X position
	 * @param y New Y position</haxe_doc>
		</resetSprite>
		<getMacroAbstractClass public="1" get="inline" set="null" line="661" static="1">
			<f a="className">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Gets the macro class created by hscript-improved for an abstract / enum</haxe_doc>
		</getMacroAbstractClass>
		<indexOfFromLast public="1" params="T" get="inline" set="null" line="671" static="1">
			<f a="array:element">
				<c path="Array"><c path="indexOfFromLast.T"/></c>
				<c path="indexOfFromLast.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Basically indexOf, but starts from the end.
	 * @param array Array to scan
	 * @param element Element
	 * @return Index, or -1 if unsuccessful.</haxe_doc>
		</indexOfFromLast>
		<clear public="1" params="T" get="inline" set="null" line="684" static="1">
			<f a="array">
				<c path="Array"><c path="clear.T"/></c>
				<c path="Array"><c path="clear.T"/></c>
			</f>
			<haxe_doc>* Clears the content of an array</haxe_doc>
		</clear>
		<pushGroup public="1" params="T" get="inline" set="null" line="697" static="1">
			<f a="array:args">
				<c path="Array"><c path="pushGroup.T"/></c>
				<x path="haxe.Rest"><c path="pushGroup.T"/></x>
				<c path="Array"><c path="pushGroup.T"/></c>
			</f>
			<haxe_doc>* Push an entire group into an array.
	 * @param array Array to push the group into
	 * @param ...args Group entries
	 * @return Array&lt;T&gt;</haxe_doc>
		</pushGroup>
		<openURL public="1" get="inline" set="null" line="707" static="1">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Opens an URL in the browser.
	 * @param url</haxe_doc>
		</openURL>
		<timeToStr public="1" get="inline" set="null" line="719" static="1">
			<f a="time">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Converts a timestamp to a readable format such as `01:22` (`mm:ss`)</haxe_doc>
		</timeToStr>
		<replay public="1" get="inline" set="null" line="725" static="1">
			<f a="sound">
				<c path="flixel.sound.FlxSound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stops a sound, set its time to 0 then play it again.
	 * @param sound Sound to replay.</haxe_doc>
		</replay>
		<maxInt public="1" get="inline" set="null" line="738" static="1">
			<f a="p1:p2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Equivalent of `Math.max`, except doesn't require a Int -&gt; Float -&gt; Int conversion.
	 * @param p1
	 * @param p2
	 * @return return p1 &lt; p2 ? p2 : p1</haxe_doc>
		</maxInt>
		<floorInt public="1" get="inline" set="null" line="744" static="1">
			<f a="e">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Equivalent of `Math.floor`, except doesn't require a Int -&gt; Float -&gt; Int conversion.
	 * @param e Value to get the floor of.</haxe_doc>
		</floorInt>
		<quantize public="1" get="inline" set="null" line="751" static="1">
			<f a="Value:Quant">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</quantize>
		<setMusic public="1" get="inline" set="null" line="761" static="1">
			<f a="frontEnd:music">
				<c path="flixel.system.frontEnds.SoundFrontEnd"/>
				<c path="flixel.sound.FlxSound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets a SoundFrontEnd's music to a FlxSound.
	 * Example: `FlxG.sound.setMusic(music);`
	 * @param frontEnd SoundFrontEnd to set the music of
	 * @param music Music</haxe_doc>
		</setMusic>
		<flxeaseFromString public="1" get="inline" set="null" line="769" static="1">
			<f a="mainEase:suffix">
				<c path="String"/>
				<c path="String"/>
				<x path="Null"><t path="flixel.tweens.EaseFunction"/></x>
			</f>
			<meta><m n=":noUsing"/></meta>
		</flxeaseFromString>
		<getFilename public="1" get="inline" set="null" line="776" static="1">
			<f a="file">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</getFilename>
		<parseNumberRange public="1" set="method" line="786" static="1">
			<f a="input">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Converts a string of "1..3,5,7..9,8..5" into an array of numbers like [1,2,3,5,7,8,9,8,7,6,5]
	 * @param input String to parse
	 * @return Array of numbers</haxe_doc>
		</parseNumberRange>
		<formatNumberRange public="1" set="method" line="826" static="1">
			<f a="numbers:?seperator" v=":&quot;,&quot;">
				<c path="Array"><x path="Int"/></c>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ seperator : "," }</e></m></meta>
			<haxe_doc>* Converts an array of numbers into a string of ranges.
	 * Example: [1,2,3,5,7,8,9,8,7,6,5] -&gt; "1..3,5,7..9,8..5"
	 * @param numbers Array of numbers
	 * @return String representing the ranges</haxe_doc>
		</formatNumberRange>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.game.PlayState</e></m>
		</meta>
	</class>
	<abstract path="funkin.backend.utils.CoolSfx" params="" file="source/funkin/backend/utils/CoolUtil.hx" module="funkin.backend.utils.CoolUtil">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<haxe_doc>* SFXs to play using `playMenuSFX`.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.utils._CoolUtil.CoolSfx_Impl_" params="" file="source/funkin/backend/utils/CoolUtil.hx" private="1" module="funkin.backend.utils.CoolUtil" extern="1" final="1">
	<SCROLL public="1" get="inline" set="null" expr="cast 0" line="871" static="1">
		<x path="funkin.backend.utils.CoolSfx"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SCROLL>
	<CONFIRM public="1" get="inline" set="null" expr="cast 1" line="872" static="1">
		<x path="funkin.backend.utils.CoolSfx"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CONFIRM>
	<CANCEL public="1" get="inline" set="null" expr="cast 2" line="873" static="1">
		<x path="funkin.backend.utils.CoolSfx"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CANCEL>
	<CHECKED public="1" get="inline" set="null" expr="cast 3" line="874" static="1">
		<x path="funkin.backend.utils.CoolSfx"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CHECKED>
	<UNCHECKED public="1" get="inline" set="null" expr="cast 4" line="875" static="1">
		<x path="funkin.backend.utils.CoolSfx"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UNCHECKED>
	<WARNING public="1" get="inline" set="null" expr="cast 5" line="876" static="1">
		<x path="funkin.backend.utils.CoolSfx"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</WARNING>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.utils._CoolUtil.CoolSfx_Impl_" params="" file="source/funkin/backend/utils/CoolUtil.hx" private="1" module="funkin.backend.utils.CoolUtil" extern="1" final="1">
		<SCROLL public="1" get="inline" set="null" expr="cast 0" line="871" static="1">
			<x path="funkin.backend.utils.CoolSfx"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SCROLL>
		<CONFIRM public="1" get="inline" set="null" expr="cast 1" line="872" static="1">
			<x path="funkin.backend.utils.CoolSfx"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CONFIRM>
		<CANCEL public="1" get="inline" set="null" expr="cast 2" line="873" static="1">
			<x path="funkin.backend.utils.CoolSfx"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CANCEL>
		<CHECKED public="1" get="inline" set="null" expr="cast 3" line="874" static="1">
			<x path="funkin.backend.utils.CoolSfx"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CHECKED>
		<UNCHECKED public="1" get="inline" set="null" expr="cast 4" line="875" static="1">
			<x path="funkin.backend.utils.CoolSfx"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UNCHECKED>
		<WARNING public="1" get="inline" set="null" expr="cast 5" line="876" static="1">
			<x path="funkin.backend.utils.CoolSfx"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</WARNING>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.backend.utils.DiscordUtil" params="" file="source/funkin/backend/utils/DiscordUtil.hx">
		<currentID public="1" set="accessor" expr="null" line="21" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</currentID>
		<discordThread public="1" expr="null" line="22" static="1">
			<x path="sys.thread.Thread"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</discordThread>
		<ready public="1" expr="false" line="23" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</ready>
		<initialized public="1" expr="false" line="24" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</initialized>
		<stopThread expr="false" line="25" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</stopThread>
		<user public="1" expr="null" line="27" static="1">
			<c path="funkin.backend.utils.DUser"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</user>
		<lastPresence public="1" expr="null" line="28" static="1">
			<t path="funkin.backend.utils.DPresence"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastPresence>
		<config public="1" expr="null" line="29" static="1">
			<t path="funkin.backend.utils.DiscordJson"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</config>
		<script public="1" static="1"><c path="funkin.backend.scripting.Script"/></script>
		<REPLY_NO public="1" expr="Discord.REPLY_NO" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Discord.REPLY_NO</e></m></meta>
		</REPLY_NO>
		<REPLY_YES public="1" expr="Discord.REPLY_YES" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Discord.REPLY_YES</e></m></meta>
		</REPLY_YES>
		<REPLY_IGNORE public="1" expr="Discord.REPLY_IGNORE" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Discord.REPLY_IGNORE</e></m></meta>
		</REPLY_IGNORE>
		<PARTY_PRIVATE public="1" expr="Discord.PARTY_PRIVATE" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Discord.PARTY_PRIVATE</e></m></meta>
		</PARTY_PRIVATE>
		<PARTY_PUBLIC public="1" expr="Discord.PARTY_PUBLIC" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Discord.PARTY_PUBLIC</e></m></meta>
		</PARTY_PUBLIC>
		<init public="1" set="method" line="43" static="1"><f a=""><x path="Void"/></f></init>
		<reloadJsonData public="1" set="method" line="73" static="1"><f a=""><x path="Void"/></f></reloadJsonData>
		<event public="1" params="T" set="method" line="96" static="1"><f a="name:event">
	<c path="String"/>
	<c path="event.T"/>
	<c path="event.T"/>
</f></event>
		<call public="1" set="method" line="103" static="1"><f a="name:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></call>
		<loadScript public="1" set="method" line="109" static="1"><f a=""><x path="Void"/></f></loadScript>
		<changePresence public="1" set="method" line="121" static="1"><f a="details:state:?smallImageKey">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></changePresence>
		<changeSongPresence public="1" set="method" line="132" static="1"><f a="details:state:audio:?smallImageKey">
	<c path="String"/>
	<c path="String"/>
	<c path="flixel.sound.FlxSound"/>
	<c path="String"/>
	<x path="Void"/>
</f></changeSongPresence>
		<changePresenceSince public="1" set="method" line="154" static="1"><f a="details:state:?smallImageKey:?time">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></changePresenceSince>
		<fixString public="1" set="method" line="169" static="1">
			<f a="str">
				<c path="String"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</fixString>
		<toString public="1" set="method" line="174" static="1">
			<f a="str">
				<x path="cpp.ConstCharStar"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</toString>
		<changePresenceAdvanced public="1" set="method" line="179" static="1"><f a="data">
	<t path="funkin.backend.utils.DPresence"/>
	<x path="Void"/>
</f></changePresenceAdvanced>
		<clearPresence public="1" set="method" line="232" static="1"><f a=""><x path="Void"/></f></clearPresence>
		<set_currentID set="method" line="239" static="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></set_currentID>
		<shutdown public="1" set="method" line="263" static="1"><f a=""><x path="Void"/></f></shutdown>
		<respond public="1" set="method" line="275" static="1"><f a="userId:reply">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></respond>
		<onReady set="method" line="284" static="1"><f a="request">
	<c path="cpp.RawConstPointer"><c path="hxdiscord_rpc.DiscordUser"/></c>
	<x path="Void"/>
</f></onReady>
		<onDisconnected set="method" line="300" static="1"><f a="errorCode:message">
	<x path="Int"/>
	<x path="cpp.ConstCharStar"/>
	<x path="Void"/>
</f></onDisconnected>
		<onError set="method" line="314" static="1"><f a="errorCode:message">
	<x path="Int"/>
	<x path="cpp.ConstCharStar"/>
	<x path="Void"/>
</f></onError>
		<onJoin set="method" line="326" static="1"><f a="joinSecret">
	<x path="cpp.ConstCharStar"/>
	<x path="Void"/>
</f></onJoin>
		<onSpectate set="method" line="333" static="1"><f a="spectateSecret">
	<x path="cpp.ConstCharStar"/>
	<x path="Void"/>
</f></onSpectate>
		<onJoinReq set="method" line="343" static="1"><f a="request">
	<c path="cpp.RawConstPointer"><c path="hxdiscord_rpc.DiscordUser"/></c>
	<x path="Void"/>
</f></onJoinReq>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.utils.DiscordJson" params="" file="source/funkin/backend/utils/DiscordUtil.hx" module="funkin.backend.utils.DiscordUtil"><a>
	<logoText>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</logoText>
	<logoKey>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</logoKey>
	<clientID>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</clientID>
</a></typedef>
	<class path="funkin.backend.utils.DUser" params="" file="source/funkin/backend/utils/DiscordUtil.hx" module="funkin.backend.utils.DiscordUtil" final="1">
		<initRaw public="1" set="method" line="416" static="1"><f a="req">
	<c path="cpp.RawConstPointer"><c path="hxdiscord_rpc.DiscordUser"/></c>
	<c path="funkin.backend.utils.DUser"/>
</f></initRaw>
		<init public="1" set="method" line="421" static="1"><f a="userData">
	<t path="cpp.Star"><c path="hxdiscord_rpc.DiscordUser"/></t>
	<c path="funkin.backend.utils.DUser"/>
</f></init>
		<handle public="1">
			<c path="String"/>
			<haxe_doc>* The username + discriminator if they have it</haxe_doc>
		</handle>
		<userId public="1">
			<c path="String"/>
			<haxe_doc>* The user id, aka 860561967383445535</haxe_doc>
		</userId>
		<username public="1">
			<c path="String"/>
			<haxe_doc>* The user's username</haxe_doc>
		</username>
		<discriminator public="1">
			<x path="Int"/>
			<haxe_doc>* The #number from before discord changed to usernames only, if the user has changed to a username them its just a 0</haxe_doc>
		</discriminator>
		<avatar public="1">
			<c path="String"/>
			<haxe_doc>* The user's avatar filename</haxe_doc>
		</avatar>
		<globalName public="1">
			<c path="String"/>
			<haxe_doc>* The user's display name</haxe_doc>
		</globalName>
		<bot public="1">
			<x path="Bool"/>
			<haxe_doc>* If the user is a bot or not</haxe_doc>
		</bot>
		<flags public="1">
			<x path="Int"/>
			<haxe_doc>* Idk check discord docs</haxe_doc>
		</flags>
		<premiumType public="1">
			<x path="funkin.backend.utils.NitroType"/>
			<haxe_doc>* If the user has nitro</haxe_doc>
		</premiumType>
		<getAvatar public="1" set="method" line="444">
			<f a="?size" v="256">
				<x path="Int"/>
				<c path="openfl.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ size : 256 }</e></m></meta>
			<haxe_doc>* Calling this function gets the BitmapData of the user</haxe_doc>
		</getAvatar>
		<new set="method" line="411"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noCustomClass"/>
		</meta>
	</class>
	<abstract path="funkin.backend.utils.NitroType" params="" file="source/funkin/backend/utils/DiscordUtil.hx" module="funkin.backend.utils.DiscordUtil">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.utils._DiscordUtil.NitroType_Impl_" params="" file="source/funkin/backend/utils/DiscordUtil.hx" private="1" module="funkin.backend.utils.DiscordUtil" extern="1" final="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="449" static="1">
		<x path="funkin.backend.utils.NitroType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<NITRO_CLASSIC public="1" get="inline" set="null" expr="cast 1" line="450" static="1">
		<x path="funkin.backend.utils.NitroType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NITRO_CLASSIC>
	<NITRO public="1" get="inline" set="null" expr="cast 2" line="451" static="1">
		<x path="funkin.backend.utils.NitroType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NITRO>
	<NITRO_BASIC public="1" get="inline" set="null" expr="cast 3" line="452" static="1">
		<x path="funkin.backend.utils.NitroType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NITRO_BASIC>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.utils._DiscordUtil.NitroType_Impl_" params="" file="source/funkin/backend/utils/DiscordUtil.hx" private="1" module="funkin.backend.utils.DiscordUtil" extern="1" final="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="449" static="1">
			<x path="funkin.backend.utils.NitroType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<NITRO_CLASSIC public="1" get="inline" set="null" expr="cast 1" line="450" static="1">
			<x path="funkin.backend.utils.NitroType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NITRO_CLASSIC>
		<NITRO public="1" get="inline" set="null" expr="cast 2" line="451" static="1">
			<x path="funkin.backend.utils.NitroType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NITRO>
		<NITRO_BASIC public="1" get="inline" set="null" expr="cast 3" line="452" static="1">
			<x path="funkin.backend.utils.NitroType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NITRO_BASIC>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="funkin.backend.utils.DPresence" params="" file="source/funkin/backend/utils/DiscordUtil.hx" module="funkin.backend.utils.DiscordUtil"><a>
	<state>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</state>
	<startTimestamp>
		<x path="Null"><x path="flixel.util.typeLimit.OneOfTwo">
	<x path="Int"/>
	<x path="haxe.Int64"/>
</x></x>
		<meta><m n=":optional"/></meta>
	</startTimestamp>
	<spectateSecret>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</spectateSecret>
	<smallImageText>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</smallImageText>
	<smallImageKey>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</smallImageKey>
	<partySize>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</partySize>
	<partyPrivacy>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</partyPrivacy>
	<partyMax>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</partyMax>
	<partyId>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</partyId>
	<matchSecret>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</matchSecret>
	<largeImageText>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</largeImageText>
	<largeImageKey>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</largeImageKey>
	<joinSecret>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</joinSecret>
	<instance>
		<x path="Null"><x path="flixel.util.typeLimit.OneOfTwo">
	<x path="Int"/>
	<x path="cpp.Int8"/>
</x></x>
		<meta><m n=":optional"/></meta>
	</instance>
	<endTimestamp>
		<x path="Null"><x path="flixel.util.typeLimit.OneOfTwo">
	<x path="Int"/>
	<x path="haxe.Int64"/>
</x></x>
		<meta><m n=":optional"/></meta>
	</endTimestamp>
	<details>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</details>
	<button2Url>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</button2Url>
	<button2Label>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</button2Label>
	<button1Url>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</button1Url>
	<button1Label>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</button1Label>
</a></typedef>
	<typedef path="funkin.backend.utils.DEvents" params="" file="source/funkin/backend/utils/DiscordUtil.hx" module="funkin.backend.utils.DiscordUtil"><a>
	<spectateGame>
		<x path="Null"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</spectateGame>
	<ready>
		<x path="Null"><f a="">
	<c path="funkin.backend.utils.DUser"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</ready>
	<joinRequest>
		<x path="Null"><f a="">
	<c path="funkin.backend.utils.DUser"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</joinRequest>
	<joinGame>
		<x path="Null"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</joinGame>
	<errored>
		<x path="Null"><f a="errorCode:message">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</errored>
	<disconnected>
		<x path="Null"><f a="errorCode:message">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</disconnected>
</a></typedef>
	<class path="funkin.backend.utils.EngineUtil" params="" file="source/funkin/backend/utils/EngineUtil.hx">
		<startMultithreadedScript public="1" set="method" line="12" static="1">
			<f a="path">
				<c path="String"/>
				<c path="funkin.backend.scripting.MultiThreadedScript"/>
			</f>
			<haxe_doc>* Starts a new multithreaded script.
	 * This script will share all the variables with the current one, which means already existing callbacks will be replaced by new ones on conflict.
	 * @param path</haxe_doc>
		</startMultithreadedScript>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.FileAttributeWrapper" params="" file="source/funkin/backend/utils/FileAttributeWrapper.hx">
		<flags><x path="Int"/></flags>
		<getValue public="1" get="inline" set="null" line="13"><f a=""><x path="Int"/></f></getValue>
		<toString public="1" get="inline" set="null" line="26">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns a string representation of the attributes.</haxe_doc>
		</toString>
		<isArchived public="1" get="accessor" set="accessor"><x path="Bool"/></isArchived>
		<get_isArchived set="method" line="38"><f a=""><x path="Bool"/></f></get_isArchived>
		<set_isArchived set="method" line="46"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isArchived>
		<isHidden public="1" get="accessor" set="accessor"><x path="Bool"/></isHidden>
		<get_isHidden set="method" line="60"><f a=""><x path="Bool"/></f></get_isHidden>
		<set_isHidden set="method" line="68"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isHidden>
		<isNormal public="1" get="accessor" set="accessor"><x path="Bool"/></isNormal>
		<get_isNormal set="method" line="82"><f a=""><x path="Bool"/></f></get_isNormal>
		<set_isNormal set="method" line="90"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isNormal>
		<isNotContentIndexed public="1" get="accessor" set="accessor"><x path="Bool"/></isNotContentIndexed>
		<get_isNotContentIndexed set="method" line="104"><f a=""><x path="Bool"/></f></get_isNotContentIndexed>
		<set_isNotContentIndexed set="method" line="112"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isNotContentIndexed>
		<isOffline public="1" get="accessor" set="accessor"><x path="Bool"/></isOffline>
		<get_isOffline set="method" line="126"><f a=""><x path="Bool"/></f></get_isOffline>
		<set_isOffline set="method" line="134"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isOffline>
		<isReadOnly public="1" get="accessor" set="accessor"><x path="Bool"/></isReadOnly>
		<get_isReadOnly set="method" line="148"><f a=""><x path="Bool"/></f></get_isReadOnly>
		<set_isReadOnly set="method" line="156"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isReadOnly>
		<isSystem public="1" get="accessor" set="accessor"><x path="Bool"/></isSystem>
		<get_isSystem set="method" line="170"><f a=""><x path="Bool"/></f></get_isSystem>
		<set_isSystem set="method" line="178"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isSystem>
		<isTemporary public="1" get="accessor" set="accessor"><x path="Bool"/></isTemporary>
		<get_isTemporary set="method" line="192"><f a=""><x path="Bool"/></f></get_isTemporary>
		<set_isTemporary set="method" line="200"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isTemporary>
		<isCompressed public="1" get="accessor" set="null"><x path="Bool"/></isCompressed>
		<get_isCompressed set="method" line="215"><f a=""><x path="Bool"/></f></get_isCompressed>
		<isDevice public="1" get="accessor" set="null"><x path="Bool"/></isDevice>
		<get_isDevice set="method" line="225"><f a=""><x path="Bool"/></f></get_isDevice>
		<isDirectory public="1" get="accessor" set="null"><x path="Bool"/></isDirectory>
		<get_isDirectory set="method" line="235"><f a=""><x path="Bool"/></f></get_isDirectory>
		<isEncrypted public="1" get="accessor" set="null"><x path="Bool"/></isEncrypted>
		<get_isEncrypted set="method" line="245"><f a=""><x path="Bool"/></f></get_isEncrypted>
		<isReparsePoint public="1" get="accessor" set="null"><x path="Bool"/></isReparsePoint>
		<get_isReparsePoint set="method" line="255"><f a=""><x path="Bool"/></f></get_isReparsePoint>
		<isSparseFile public="1" get="accessor" set="null"><x path="Bool"/></isSparseFile>
		<get_isSparseFile set="method" line="265"><f a=""><x path="Bool"/></f></get_isSparseFile>
		<isNothing public="1" get="accessor" set="null"><x path="Bool"/></isNothing>
		<get_isNothing set="method" line="276"><f a=""><x path="Bool"/></f></get_isNothing>
		<new public="1" set="method" line="18"><f a="flags">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Currently only for Windows, but planned to work on other platforms later.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.FlxInterpolateColor" params="" file="source/funkin/backend/utils/FlxInterpolateColor.hx">
		<red public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</red>
		<green public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</green>
		<blue public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</blue>
		<alpha public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</alpha>
		<color public="1" get="accessor" set="accessor"><x path="flixel.util.FlxColor"/></color>
		<get_color get="inline" set="null" line="18"><f a=""><x path="flixel.util.FlxColor"/></f></get_color>
		<set_color get="inline" set="null" line="20"><f a="c">
	<x path="flixel.util.FlxColor"/>
	<x path="flixel.util.FlxColor"/>
</f></set_color>
		<toString public="1" get="inline" set="null" line="29"><f a=""><c path="String"/></f></toString>
		<lerpTo public="1" set="method" line="34"><f a="color:ratio">
	<x path="flixel.util.FlxColor"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lerpTo>
		<fpsLerpTo public="1" get="inline" set="null" line="42"><f a="color:ratio">
	<x path="flixel.util.FlxColor"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fpsLerpTo>
		<new public="1" set="method" line="30"><f a="color">
	<x path="flixel.util.FlxColor"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Additional class for FlxColor lerping.
 * Gets rid of precision issues with `FlxColor.interpolate`</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.FunkinParentDisabler" params="" file="source/funkin/backend/utils/FunkinParentDisabler.hx">
		<extends path="flixel.FlxBasic"/>
		<__tweens><c path="Array"><c path="flixel.tweens.FlxTween"/></c></__tweens>
		<__cameras><c path="Array"><c path="flixel.FlxCamera"/></c></__cameras>
		<__timers><c path="Array"><c path="flixel.util.FlxTimer"/></c></__timers>
		<__sounds><c path="Array"><c path="flixel.sound.FlxSound"/></c></__sounds>
		<__replaceUponDestroy><x path="Bool"/></__replaceUponDestroy>
		<draw public="1" set="method" line="44" override="1"><f a=""><x path="Void"/></f></draw>
		<reset public="1" set="method" line="46"><f a=""><x path="Void"/></f></reset>
		<destroy public="1" set="method" line="53" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="22">
			<f a="?replaceUponDestroy" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ replaceUponDestroy : false }</e></m></meta>
		</new>
		<haxe_doc>* FlxBasic allowing you to disable those elements from the parent state while this substate is opened
 * - Tweens
 * - Camera Movement
 * - Timers
 * - Sounds
 *
 * To use, add `add(new FunkinParentDisabler());` after `super.create();` in your `create` function.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.HttpUtil" params="" file="source/funkin/backend/utils/HttpUtil.hx">
		<userAgent public="1" expr="&quot;request&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"request"</e></m></meta>
		</userAgent>
		<requestText public="1" set="method" line="9" static="1"><f a="url">
	<c path="String"/>
	<c path="String"/>
</f></requestText>
		<requestBytes public="1" set="method" line="35" static="1"><f a="url">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></requestBytes>
		<isRedirect set="method" line="61" static="1"><f a="status">
	<x path="Int"/>
	<x path="Bool"/>
</f></isRedirect>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.IniUtil" params="" file="source/funkin/backend/utils/IniUtil.hx">
		<parseAsset public="1" get="inline" set="null" line="9" static="1"><f a="assetPath:?defaultVariables">
	<c path="String"/>
	<t path="Map">
		<c path="String"/>
		<c path="String"/>
	</t>
	<t path="Map">
		<c path="String"/>
		<c path="String"/>
	</t>
</f></parseAsset>
		<parseString public="1" set="method" line="11" static="1"><f a="data:?defaultVariables">
	<c path="String"/>
	<t path="Map">
		<c path="String"/>
		<c path="String"/>
	</t>
	<t path="Map">
		<c path="String"/>
		<c path="String"/>
	</t>
</f></parseString>
		<haxe_doc>* DOESNT SUPPORT CATEGORIES YET!!</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.MarkdownUtil" params="" file="source/funkin/backend/utils/MarkdownUtil.hx">
		<applyMarkdownText public="1" set="method" line="7" static="1"><f a="text:str">
	<c path="flixel.text.FlxText"/>
	<c path="String"/>
	<x path="Void"/>
</f></applyMarkdownText>
		<createAdvancedMarkerPair public="1" set="method" line="39" static="1">
			<f a="marker:color:size:?bold:?italic:?underline:?blockIndent:?bullet" v=":::false:false:false::">
				<c path="String"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Null"><x path="Float"/></x>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.text.FlxTextFormatMarkerPair"/>
			</f>
			<meta><m n=":value"><e>{ underline : false, italic : false, bold : false }</e></m></meta>
		</createAdvancedMarkerPair>
		<parseWarnings public="1" set="method" line="50" static="1"><f a="text">
	<c path="String"/>
	<c path="String"/>
</f></parseWarnings>
		<prepareMarkdown public="1" set="method" line="58" static="1"><f a="text">
	<c path="String"/>
	<c path="String"/>
</f></prepareMarkdown>
		<parseEmote public="1" set="method" line="77" static="1">
			<f a="text:emote:beginning:end:?emoteEnd" v="::::&quot;\n&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ emoteEnd : "\n" }</e></m></meta>
		</parseEmote>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.MemoryUtil" params="" file="source/funkin/backend/utils/MemoryUtil.hx">
		<disableCount public="1" expr="0" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</disableCount>
		<askDisable public="1" set="method" line="20" static="1"><f a=""><x path="Void"/></f></askDisable>
		<askEnable public="1" set="method" line="27" static="1"><f a=""><x path="Void"/></f></askEnable>
		<init public="1" set="method" line="35" static="1"><f a=""><x path="Void"/></f></init>
		<clearMinor public="1" set="method" line="37" static="1"><f a=""><x path="Void"/></f></clearMinor>
		<clearMajor public="1" set="method" line="43" static="1"><f a=""><x path="Void"/></f></clearMajor>
		<enable public="1" set="method" line="54" static="1"><f a=""><x path="Void"/></f></enable>
		<disable public="1" set="method" line="60" static="1"><f a=""><x path="Void"/></f></disable>
		<getTotalMem public="1" set="method" line="67" static="1"><f a=""><x path="Float"/></f></getTotalMem>
		<currentMemUsage public="1" get="inline" set="null" line="79" static="1"><f a=""><x path="Float"/></f></currentMemUsage>
		<getMemType public="1" set="method" line="92" static="1"><f a=""><c path="String"/></f></getMemType>
		<_nb expr="0" line="145" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_nb>
		<_nbD expr="0" line="146" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_nbD>
		<_zombie static="1"><d/></_zombie>
		<destroyFlixelZombies public="1" set="method" line="149" static="1"><f a=""><x path="Void"/></f></destroyFlixelZombies>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.NativeAPI" params="" file="source/funkin/backend/utils/NativeAPI.hx">
		<registerAudio public="1" set="method" line="12" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</registerAudio>
		<registerAsDPICompatible public="1" set="method" line="18" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</registerAsDPICompatible>
		<allocConsole public="1" set="method" line="27" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Allocates a new console. The console will automatically be opened</haxe_doc>
		</allocConsole>
		<getFileAttributesRaw public="1" set="method" line="37" static="1">
			<f a="path:?useAbsol" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ useAbsol : true }</e></m></meta>
			<haxe_doc>* Gets the specified file's (or folder) attributes.</haxe_doc>
		</getFileAttributesRaw>
		<getFileAttributes public="1" set="method" line="49" static="1">
			<f a="path:?useAbsol" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="funkin.backend.utils.FileAttributeWrapper"/>
			</f>
			<meta><m n=":value"><e>{ useAbsol : true }</e></m></meta>
			<haxe_doc>* Gets the specified file's (or folder) attributes and passes it to `FileAttributeWrapper`.</haxe_doc>
		</getFileAttributes>
		<setFileAttributes public="1" set="method" line="56" static="1">
			<f a="path:attrib:?useAbsol" v="::true">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfThree">
					<x path="funkin.backend.utils.FileAttribute"/>
					<c path="funkin.backend.utils.FileAttributeWrapper"/>
					<x path="Int"/>
				</x>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ useAbsol : true }</e></m></meta>
			<haxe_doc>* Sets the specified file's (or folder) attributes. If it fails, the return value is `0`.</haxe_doc>
		</setFileAttributes>
		<addFileAttributes public="1" set="method" line="68" static="1">
			<f a="path:attrib:?useAbsol" v="::true">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfTwo">
					<x path="funkin.backend.utils.FileAttribute"/>
					<x path="Int"/>
				</x>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ useAbsol : true }</e></m></meta>
			<haxe_doc>* Removes from the specified file's (or folder) one (or more) specific attribute.</haxe_doc>
		</addFileAttributes>
		<removeFileAttributes public="1" set="method" line="79" static="1">
			<f a="path:attrib:?useAbsol" v="::true">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfTwo">
					<x path="funkin.backend.utils.FileAttribute"/>
					<x path="Int"/>
				</x>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ useAbsol : true }</e></m></meta>
			<haxe_doc>* Removes from the specified file's (or folder) one (or more) specific attribute.</haxe_doc>
		</removeFileAttributes>
		<setDarkMode public="1" set="method" line="87" static="1"><f a="title:enable">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setDarkMode>
		<showMessageBox public="1" set="method" line="96" static="1">
			<f a="caption:message:?icon" v="::MSG_WARNING">
				<c path="String"/>
				<c path="String"/>
				<x path="funkin.backend.utils.MessageBoxIcon"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ icon : MSG_WARNING }</e></m></meta>
			<haxe_doc>* Shows a message box</haxe_doc>
		</showMessageBox>
		<setConsoleColors public="1" set="method" line="107" static="1">
			<f a="?foregroundColor:?backgroundColor" v="NONE:NONE">
				<x path="funkin.backend.utils.ConsoleColor"/>
				<x path="funkin.backend.utils.ConsoleColor"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ backgroundColor : NONE, foregroundColor : NONE }</e></m></meta>
			<haxe_doc>* Sets the console colors</haxe_doc>
		</setConsoleColors>
		<consoleColorToANSI public="1" set="method" line="128" static="1"><f a="color">
	<x path="funkin.backend.utils.ConsoleColor"/>
	<x path="Int"/>
</f></consoleColorToANSI>
		<consoleColorToOpenFL public="1" set="method" line="149" static="1"><f a="color">
	<x path="funkin.backend.utils.ConsoleColor"/>
	<x path="Int"/>
</f></consoleColorToOpenFL>
		<haxe_doc>* Class for functions that talk to a lower level than haxe, such as message boxes, and more.
 * Some functions might not have effect on some platforms.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="funkin.backend.utils.FileAttribute" params="" file="source/funkin/backend/utils/NativeAPI.hx" module="funkin.backend.utils.NativeAPI">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.utils._NativeAPI.FileAttribute_Impl_" params="" file="source/funkin/backend/utils/NativeAPI.hx" private="1" module="funkin.backend.utils.NativeAPI" extern="1" final="1">
	<ARCHIVE public="1" get="inline" set="null" expr="cast 0x20" line="173" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x20</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ARCHIVE>
	<HIDDEN public="1" get="inline" set="null" expr="cast 0x2" line="174" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HIDDEN>
	<NORMAL public="1" get="inline" set="null" expr="cast 0x80" line="175" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x80</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NORMAL>
	<NOT_CONTENT_INDEXED public="1" get="inline" set="null" expr="cast 0x2000" line="176" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x2000</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOT_CONTENT_INDEXED>
	<OFFLINE public="1" get="inline" set="null" expr="cast 0x1000" line="177" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x1000</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</OFFLINE>
	<READONLY public="1" get="inline" set="null" expr="cast 0x1" line="178" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</READONLY>
	<SYSTEM public="1" get="inline" set="null" expr="cast 0x4" line="179" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SYSTEM>
	<TEMPORARY public="1" get="inline" set="null" expr="cast 0x100" line="180" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x100</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TEMPORARY>
	<COMPRESSED public="1" get="inline" set="null" expr="cast 0x800" line="183" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x800</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COMPRESSED>
	<DEVICE public="1" get="inline" set="null" expr="cast 0x40" line="184" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x40</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DEVICE>
	<DIRECTORY public="1" get="inline" set="null" expr="cast 0x10" line="185" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DIRECTORY>
	<ENCRYPTED public="1" get="inline" set="null" expr="cast 0x4000" line="186" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x4000</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ENCRYPTED>
	<REPARSE_POINT public="1" get="inline" set="null" expr="cast 0x400" line="187" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x400</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</REPARSE_POINT>
	<SPARSE_FILE public="1" get="inline" set="null" expr="cast 0x200" line="188" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x200</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SPARSE_FILE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.utils._NativeAPI.FileAttribute_Impl_" params="" file="source/funkin/backend/utils/NativeAPI.hx" private="1" module="funkin.backend.utils.NativeAPI" extern="1" final="1">
		<ARCHIVE public="1" get="inline" set="null" expr="cast 0x20" line="173" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x20</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ARCHIVE>
		<HIDDEN public="1" get="inline" set="null" expr="cast 0x2" line="174" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HIDDEN>
		<NORMAL public="1" get="inline" set="null" expr="cast 0x80" line="175" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x80</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NORMAL>
		<NOT_CONTENT_INDEXED public="1" get="inline" set="null" expr="cast 0x2000" line="176" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x2000</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOT_CONTENT_INDEXED>
		<OFFLINE public="1" get="inline" set="null" expr="cast 0x1000" line="177" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x1000</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</OFFLINE>
		<READONLY public="1" get="inline" set="null" expr="cast 0x1" line="178" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</READONLY>
		<SYSTEM public="1" get="inline" set="null" expr="cast 0x4" line="179" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SYSTEM>
		<TEMPORARY public="1" get="inline" set="null" expr="cast 0x100" line="180" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x100</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TEMPORARY>
		<COMPRESSED public="1" get="inline" set="null" expr="cast 0x800" line="183" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x800</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COMPRESSED>
		<DEVICE public="1" get="inline" set="null" expr="cast 0x40" line="184" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x40</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DEVICE>
		<DIRECTORY public="1" get="inline" set="null" expr="cast 0x10" line="185" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DIRECTORY>
		<ENCRYPTED public="1" get="inline" set="null" expr="cast 0x4000" line="186" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x4000</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ENCRYPTED>
		<REPARSE_POINT public="1" get="inline" set="null" expr="cast 0x400" line="187" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x400</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</REPARSE_POINT>
		<SPARSE_FILE public="1" get="inline" set="null" expr="cast 0x200" line="188" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x200</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SPARSE_FILE>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="funkin.backend.utils.ConsoleColor" params="" file="source/funkin/backend/utils/NativeAPI.hx" module="funkin.backend.utils.NativeAPI">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.utils._NativeAPI.ConsoleColor_Impl_" params="" file="source/funkin/backend/utils/NativeAPI.hx" private="1" module="funkin.backend.utils.NativeAPI" extern="1" final="1">
	<BLACK public="1" get="inline" set="null" expr="cast 0" line="192" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BLACK>
	<DARKBLUE public="1" get="inline" set="null" expr="cast 1" line="193" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DARKBLUE>
	<DARKGREEN public="1" get="inline" set="null" expr="cast 2" line="194" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DARKGREEN>
	<DARKCYAN public="1" get="inline" set="null" expr="cast 3" line="195" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DARKCYAN>
	<DARKRED public="1" get="inline" set="null" expr="cast 4" line="196" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DARKRED>
	<DARKMAGENTA public="1" get="inline" set="null" expr="cast 5" line="197" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DARKMAGENTA>
	<DARKYELLOW public="1" get="inline" set="null" expr="cast 6" line="198" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DARKYELLOW>
	<LIGHTGRAY public="1" get="inline" set="null" expr="cast 7" line="199" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LIGHTGRAY>
	<GRAY public="1" get="inline" set="null" expr="cast 8" line="200" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</GRAY>
	<BLUE public="1" get="inline" set="null" expr="cast 9" line="201" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BLUE>
	<GREEN public="1" get="inline" set="null" expr="cast 10" line="202" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</GREEN>
	<CYAN public="1" get="inline" set="null" expr="cast 11" line="203" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CYAN>
	<RED public="1" get="inline" set="null" expr="cast 12" line="204" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RED>
	<MAGENTA public="1" get="inline" set="null" expr="cast 13" line="205" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MAGENTA>
	<YELLOW public="1" get="inline" set="null" expr="cast 14" line="206" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</YELLOW>
	<WHITE public="1" get="inline" set="null" expr="cast 15" line="207" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</WHITE>
	<NONE public="1" get="inline" set="null" expr="cast -1" line="209" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast -1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.utils._NativeAPI.ConsoleColor_Impl_" params="" file="source/funkin/backend/utils/NativeAPI.hx" private="1" module="funkin.backend.utils.NativeAPI" extern="1" final="1">
		<BLACK public="1" get="inline" set="null" expr="cast 0" line="192" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BLACK>
		<DARKBLUE public="1" get="inline" set="null" expr="cast 1" line="193" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DARKBLUE>
		<DARKGREEN public="1" get="inline" set="null" expr="cast 2" line="194" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DARKGREEN>
		<DARKCYAN public="1" get="inline" set="null" expr="cast 3" line="195" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DARKCYAN>
		<DARKRED public="1" get="inline" set="null" expr="cast 4" line="196" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DARKRED>
		<DARKMAGENTA public="1" get="inline" set="null" expr="cast 5" line="197" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DARKMAGENTA>
		<DARKYELLOW public="1" get="inline" set="null" expr="cast 6" line="198" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DARKYELLOW>
		<LIGHTGRAY public="1" get="inline" set="null" expr="cast 7" line="199" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LIGHTGRAY>
		<GRAY public="1" get="inline" set="null" expr="cast 8" line="200" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</GRAY>
		<BLUE public="1" get="inline" set="null" expr="cast 9" line="201" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BLUE>
		<GREEN public="1" get="inline" set="null" expr="cast 10" line="202" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</GREEN>
		<CYAN public="1" get="inline" set="null" expr="cast 11" line="203" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CYAN>
		<RED public="1" get="inline" set="null" expr="cast 12" line="204" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RED>
		<MAGENTA public="1" get="inline" set="null" expr="cast 13" line="205" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MAGENTA>
		<YELLOW public="1" get="inline" set="null" expr="cast 14" line="206" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</YELLOW>
		<WHITE public="1" get="inline" set="null" expr="cast 15" line="207" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</WHITE>
		<NONE public="1" get="inline" set="null" expr="cast -1" line="209" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast -1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="funkin.backend.utils.MessageBoxIcon" params="" file="source/funkin/backend/utils/NativeAPI.hx" module="funkin.backend.utils.NativeAPI">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.utils._NativeAPI.MessageBoxIcon_Impl_" params="" file="source/funkin/backend/utils/NativeAPI.hx" private="1" module="funkin.backend.utils.NativeAPI" extern="1" final="1">
	<MSG_ERROR public="1" get="inline" set="null" expr="cast 0x00000010" line="213" static="1">
		<x path="funkin.backend.utils.MessageBoxIcon"/>
		<meta>
			<m n=":value"><e>cast 0x00000010</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MSG_ERROR>
	<MSG_QUESTION public="1" get="inline" set="null" expr="cast 0x00000020" line="214" static="1">
		<x path="funkin.backend.utils.MessageBoxIcon"/>
		<meta>
			<m n=":value"><e>cast 0x00000020</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MSG_QUESTION>
	<MSG_WARNING public="1" get="inline" set="null" expr="cast 0x00000030" line="215" static="1">
		<x path="funkin.backend.utils.MessageBoxIcon"/>
		<meta>
			<m n=":value"><e>cast 0x00000030</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MSG_WARNING>
	<MSG_INFORMATION public="1" get="inline" set="null" expr="cast 0x00000040" line="216" static="1">
		<x path="funkin.backend.utils.MessageBoxIcon"/>
		<meta>
			<m n=":value"><e>cast 0x00000040</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MSG_INFORMATION>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.utils._NativeAPI.MessageBoxIcon_Impl_" params="" file="source/funkin/backend/utils/NativeAPI.hx" private="1" module="funkin.backend.utils.NativeAPI" extern="1" final="1">
		<MSG_ERROR public="1" get="inline" set="null" expr="cast 0x00000010" line="213" static="1">
			<x path="funkin.backend.utils.MessageBoxIcon"/>
			<meta>
				<m n=":value"><e>cast 0x00000010</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MSG_ERROR>
		<MSG_QUESTION public="1" get="inline" set="null" expr="cast 0x00000020" line="214" static="1">
			<x path="funkin.backend.utils.MessageBoxIcon"/>
			<meta>
				<m n=":value"><e>cast 0x00000020</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MSG_QUESTION>
		<MSG_WARNING public="1" get="inline" set="null" expr="cast 0x00000030" line="215" static="1">
			<x path="funkin.backend.utils.MessageBoxIcon"/>
			<meta>
				<m n=":value"><e>cast 0x00000030</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MSG_WARNING>
		<MSG_INFORMATION public="1" get="inline" set="null" expr="cast 0x00000040" line="216" static="1">
			<x path="funkin.backend.utils.MessageBoxIcon"/>
			<meta>
				<m n=":value"><e>cast 0x00000040</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MSG_INFORMATION>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.backend.utils.NdllUtil" params="" file="source/funkin/backend/utils/NdllUtil.hx">
		<os final="1" public="1" set="null" expr="&quot;windows&quot;" line="21" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"windows"</e></m></meta>
		</os>
		<getFunction public="1" set="method" line="36" static="1">
			<f a="ndll:name:args">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>* Returns an function from a Haxe NDLL.
	 * Limited to 25 argument due to a limitation
	 *
	 * @param ndll Name of the NDLL.
	 * @param name Name of the function.
	 * @param args Number of arguments of that function.</haxe_doc>
		</getFunction>
		<getFunctionFromPath public="1" set="method" line="58" static="1">
			<f a="ndll:name:args">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>* Returns an function from a Haxe NDLL at specified path.
	 *
	 * @param ndll Asset path to the NDLL.
	 * @param name Name of the function.
	 * @param args Number of arguments of that function.</haxe_doc>
		</getFunctionFromPath>
		<noop set="method" line="77" static="1">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</noop>
		<haxe_doc>* Small util that allows you to load any function from ndlls via `getFunction`.
 *
 * NDLLs must be in your mod's "ndlls" folder, and must follow this name scheme:
 * - `name-windows.ndll` for Windows targeted ndlls
 * - `name-linux.ndll` for Linux targeted ndlls
 * - `name-mac.ndll` for Mac targeted ndlls
 *
 * If:
 * - The platform does not support NDLLs
 * - The NDLL is not found
 * - The Function cannot be found in the NDLL
 * then an empty function will be returned instead, and a message will be shown in logs.</haxe_doc>
	</class>
	<class path="funkin.backend.utils.ShaderResizeFix" params="" file="source/funkin/backend/utils/ShaderResizeFix.hx">
		<doResizeFix public="1" expr="true" line="6" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</doResizeFix>
		<init public="1" set="method" line="8" static="1"><f a=""><x path="Void"/></f></init>
		<fixSpritesShadersSizes public="1" get="inline" set="null" line="12" static="1"><f a=""><x path="Void"/></f></fixSpritesShadersSizes>
		<fixSpriteShaderSize public="1" get="inline" set="null" line="27" static="1"><f a="sprite">
	<c path="openfl.display.Sprite"/>
	<x path="Void"/>
</f></fixSpriteShaderSize>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.SortedArrayUtil" params="" file="source/funkin/backend/utils/SortedArrayUtil.hx">
		<binarySearch public="1" params="T" get="inline" set="null" line="13" static="1">
			<f a="array:val:getVal">
				<c path="Array"><c path="binarySearch.T"/></c>
				<x path="Float"/>
				<f a="">
					<c path="binarySearch.T"/>
					<x path="Float"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>* Gets the index of a possible new element of an Array of T using an efficient algorithm.
	 * @param array Array of T to check in
	 * @param getVal Function that returns the position value of T
	 * @return Index</haxe_doc>
		</binarySearch>
		<addSorted public="1" params="T" get="inline" set="null" line="45" static="1">
			<f a="array:val:getVal">
				<c path="Array"><c path="addSorted.T"/></c>
				<c path="addSorted.T"/>
				<f a="">
					<c path="addSorted.T"/>
					<x path="Float"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds to a sorted array, using binary search.
	 * @param array Array to add to
	 * @param val Value to add
	 * @param getVal Function that returns the value that needs to be sorted</haxe_doc>
		</addSorted>
		<haxe_doc>* All types of utils only usable in a sorted array.</haxe_doc>
	</class>
	<class path="funkin.backend.utils.SysZip" params="" file="source/funkin/backend/utils/SysZip.hx">
		<extends path="haxe.zip.Reader"/>
		<openFromFile public="1" set="method" line="25" static="1">
			<f a="path">
				<c path="String"/>
				<c path="funkin.backend.utils.SysZip"/>
			</f>
			<haxe_doc>* Opens a zip from a specified path.
	 * @param path Path to the zip file.</haxe_doc>
		</openFromFile>
		<input><c path="haxe.io.Input"/></input>
		<fileInput><c path="sys.io.FileInput"/></fileInput>
		<entries public="1"><t path="List"><t path="funkin.backend.utils.SysZipEntry"/></t></entries>
		<readEntryData public="1" set="method" line="44">
			<f a="e">
				<t path="funkin.backend.utils.SysZipEntry"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Reads all the data present in a specified entry.
	 * NOTE: If the entry is compressed, the data won't be decompressed. For decompression, use `unzipEntry`.
	 * @param e Entry</haxe_doc>
		</readEntryData>
		<unzipEntry public="1" set="method" line="116">
			<f a="f">
				<t path="funkin.backend.utils.SysZipEntry"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Unzips and returns all of the data present in an entry.
	 * @param f Entry to read from.</haxe_doc>
		</unzipEntry>
		<read public="1" set="method" line="131" override="1"><f a=""><t path="List"><t path="haxe.zip.Entry"/></t></f></read>
		<dispose public="1" set="method" line="148"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="34">
			<f a="input">
				<c path="sys.io.FileInput"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new SysZip from a specified file input.
	 * @param input File input.</haxe_doc>
		</new>
		<haxe_doc>* Class that extends Reader allowing you to load ZIP entries without blowing your RAM up!!
 * Half of the code is taken from haxe libraries btw</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.utils.SysZipEntry" params="" file="source/funkin/backend/utils/SysZip.hx" module="funkin.backend.utils.SysZip"><a>
	<seekPos><x path="Int"/></seekPos>
	<fileTime><c path="Date"/></fileTime>
	<fileSize><x path="Int"/></fileSize>
	<fileName><c path="String"/></fileName>
	<extraFields>
		<x path="Null"><c path="haxe.ds.List"><e path="haxe.zip.ExtraField"/></c></x>
		<meta><m n=":optional"/></meta>
	</extraFields>
	<dataSize><x path="Int"/></dataSize>
	<data><x path="Null"><c path="haxe.io.Bytes"/></x></data>
	<crc32><x path="Null"><x path="Int"/></x></crc32>
	<compressed><x path="Bool"/></compressed>
</a></typedef>
	<class path="funkin.backend.utils.ThreadUtil" params="" file="source/funkin/backend/utils/ThreadUtil.hx"><createSafe public="1" set="method" line="10" static="1">
	<f a="func:?autoRestart" v=":false">
		<f a=""><x path="Void"/></f>
		<x path="Bool"/>
		<x path="sys.thread.Thread"/>
	</f>
	<meta><m n=":value"><e>{ autoRestart : false }</e></m></meta>
	<haxe_doc>* Creates a new Thread with an error handler.
	 * @param func Function to execute
	 * @param autoRestart Whenever the thread should auto restart itself after crashing.</haxe_doc>
</createSafe></class>
	<class path="funkin.backend.utils.WindowUtils" params="" file="source/funkin/backend/utils/WindowUtils.hx">
		<winTitle public="1" set="accessor" static="1"><c path="String"/></winTitle>
		<set_winTitle set="method" line="7" static="1"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_winTitle>
		<prefix public="1" set="accessor" expr="&quot;&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</prefix>
		<set_prefix set="method" line="13" static="1"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_prefix>
		<suffix public="1" set="accessor" expr="&quot;&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</suffix>
		<set_suffix set="method" line="19" static="1"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_suffix>
		<preventClosing public="1" expr="true" line="25" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</preventClosing>
		<onClosing public="1" static="1"><f a=""><x path="Void"/></f></onClosing>
		<__triedClosing expr="false" line="28" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__triedClosing>
		<resetClosing public="1" get="inline" set="null" line="29" static="1"><f a=""><x path="Void"/></f></resetClosing>
		<init public="1" get="inline" set="null" line="31" static="1"><f a=""><x path="Void"/></f></init>
		<resetTitle public="1" get="inline" set="null" line="44" static="1"><f a=""><x path="Void"/></f></resetTitle>
		<resetAffixes public="1" get="inline" set="null" line="49" static="1"><f a=""><x path="Void"/></f></resetAffixes>
		<updateTitle public="1" get="inline" set="null" line="55" static="1"><f a=""><x path="Void"/></f></updateTitle>
		<endfix public="1" get="accessor" set="accessor" static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</endfix>
		<set_endfix set="method" line="59" static="1">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_endfix>
		<get_endfix set="method" line="62" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_endfix>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.utils.TextFormat" params="" file="source/funkin/backend/utils/XMLUtil.hx" module="funkin.backend.utils.XMLUtil"><a>
	<text><c path="String"/></text>
	<format><d/></format>
</a></typedef>
	<class path="funkin.backend.utils.XMLUtil" params="" file="source/funkin/backend/utils/XMLUtil.hx">
		<applyXMLProperty public="1" set="method" line="29" static="1">
			<f a="object:property">
				<d/>
				<x path="haxe.xml.Access"/>
				<x path="funkin.backend.system.ErrorCode"/>
			</f>
			<haxe_doc>* Applies a property XML node to an object.
	 * @param object Object to which the xml property will be applied
	 * @param property `property` node.</haxe_doc>
		</applyXMLProperty>
		<loadSpriteFromXML public="1" set="method" line="73" static="1">
			<f a="spr:node:?parentFolder:?defaultAnimType" v="::&quot;&quot;:BEAT">
				<c path="funkin.backend.FunkinSprite"/>
				<x path="haxe.xml.Access"/>
				<c path="String"/>
				<x path="funkin.backend.XMLAnimType"/>
				<c path="funkin.backend.FunkinSprite"/>
			</f>
			<meta><m n=":value"><e>{ defaultAnimType : BEAT, parentFolder : "" }</e></m></meta>
			<haxe_doc>* Overrides a sprite based on a XML node.</haxe_doc>
		</loadSpriteFromXML>
		<createSpriteFromXML public="1" get="inline" set="null" line="188" static="1">
			<f a="node:?parentFolder:?defaultAnimType:?cl:?args" v=":&quot;&quot;:BEAT::">
				<x path="haxe.xml.Access"/>
				<c path="String"/>
				<x path="funkin.backend.XMLAnimType"/>
				<x path="Class"><c path="funkin.backend.FunkinSprite"/></x>
				<c path="Array"><d/></c>
				<c path="funkin.backend.FunkinSprite"/>
			</f>
			<meta><m n=":value"><e>{ defaultAnimType : BEAT, parentFolder : "" }</e></m></meta>
			<haxe_doc>* Creates a new sprite based on a XML node.</haxe_doc>
		</createSpriteFromXML>
		<extractAnimFromXML public="1" set="method" line="194" static="1">
			<f a="anim:?animType:?loop" v=":NONE:false">
				<x path="haxe.xml.Access"/>
				<x path="funkin.backend.XMLAnimType"/>
				<x path="Bool"/>
				<t path="funkin.backend.utils.AnimData"/>
			</f>
			<meta><m n=":value"><e>{ loop : false, animType : NONE }</e></m></meta>
		</extractAnimFromXML>
		<addXMLAnimation public="1" set="method" line="223" static="1">
			<f a="sprite:anim:?loop" v="::false">
				<c path="flixel.FlxSprite"/>
				<x path="haxe.xml.Access"/>
				<x path="Bool"/>
				<x path="funkin.backend.system.ErrorCode"/>
			</f>
			<meta><m n=":value"><e>{ loop : false }</e></m></meta>
			<haxe_doc>* Adds an XML animation to `sprite`.
	 * @param sprite Destination sprite
	 * @param anim Animation (Must be a `anim` XML node)</haxe_doc>
		</addXMLAnimation>
		<addAnimToSprite public="1" set="method" line="232" static="1"><f a="sprite:animData">
	<c path="flixel.FlxSprite"/>
	<t path="funkin.backend.utils.AnimData"/>
	<x path="funkin.backend.system.ErrorCode"/>
</f></addAnimToSprite>
		<defaultForcedCheck public="1" get="inline" set="null" line="279" static="1"><f a="animName:sprite">
	<c path="String"/>
	<c path="funkin.backend.FunkinSprite"/>
	<x path="Bool"/>
</f></defaultForcedCheck>
		<fixXMLText public="1" get="inline" set="null" line="281" static="1"><f a="text">
	<c path="String"/>
	<c path="String"/>
</f></fixXMLText>
		<fixSpacingInNode public="1" set="method" line="289" static="1">
			<f a="node">
				<x path="haxe.xml.Access"/>
				<x path="haxe.xml.Access"/>
			</f>
			<haxe_doc>* WARNING: will edit directly the node!</haxe_doc>
		</fixSpacingInNode>
		<getTextFormats public="1" set="method" line="304" static="1">
			<f a="_node:?currentFormat:?parsedSegments" v=":null:null">
				<x path="flixel.util.typeLimit.OneOfTwo">
					<c path="Xml"/>
					<x path="haxe.xml.Access"/>
				</x>
				<d/>
				<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
				<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
			</f>
			<meta><m n=":value"><e>{ parsedSegments : null, currentFormat : null }</e></m></meta>
		</getTextFormats>
		<haxe_doc>* Class made to make XML parsing easier.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.XMLImportedScriptInfo" params="" file="source/funkin/backend/utils/XMLUtil.hx" module="funkin.backend.utils.XMLUtil">
		<prepareInfos public="1" set="method" line="347" static="1"><f a="node:parentScriptPack:?onScriptPreLoad">
	<x path="haxe.xml.Access"/>
	<c path="funkin.backend.scripting.ScriptPack"/>
	<f a="">
		<c path="funkin.backend.utils.XMLImportedScriptInfo"/>
		<x path="Void"/>
	</f>
	<c path="funkin.backend.utils.XMLImportedScriptInfo"/>
</f></prepareInfos>
		<shouldLoadBefore public="1" get="inline" set="null" line="374" static="1">
			<f a="node">
				<x path="haxe.xml.Access"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</shouldLoadBefore>
		<path public="1"><c path="String"/></path>
		<shortLived public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</shortLived>
		<loadBefore public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</loadBefore>
		<importStageSprites public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</importStageSprites>
		<parentScriptPack public="1" expr="null">
			<c path="funkin.backend.scripting.ScriptPack"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</parentScriptPack>
		<getScript public="1" set="method" line="345"><f a=""><c path="funkin.backend.scripting.Script"/></f></getScript>
		<new public="1" set="method" line="339"><f a="path:parentScriptPack">
	<c path="String"/>
	<c path="funkin.backend.scripting.ScriptPack"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.utils.AnimData" params="" file="source/funkin/backend/utils/XMLUtil.hx" module="funkin.backend.utils.XMLUtil"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<name><c path="String"/></name>
	<loop><x path="Bool"/></loop>
	<indices><c path="Array"><x path="Int"/></c></indices>
	<fps><x path="Float"/></fps>
	<forced>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</forced>
	<animType><x path="funkin.backend.XMLAnimType"/></animType>
	<anim><c path="String"/></anim>
</a></typedef>
	<typedef path="funkin.backend.utils.BeatAnim" params="" file="source/funkin/backend/utils/XMLUtil.hx" module="funkin.backend.utils.XMLUtil"><a>
	<name><c path="String"/></name>
	<forced><x path="Bool"/></forced>
</a></typedef>
	<class path="funkin.backend.utils.ZipUtil" params="" file="source/funkin/backend/utils/ZipUtil.hx">
		<bannedNames public="1" expr="[&quot;.git&quot;, &quot;.gitignore&quot;, &quot;.github&quot;, &quot;.vscode&quot;, &quot;.gitattributes&quot;, &quot;readme.txt&quot;]" line="27" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[".git", ".gitignore", ".github", ".vscode", ".gitattributes", "readme.txt"]</e></m></meta>
		</bannedNames>
		<uncompressZip public="1" set="method" line="34" static="1">
			<f a="zip:destFolder:?prefix:?prog">
				<c path="haxe.zip.Reader"/>
				<c path="String"/>
				<c path="String"/>
				<c path="funkin.backend.utils.ZipProgress"/>
				<c path="funkin.backend.utils.ZipProgress"/>
			</f>
			<haxe_doc>* [Description] Uncompresses `zip` into the `destFolder` folder
	 * @param zip
	 * @param destFolder</haxe_doc>
		</uncompressZip>
		<uncompressZipAsync public="1" set="method" line="78" static="1"><f a="zip:destFolder:?prog:?prefix">
	<c path="haxe.zip.Reader"/>
	<c path="String"/>
	<c path="funkin.backend.utils.ZipProgress"/>
	<c path="String"/>
	<c path="funkin.backend.utils.ZipProgress"/>
</f></uncompressZipAsync>
		<openZip public="1" set="method" line="93" static="1">
			<f a="zipPath">
				<c path="String"/>
				<c path="haxe.zip.Reader"/>
			</f>
			<haxe_doc>* [Description] Returns a `zip.Reader` instance from path.
	 * @param zipPath
	 * @return Reader</haxe_doc>
		</openZip>
		<unzip public="1" set="method" line="101" static="1">
			<f a="f">
				<t path="haxe.zip.Entry"/>
				<x path="Null"><c path="haxe.io.Bytes"/></x>
			</f>
			<haxe_doc>* [Description] Copy of haxe's Zip unzip function cause lime replaced it.
	 * @param f Zip entry</haxe_doc>
		</unzip>
		<createZipFile public="1" set="method" line="121" static="1">
			<f a="path">
				<c path="String"/>
				<c path="funkin.backend.utils.ZipWriter"/>
			</f>
			<haxe_doc>* [Description] Creates a ZIP file at the specified location and returns the Writer.
	 * @param path
	 * @return Writer</haxe_doc>
		</createZipFile>
		<writeFolderToZip public="1" set="method" line="132" static="1">
			<f a="zip:path:?prefix:?prog:?whitelist">
				<c path="funkin.backend.utils.ZipWriter"/>
				<c path="String"/>
				<c path="String"/>
				<c path="funkin.backend.utils.ZipProgress"/>
				<c path="Array"><c path="String"/></c>
				<c path="funkin.backend.utils.ZipProgress"/>
			</f>
			<haxe_doc>[Description] Writes the entirety of a folder to a zip file.
		@param zip ZIP file to write to
		@param path Folder path
		@param prefix (Additional) allows you to set a prefix in the zip itself.</haxe_doc>
		</writeFolderToZip>
		<writeFolderToZipAsync public="1" set="method" line="195" static="1"><f a="zip:path:?prefix">
	<c path="funkin.backend.utils.ZipWriter"/>
	<c path="String"/>
	<c path="String"/>
	<c path="funkin.backend.utils.ZipProgress"/>
</f></writeFolderToZipAsync>
		<arrayToList public="1" set="method" line="208" static="1">
			<f a="array">
				<c path="Array"><t path="haxe.zip.Entry"/></c>
				<t path="List"><t path="haxe.zip.Entry"/></t>
			</f>
			<haxe_doc>* [Description] Converts an `Array&lt;Entry&gt;` to a `List&lt;Entry&gt;`.
	 * @param array
	 * @return List&lt;Entry&gt;</haxe_doc>
		</arrayToList>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.ZipProgress" params="" file="source/funkin/backend/utils/ZipUtil.hx" module="funkin.backend.utils.ZipUtil">
		<error public="1" expr="null">
			<c path="haxe.Exception"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</error>
		<curFile public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curFile>
		<fileCount public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</fileCount>
		<done public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</done>
		<percentage public="1" get="accessor" set="null"><x path="Float"/></percentage>
		<get_percentage set="method" line="223"><f a=""><x path="Float"/></f></get_percentage>
		<new public="1" set="method" line="227"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.ZipReader" params="" file="source/funkin/backend/utils/ZipUtil.hx" module="funkin.backend.utils.ZipUtil">
		<extends path="haxe.zip.Reader"/>
		<files public="1"><t path="List"><t path="haxe.zip.Entry"/></t></files>
		<read public="1" set="method" line="233" override="1"><f a=""><t path="List"><t path="haxe.zip.Entry"/></t></f></read>
		<new public="1" set="method" line="230"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.ZipWriter" params="" file="source/funkin/backend/utils/ZipUtil.hx" module="funkin.backend.utils.ZipUtil">
		<extends path="haxe.zip.Writer"/>
		<flush public="1" set="method" line="245"><f a=""><x path="Void"/></f></flush>
		<writeFile public="1" set="method" line="249"><f a="entry">
	<t path="haxe.zip.Entry"/>
	<x path="Void"/>
</f></writeFile>
		<close public="1" set="method" line="254"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="244"><f a="o">
	<c path="haxe.io.Output"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.StrNameLabel" params="" file="source/funkin/backend/utils/ZipUtil.hx" module="funkin.backend.utils.ZipUtil">
		<name public="1"><c path="String"/></name>
		<label public="1"><c path="String"/></label>
		<new public="1" set="method" line="263"><f a="name:label">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.native.Stdin" params="" file="source/funkin/backend/utils/native/HiddenProcess.hx" module="funkin.backend.utils.native.HiddenProcess">
		<extends path="haxe.io.Output"/>
		<p><d/></p>
		<buf><c path="haxe.io.Bytes"/></buf>
		<close public="1" set="method" line="37" override="1"><f a=""><x path="Void"/></f></close>
		<writeByte public="1" set="method" line="42" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="47" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<new public="1" set="method" line="32"><f a="p">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.native.Stdout" params="" file="source/funkin/backend/utils/native/HiddenProcess.hx" module="funkin.backend.utils.native.HiddenProcess">
		<extends path="haxe.io.Input"/>
		<p><d/></p>
		<out><x path="Bool"/></out>
		<buf><c path="haxe.io.Bytes"/></buf>
		<readByte public="1" set="method" line="68" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="74" override="1"><f a="str:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="62"><f a="p:out">
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.native.HiddenProcess" params="" file="source/funkin/backend/utils/native/HiddenProcess.hx">
		<p><d/></p>
		<stdout public="1" set="null"><c path="haxe.io.Input"/></stdout>
		<stderr public="1" set="null"><c path="haxe.io.Input"/></stderr>
		<stdin public="1" set="null"><c path="haxe.io.Output"/></stdin>
		<getPid public="1" set="method" line="103"><f a=""><x path="Int"/></f></getPid>
		<exitCode public="1" set="method" line="107">
			<f a="?block" v="true">
				<x path="Bool"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta><m n=":value"><e>{ block : true }</e></m></meta>
		</exitCode>
		<close public="1" set="method" line="111"><f a=""><x path="Void"/></f></close>
		<kill public="1" set="method" line="115"><f a=""><x path="Void"/></f></kill>
		<new public="1" set="method" line="94"><f a="cmd:?args:?detached">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.native.Windows" params="" file="source/funkin/backend/utils/native/Windows.hx">
		<__audioChangeCallback public="1" expr="function() {  trace(&quot;test&quot;); }" line="119" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>function() {
	trace("test");
}</e></m></meta>
		</__audioChangeCallback>
		<registerAudio public="1" set="method" line="127" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"\r\n\tif (!curAudioFix) curAudioFix = new AudioFixClient();\r\n\t"</e></m></meta>
		</registerAudio>
		<setDarkMode public="1" set="method" line="142" static="1">
			<f a="title:enable">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\tint darkMode = enable ? 1 : 0;\r\n\r\n\t\tHWND window = FindWindowA(NULL, title.c_str());\r\n\t\t// Look for child windows if top level aint found\r\n\t\tif (window == NULL) window = FindWindowExA(GetActiveWindow(), NULL, NULL, title.c_str());\r\n\r\n\t\tif (window != NULL &amp;&amp; S_OK != DwmSetWindowAttribute(window, 19, &amp;darkMode, sizeof(darkMode))) {\r\n\t\t\tDwmSetWindowAttribute(window, 20, &amp;darkMode, sizeof(darkMode));\r\n\t\t}\r\n\t"</e></m></meta>
		</setDarkMode>
		<allocConsole public="1" set="method" line="154" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"\r\n\t// https://stackoverflow.com/questions/15543571/allocconsole-not-displaying-cout\r\n\r\n\tif (!AllocConsole())\r\n\t\treturn;\r\n\r\n\tfreopen(\"CONIN$\", \"r\", stdin);\r\n\tfreopen(\"CONOUT$\", \"w\", stdout);\r\n\tfreopen(\"CONOUT$\", \"w\", stderr);\r\n\t"</e></m></meta>
		</allocConsole>
		<getFileAttributes public="1" set="method" line="161" static="1">
			<f a="path">
				<c path="String"/>
				<x path="funkin.backend.utils.FileAttribute"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\treturn GetFileAttributes(path);\r\n\t"</e></m></meta>
		</getFileAttributes>
		<setFileAttributes public="1" set="method" line="169" static="1">
			<f a="path:attrib">
				<c path="String"/>
				<x path="funkin.backend.utils.FileAttribute"/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\treturn SetFileAttributes(path, attrib);\r\n\t"</e></m></meta>
		</setFileAttributes>
		<setConsoleColors public="1" set="method" line="178" static="1">
			<f a="color">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\tHANDLE console = GetStdHandle(STD_OUTPUT_HANDLE);\r\n\t\tSetConsoleTextAttribute(console, color);\r\n\t"</e></m></meta>
		</setConsoleColors>
		<clearScreen public="1" set="method" line="186" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"\r\n\t\tsystem(\"CLS\");\r\n\t\tstd::cout&lt;&lt; \"\" &lt;&lt;std::flush;\r\n\t"</e></m></meta>
		</clearScreen>
		<showMessageBox public="1" set="method" line="194" static="1">
			<f a="caption:message:?icon" v="::MSG_WARNING">
				<c path="String"/>
				<c path="String"/>
				<x path="funkin.backend.utils.MessageBoxIcon"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ icon : MSG_WARNING }</e></m>
				<m n=":functionCode"><e>"\r\n\t\tMessageBox(GetActiveWindow(), message, caption, icon | MB_SETFOREGROUND);\r\n\t"</e></m>
			</meta>
		</showMessageBox>
		<registerAsDPICompatible public="1" set="method" line="201" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"\r\n\t\tSetProcessDPIAware();\r\n\t"</e></m></meta>
		</registerAsDPICompatible>
		<getTotalRam public="1" set="method" line="210" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":functionCode"><e>"\r\n\t\t// simple but effective code\r\n\t\tunsigned long long allocatedRAM = 0;\r\n\t\tGetPhysicallyInstalledSystemMemory(&amp;allocatedRAM);\r\n\t\treturn (allocatedRAM / 1024);\r\n\t"</e></m></meta>
		</getTotalRam>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e>"\r\n&lt;target id=\"haxe\"&gt;\r\n\t&lt;lib name=\"dwmapi.lib\" if=\"windows\" /&gt;\r\n\t&lt;lib name=\"shell32.lib\" if=\"windows\" /&gt;\r\n\t&lt;lib name=\"gdi32.lib\" if=\"windows\" /&gt;\r\n\t&lt;lib name=\"ole32.lib\" if=\"windows\" /&gt;\r\n\t&lt;lib name=\"uxtheme.lib\" if=\"windows\" /&gt;\r\n&lt;/target&gt;\r\n"</e></m>
			<m n=":cppFileCode"><e>"\r\n#include \"mmdeviceapi.h\"\r\n#include \"combaseapi.h\"\r\n#include &lt;iostream&gt;\r\n#include &lt;Windows.h&gt;\r\n#include &lt;cstdio&gt;\r\n#include &lt;tchar.h&gt;\r\n#include &lt;dwmapi.h&gt;\r\n#include &lt;winuser.h&gt;\r\n#include &lt;Shlobj.h&gt;\r\n#include &lt;wingdi.h&gt;\r\n#include &lt;shellapi.h&gt;\r\n#include &lt;uxtheme.h&gt;\r\n\r\n#define SAFE_RELEASE(punk)  \\\r\n\t\t\t  if ((punk) != NULL)  \\\r\n\t\t\t\t{ (punk)-&gt;Release(); (punk) = NULL; }\r\n\r\nstatic long lastDefId = 0;\r\n\r\nclass AudioFixClient : public IMMNotificationClient {\r\n\tLONG _cRef;\r\n\tIMMDeviceEnumerator *_pEnumerator;\r\n\r\n\tpublic:\r\n\tAudioFixClient() :\r\n\t\t_cRef(1),\r\n\t\t_pEnumerator(NULL)\r\n\t{\r\n\t\tHRESULT result = CoCreateInstance(__uuidof(MMDeviceEnumerator),\r\n\t\t\t\t\t\t\t  NULL, CLSCTX_INPROC_SERVER,\r\n\t\t\t\t\t\t\t  __uuidof(IMMDeviceEnumerator),\r\n\t\t\t\t\t\t\t  (void**)&amp;_pEnumerator);\r\n\t\tif (result == S_OK) {\r\n\t\t\t_pEnumerator-&gt;RegisterEndpointNotificationCallback(this);\r\n\t\t}\r\n\t}\r\n\r\n\t~AudioFixClient()\r\n\t{\r\n\t\tSAFE_RELEASE(_pEnumerator);\r\n\t}\r\n\r\n\tULONG STDMETHODCALLTYPE AddRef()\r\n\t{\r\n\t\treturn InterlockedIncrement(&amp;_cRef);\r\n\t}\r\n\r\n\tULONG STDMETHODCALLTYPE Release()\r\n\t{\r\n\t\tULONG ulRef = InterlockedDecrement(&amp;_cRef);\r\n\t\tif (0 == ulRef)\r\n\t\t{\r\n\t\t\tdelete this;\r\n\t\t}\r\n\t\treturn ulRef;\r\n\t}\r\n\r\n\tHRESULT STDMETHODCALLTYPE QueryInterface(\r\n\t\t\t\t\t\t\t\tREFIID riid, VOID **ppvInterface)\r\n\t{\r\n\t\treturn S_OK;\r\n\t}\r\n\r\n\tHRESULT STDMETHODCALLTYPE OnDeviceAdded(LPCWSTR pwstrDeviceId)\r\n\t{\r\n\t\treturn S_OK;\r\n\t};\r\n\r\n\tHRESULT STDMETHODCALLTYPE OnDeviceRemoved(LPCWSTR pwstrDeviceId)\r\n\t{\r\n\t\treturn S_OK;\r\n\t}\r\n\r\n\tHRESULT STDMETHODCALLTYPE OnDeviceStateChanged(\r\n\t\t\t\t\t\t\t\tLPCWSTR pwstrDeviceId,\r\n\t\t\t\t\t\t\t\tDWORD dwNewState)\r\n\t{\r\n\t\treturn S_OK;\r\n\t}\r\n\r\n\tHRESULT STDMETHODCALLTYPE OnPropertyValueChanged(\r\n\t\t\t\t\t\t\t\tLPCWSTR pwstrDeviceId,\r\n\t\t\t\t\t\t\t\tconst PROPERTYKEY key)\r\n\t{\r\n\t\treturn S_OK;\r\n\t}\r\n\r\n\tHRESULT STDMETHODCALLTYPE OnDefaultDeviceChanged(\r\n\t\tEDataFlow flow, ERole role,\r\n\t\tLPCWSTR pwstrDeviceId)\r\n\t{\r\n\t\t::funkin::backend::_hx_system::Main_obj::audioDisconnected = true;\r\n\t\treturn S_OK;\r\n\t};\r\n};\r\n\r\nAudioFixClient *curAudioFix;\r\n"</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="funkin.editors.ui.UIState" params="" file="source/funkin/editors/ui/UIState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<state public="1" get="accessor" set="null" static="1"><c path="funkin.editors.ui.UIState"/></state>
		<get_state get="inline" set="null" line="28" static="1"><f a=""><x path="Null"><c path="funkin.editors.ui.UIState"/></x></f></get_state>
		<curContextMenu public="1" expr="null">
			<c path="funkin.editors.ui.UIContextMenu"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curContextMenu>
		<buttonHandler public="1" expr="null">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</buttonHandler>
		<hoveredSprite public="1" expr="null">
			<c path="funkin.editors.ui.UISprite"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</hoveredSprite>
		<currentFocus public="1" expr="null">
			<c path="funkin.editors.ui.IUIFocusable"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</currentFocus>
		<currentCursor public="1" expr="ARROW">
			<x path="openfl.ui.MouseCursor"/>
			<meta><m n=":value"><e>ARROW</e></m></meta>
		</currentCursor>
		<__rect><c path="flixel.math.FlxRect"/></__rect>
		<__mousePos><x path="flixel.math.FlxPoint"/></__mousePos>
		<create public="1" set="method" line="30" override="1"><f a=""><x path="Void"/></f></create>
		<onKeyDown set="method" line="43"><f a="e:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyDown>
		<onKeyUp set="method" line="48"><f a="e:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyUp>
		<onTextInput set="method" line="53"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></onTextInput>
		<onTextEdit set="method" line="57"><f a="str:start:end">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onTextEdit>
		<updateSpriteRect public="1" get="inline" set="null" line="62"><f a="spr">
	<c path="funkin.editors.ui.UISprite"/>
	<x path="Void"/>
</f></updateSpriteRect>
		<updateButtonHandler public="1" set="method" line="69"><f a="spr:buttonHandler">
	<c path="funkin.editors.ui.UISprite"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></updateButtonHandler>
		<isOverlapping public="1" set="method" line="77"><f a="spr:rect">
	<c path="funkin.editors.ui.UISprite"/>
	<c path="flixel.math.FlxRect"/>
	<x path="Bool"/>
</f></isOverlapping>
		<updateRectButtonHandler public="1" set="method" line="97"><f a="spr:rect:buttonHandler">
	<c path="funkin.editors.ui.UISprite"/>
	<c path="flixel.math.FlxRect"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></updateRectButtonHandler>
		<tryUpdate public="1" set="method" line="105" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></tryUpdate>
		<destroy public="1" set="method" line="128" override="1"><f a=""><x path="Void"/></f></destroy>
		<closeCurrentContextMenu public="1" set="method" line="141"><f a=""><x path="Void"/></f></closeCurrentContextMenu>
		<openContextMenu public="1" set="method" line="148"><f a="options:?callback:?x:?y">
	<c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c>
	<x path="Null"><t path="funkin.editors.ui.UIContextMenuCallback"/></x>
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.editors.ui.UIContextMenu"/>
</f></openContextMenu>
		<new public="1" set="method" line="13"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.TreeMenu" params="" file="source/funkin/options/TreeMenu.hx">
		<extends path="funkin.editors.ui.UIState"/>
		<lastState public="1" expr="null" line="19" static="1">
			<x path="Class"><c path="flixel.FlxState"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastState>
		<menuTransitionEase public="1" get="inline" set="null" line="109" static="1"><f a="e">
	<x path="Float"/>
	<x path="Float"/>
</f></menuTransitionEase>
		<main public="1"><c path="funkin.options.OptionsScreen"/></main>
		<optionsTree public="1"><c path="funkin.options.OptionsTree"/></optionsTree>
		<pathLabel public="1"><c path="funkin.backend.FunkinText"/></pathLabel>
		<pathDesc public="1"><c path="funkin.backend.FunkinText"/></pathDesc>
		<pathBG public="1"><c path="flixel.FlxSprite"/></pathBG>
		<createPost public="1" set="method" line="26" override="1"><f a=""><x path="Void"/></f></createPost>
		<onMenuChange public="1" set="method" line="60"><f a=""><x path="Void"/></f></onMenuChange>
		<updateDesc public="1" set="method" line="82">
			<f a="?moreTxt" v="&quot;&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ moreTxt : "" }</e></m></meta>
		</updateDesc>
		<exit public="1" set="method" line="89"><f a=""><x path="Void"/></f></exit>
		<onMenuClose public="1" set="method" line="94"><f a="m">
	<c path="funkin.options.OptionsScreen"/>
	<x path="Void"/>
</f></onMenuClose>
		<menuChangeTween><c path="flixel.tweens.FlxTween"/></menuChangeTween>
		<update public="1" set="method" line="99" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="funkin.editors.DebugOptions" params="" file="source/funkin/editors/DebugOptions.hx">
		<extends path="funkin.options.TreeMenu"/>
		<create public="1" set="method" line="9" override="1"><f a=""><x path="Void"/></f></create>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.OptionsScreen" params="" file="source/funkin/options/OptionsScreen.hx">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="funkin.options.type.OptionType"/></extends>
		<optionHeight public="1" expr="120" line="6" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</optionHeight>
		<parent public="1"><c path="funkin.options.OptionsTree"/></parent>
		<curSelected public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSelected>
		<id public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</id>
		<__firstFrame expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__firstFrame>
		<name public="1"><c path="String"/></name>
		<desc public="1"><c path="String"/></desc>
		<update public="1" set="method" line="25" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<close public="1" set="method" line="59"><f a=""><x path="Void"/></f></close>
		<changeSelection public="1" set="method" line="63">
			<f a="sel:?force" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</changeSelection>
		<updateMenuDesc public="1" set="method" line="72"><f a="?customTxt">
	<c path="String"/>
	<x path="Void"/>
</f></updateMenuDesc>
		<onClose public="1" set="dynamic" line="77"><f a="o">
	<c path="funkin.options.OptionsScreen"/>
	<x path="Void"/>
</f></onClose>
		<new public="1" set="method" line="18"><f a="name:desc:?options">
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><c path="funkin.options.type.OptionType"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.DebugOptionsScreen" params="" file="source/funkin/editors/DebugOptions.hx" module="funkin.editors.DebugOptions">
		<extends path="funkin.options.OptionsScreen"/>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.EditorPicker" params="" file="source/funkin/editors/EditorPicker.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<bg public="1"><c path="flixel.FlxSprite"/></bg>
		<options public="1" expr="[{ name : &quot;Chart Editor&quot;, iconID : 0, state : funkin.editors.charter.CharterSelection }, { name : &quot;Character Editor&quot;, iconID : 1, state : funkin.editors.character.CharacterSelection }, { name : &quot;Stage Editor&quot;, iconID : 2, state : null }, { name : &quot;UI Debug State&quot;, iconID : 3, state : UIDebugState }, { name : &quot;Debug Options&quot;, iconID : 4, state : DebugOptions }]">
			<c path="Array"><t path="funkin.editors.Editor"/></c>
			<meta><m n=":value"><e>[{ name : "Chart Editor", iconID : 0, state : funkin.editors.charter.CharterSelection }, { name : "Character Editor", iconID : 1, state : funkin.editors.character.CharacterSelection }, { name : "Stage Editor", iconID : 2, state : null }, { name : "UI Debug State", iconID : 3, state : UIDebugState }, { name : "Debug Options", iconID : 4, state : DebugOptions }]</e></m></meta>
		</options>
		<sprites public="1" expr="[]">
			<c path="Array"><c path="funkin.editors.EditorPickerOption"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</sprites>
		<curSelected public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSelected>
		<subCam public="1"><c path="flixel.FlxCamera"/></subCam>
		<oldMousePos public="1" expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</oldMousePos>
		<curMousePos public="1" expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</curMousePos>
		<optionHeight public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</optionHeight>
		<selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selected>
		<camVelocity public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</camVelocity>
		<create public="1" set="method" line="51" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="77" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="123" override="1"><f a=""><x path="Void"/></f></destroy>
		<changeSelection public="1" set="method" line="133"><f a="change">
	<x path="Int"/>
	<x path="Void"/>
</f></changeSelection>
		<new public="1" set="method" line="6"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.Editor" params="" file="source/funkin/editors/EditorPicker.hx" module="funkin.editors.EditorPicker"><a>
	<state><x path="Class"><c path="funkin.backend.MusicBeatState"/></x></state>
	<name><c path="String"/></name>
	<iconID><x path="Int"/></iconID>
</a></typedef>
	<class path="funkin.editors.EditorPickerOption" params="" file="source/funkin/editors/EditorPicker.hx" module="funkin.editors.EditorPicker">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<iconSpr public="1"><c path="flixel.FlxSprite"/></iconSpr>
		<label public="1"><c path="funkin.menus.ui.Alphabet"/></label>
		<selectionBG public="1"><c path="flixel.FlxSprite"/></selectionBG>
		<selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selected>
		<selectionLerp public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</selectionLerp>
		<iconRotationCycle public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</iconRotationCycle>
		<update public="1" set="method" line="191" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="208" override="1"><f a=""><x path="Void"/></f></destroy>
		<flicker public="1" set="method" line="212"><f a="callback">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></flicker>
		<new public="1" set="method" line="161"><f a="name:iconID:height">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.EditorTreeMenu" params="" file="source/funkin/editors/EditorTreeMenu.hx">
		<extends path="funkin.options.TreeMenu"/>
		<bg public="1"><c path="flixel.addons.display.FlxBackdrop"/></bg>
		<bgType public="1" expr="&quot;default&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"default"</e></m></meta>
		</bgType>
		<create public="1" set="method" line="11" override="1"><f a=""><x path="Void"/></f></create>
		<exit public="1" set="method" line="22" override="1"><f a=""><x path="Void"/></f></exit>
		<update public="1" set="method" line="26" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="funkin.editors.SaveSubstate" params="" file="source/funkin/editors/SaveSubstate.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<saveOptions public="1"><t path="Map">
	<c path="String"/>
	<x path="Bool"/>
</t></saveOptions>
		<options public="1"><t path="funkin.editors.SaveSubstateData"/></options>
		<data public="1"><c path="String"/></data>
		<cam public="1"><c path="flixel.FlxCamera"/></cam>
		<create public="1" set="method" line="26" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="38" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="14"><f a="data:?options:?saveOptions">
	<c path="String"/>
	<x path="Null"><t path="funkin.editors.SaveSubstateData"/></x>
	<t path="Map">
		<c path="String"/>
		<x path="Bool"/>
	</t>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.SaveSubstateData" params="" file="source/funkin/editors/SaveSubstate.hx" module="funkin.editors.SaveSubstate"><a>
	<saveExt>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</saveExt>
	<defaultSaveFile>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</defaultSaveFile>
</a></typedef>
	<class path="funkin.editors.SaveWarning" params="" file="source/funkin/editors/SaveWarning.hx">
		<showWarning public="1" set="accessor" static="1"><x path="Bool"/></showWarning>
		<set_showWarning public="1" set="method" line="6" static="1"><f a="warning">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_showWarning>
		<selectionClass public="1" expr="null" line="8" static="1">
			<x path="Class"><c path="funkin.editors.EditorTreeMenu"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</selectionClass>
		<saveFunc public="1" expr="null" line="9" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</saveFunc>
		<init public="1" set="method" line="11" static="1"><f a=""><x path="Void"/></f></init>
		<warningFunc public="1" expr="null" line="19" static="1">
			<f a="">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</warningFunc>
		<triggerWarning public="1" set="method" line="20" static="1">
			<f a="?closingWindow" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ closingWindow : false }</e></m></meta>
		</triggerWarning>
		<reset public="1" get="inline" set="null" line="62" static="1"><f a=""><x path="Void"/></f></reset>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.UIDebugState" params="" file="source/funkin/editors/UIDebugState.hx">
		<extends path="funkin.editors.ui.UIState"/>
		<create public="1" set="method" line="7" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="111" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="6"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.UndoList" params="T" file="source/funkin/editors/UndoList.hx">
		<undoList public="1" expr="[]">
			<c path="Array"><c path="funkin.editors.UndoList.T"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</undoList>
		<redoList public="1" expr="[]">
			<c path="Array"><c path="funkin.editors.UndoList.T"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</redoList>
		<savedLength expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</savedLength>
		<unsaved public="1" get="accessor" set="null"><x path="Bool"/></unsaved>
		<get_unsaved public="1" get="inline" set="null" line="11"><f a=""><x path="Bool"/></f></get_unsaved>
		<addToUndo public="1" get="inline" set="null" line="15"><f a="c">
	<c path="funkin.editors.UndoList.T"/>
	<x path="Void"/>
</f></addToUndo>
		<undo public="1" get="inline" set="null" line="22"><f a=""><c path="funkin.editors.UndoList.T"/></f></undo>
		<redo public="1" get="inline" set="null" line="29"><f a=""><c path="funkin.editors.UndoList.T"/></f></redo>
		<save public="1" get="inline" set="null" line="37"><f a=""><x path="Void"/></f></save>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UISprite" params="" file="source/funkin/editors/ui/UISprite.hx">
		<extends path="flixel.FlxSprite"/>
		<members public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxBasic"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</members>
		<__lastDrawCameras expr="[]">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__lastDrawCameras>
		<__rect expr="new FlxRect()">
			<c path="flixel.math.FlxRect"/>
			<meta><m n=":value"><e>new FlxRect()</e></m></meta>
		</__rect>
		<__oldDefCams><c path="Array"><c path="flixel.FlxCamera"/></c></__oldDefCams>
		<hovered public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hovered>
		<hoveredByChild public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hoveredByChild>
		<pressed public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pressed>
		<canBeHovered public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</canBeHovered>
		<hoverCallback public="1" expr="null">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</hoverCallback>
		<cursor public="1" expr="ARROW">
			<x path="openfl.ui.MouseCursor"/>
			<meta><m n=":value"><e>ARROW</e></m></meta>
		</cursor>
		<focused public="1" get="accessor" set="accessor"><x path="Bool"/></focused>
		<selectable public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</selectable>
		<autoAlpha public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoAlpha>
		<get_focused get="inline" set="null" line="31"><f a=""><x path="Bool"/></f></get_focused>
		<set_focused get="inline" set="null" line="33"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_focused>
		<update public="1" set="method" line="44" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="65" override="1"><f a=""><x path="Void"/></f></draw>
		<drawSuper public="1" set="method" line="70"><f a=""><x path="Void"/></f></drawSuper>
		<drawMembers public="1" set="method" line="75"><f a=""><x path="Void"/></f></drawMembers>
		<destroy public="1" set="method" line="88" override="1"><f a=""><x path="Void"/></f></destroy>
		<updateButton public="1" set="method" line="93"><f a=""><x path="Void"/></f></updateButton>
		<updateButtonHandler public="1" set="method" line="103"><f a=""><x path="Void"/></f></updateButtonHandler>
		<onHovered public="1" set="method" line="110">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called whenever the sprite is being hovered by the mouse.</haxe_doc>
		</onHovered>
		<new public="1" set="method" line="8"><f a="?X:?Y:?SimpleGraphic">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Null"><t path="flixel.system.FlxGraphicAsset"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.editors.ui.UIState</e></m>
			<m n=":allow"><e>funkin.editors.ui.UIUtil</e></m>
		</meta>
	</class>
	<class path="funkin.editors.ui.UISliceSprite" params="" file="source/funkin/editors/ui/UISliceSprite.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<bWidth public="1" expr="120">
			<x path="Int"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</bWidth>
		<bHeight public="1" expr="20">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</bHeight>
		<framesOffset public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</framesOffset>
		<incorporeal public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</incorporeal>
		<updateButton public="1" set="method" line="19" override="1"><f a=""><x path="Void"/></f></updateButton>
		<resize public="1" set="method" line="28"><f a="w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<drawTop public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</drawTop>
		<drawMiddle public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</drawMiddle>
		<drawBottom public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</drawBottom>
		<draw public="1" set="method" line="37" override="1"><f a=""><x path="Void"/></f></draw>
		<__setSize set="method" line="144"><f a="Width:Height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__setSize>
		<new public="1" set="method" line="12"><f a="x:y:w:h:path">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIButton" params="" file="source/funkin/editors/ui/UIButton.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<callback public="1" expr="null">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</callback>
		<field public="1"><c path="funkin.editors.ui.UIText"/></field>
		<shouldPress public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</shouldPress>
		<hasBeenPressed public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasBeenPressed>
		<resize public="1" set="method" line="19" override="1"><f a="w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<onHovered public="1" set="method" line="24" override="1"><f a=""><x path="Void"/></f></onHovered>
		<update public="1" set="method" line="33" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="40" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="9">
			<f a="x:y:text:callback:?w:?h" v="::::120:32">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : 32, w : 120 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.character.CharacterAnimButtons" params="" file="source/funkin/editors/character/CharacterAnimButtons.hx">
		<extends path="funkin.editors.ui.UIButton"/>
		<anim public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</anim>
		<editButton public="1"><c path="funkin.editors.ui.UIButton"/></editButton>
		<editIcon public="1"><c path="flixel.FlxSprite"/></editIcon>
		<ghostButton public="1"><c path="funkin.editors.ui.UIButton"/></ghostButton>
		<ghostIcon public="1"><c path="flixel.FlxSprite"/></ghostIcon>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<update public="1" set="method" line="63" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updateInfo public="1" set="method" line="72"><f a="anim:offset:ghost">
	<c path="String"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></updateInfo>
		<updatePos public="1" get="inline" set="null" line="80"><f a=""><x path="Void"/></f></updatePos>
		<new public="1" set="method" line="18"><f a="x:y:anim:offset">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UISubstateWindow" params="" file="source/funkin/editors/ui/UISubstateWindow.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<camShaders expr="[]">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</camShaders>
		<blurShader expr="new CustomShader(Options.intensiveBlur ? &quot;engine/editorBlur&quot; : &quot;engine/editorBlurFast&quot;)">
			<c path="funkin.backend.shaders.CustomShader"/>
			<meta><m n=":value"><e>new CustomShader(Options.intensiveBlur ? "engine/editorBlur" : "engine/editorBlurFast")</e></m></meta>
		</blurShader>
		<titleSpr><c path="funkin.editors.ui.UIText"/></titleSpr>
		<messageSpr><c path="funkin.editors.ui.UIText"/></messageSpr>
		<subCam><c path="flixel.FlxCamera"/></subCam>
		<windowSpr><c path="funkin.editors.ui.UISliceSprite"/></windowSpr>
		<onSubstateOpen public="1" set="method" line="19" override="1"><f a=""><x path="Void"/></f></onSubstateOpen>
		<winWidth expr="560">
			<x path="Int"/>
			<meta><m n=":value"><e>560</e></m></meta>
		</winWidth>
		<winHeight expr="570">
			<x path="Int"/>
			<meta><m n=":value"><e>570</e></m></meta>
		</winHeight>
		<winTitle expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</winTitle>
		<create public="1" set="method" line="29" override="1"><f a=""><x path="Void"/></f></create>
		<destroy public="1" set="method" line="72" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="82" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="8"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="funkin.editors.character.CharacterAnimScreen" params="" file="source/funkin/editors/character/CharacterAnimScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<animData public="1"><t path="funkin.backend.utils.AnimData"/></animData>
		<nameTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></nameTextBox>
		<animTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></animTextBox>
		<fpsStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></fpsStepper>
		<loopedCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></loopedCheckbox>
		<indicesTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></indicesTextBox>
		<offsetXStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></offsetXStepper>
		<offsetYStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></offsetYStepper>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<onSave public="1" expr="null">
			<f a="animData">
				<t path="funkin.backend.utils.AnimData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onSave>
		<create public="1" set="method" line="29" override="1"><f a=""><x path="Void"/></f></create>
		<saveAnimData public="1" set="method" line="100"><f a=""><x path="Void"/></f></saveAnimData>
		<new public="1" set="method" line="23"><f a="animData:?onSave">
	<t path="funkin.backend.utils.AnimData"/>
	<f a="animData">
		<t path="funkin.backend.utils.AnimData"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.character.CharacterEditor" params="" file="source/funkin/editors/character/CharacterEditor.hx">
		<extends path="funkin.editors.ui.UIState"/>
		<__character static="1"><c path="String"/></__character>
		<instance public="1" get="accessor" set="null" static="1"><c path="funkin.editors.character.CharacterEditor"/></instance>
		<get_instance get="inline" set="null" line="20" static="1"><f a=""><x path="Null"><c path="funkin.editors.character.CharacterEditor"/></x></f></get_instance>
		<character public="1"><c path="funkin.game.Character"/></character>
		<ghosts public="1"><c path="funkin.editors.character.CharacterGhostsHandler"/></ghosts>
		<characterBG public="1">
			<c path="funkin.backend.FunkinSprite"/>
			<haxe_doc>* CHARACTER UI STUFF</haxe_doc>
		</characterBG>
		<topMenu public="1"><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></topMenu>
		<topMenuSpr public="1"><c path="funkin.editors.ui.UITopMenu"/></topMenuSpr>
		<uiGroup public="1" expr="new FlxTypedGroup&lt;FlxSprite&gt;()">
			<c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxSprite"/></c>
			<meta><m n=":value"><e>new FlxTypedGroup&lt;FlxSprite&gt;()</e></m></meta>
		</uiGroup>
		<characterPropertiresWindow public="1"><c path="funkin.editors.character.CharacterPropertiesWindow"/></characterPropertiresWindow>
		<characterAnimsWindow public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.character.CharacterAnimButtons"/></c></characterAnimsWindow>
		<charCamera public="1"><c path="flixel.FlxCamera"/></charCamera>
		<animsCamera public="1"><c path="flixel.FlxCamera"/></animsCamera>
		<uiCamera public="1"><c path="flixel.FlxCamera"/></uiCamera>
		<undos public="1" expr="new UndoList&lt;CharacterChange&gt;()">
			<c path="funkin.editors.UndoList"><e path="funkin.editors.character.CharacterChange"/></c>
			<meta><m n=":value"><e>new UndoList&lt;CharacterChange&gt;()</e></m></meta>
		</undos>
		<create public="1" set="method" line="49" override="1"><f a=""><x path="Void"/></f></create>
		<destroy public="1" set="method" line="264" override="1"><f a=""><x path="Void"/></f></destroy>
		<nextScroll expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</nextScroll>
		<update public="1" set="method" line="278" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<_file_exit set="method" line="323"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_exit>
		<_file_new set="method" line="328"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_new>
		<_file_save set="method" line="331"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_save>
		<_file_saveas set="method" line="343"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_saveas>
		<buildCharacter set="method" line="350"><f a=""><c path="String"/></f></buildCharacter>
		<_edit_undo set="method" line="368"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_undo>
		<_edit_redo set="method" line="396"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_redo>
		<_char_add_anim set="method" line="416"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_char_add_anim>
		<_char_edit_anim set="method" line="420"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_char_edit_anim>
		<_char_remove_anim set="method" line="424"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_char_remove_anim>
		<_char_edit_info set="method" line="428"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_char_edit_info>
		<createAnimWithUI public="1" set="method" line="432"><f a=""><x path="Void"/></f></createAnimWithUI>
		<editAnimWithUI public="1" set="method" line="438"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></editAnimWithUI>
		<createAnim public="1" set="method" line="444">
			<f a="animData:?animID:?addtoUndo" v=":-1:true">
				<t path="funkin.backend.utils.AnimData"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addtoUndo : true, animID : -1 }</e></m></meta>
		</createAnim>
		<editAnim public="1" set="method" line="457">
			<f a="name:animData:?addtoUndo" v="::true">
				<c path="String"/>
				<t path="funkin.backend.utils.AnimData"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addtoUndo : true }</e></m></meta>
		</editAnim>
		<deleteAnim public="1" set="method" line="475">
			<f a="name:?addtoUndo" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addtoUndo : true }</e></m></meta>
		</deleteAnim>
		<editInfoWithUI public="1" set="method" line="502"><f a=""><x path="Void"/></f></editInfoWithUI>
		<editInfo public="1" set="method" line="508">
			<f a="newInfo:?addtoUndo" v=":true">
				<c path="Xml"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addtoUndo : true }</e></m></meta>
		</editInfo>
		<ghostAnim public="1" set="method" line="521"><f a="anim">
	<c path="String"/>
	<x path="Void"/>
</f></ghostAnim>
		<_playback_play_anim set="method" line="531"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_play_anim>
		<_playback_stop_anim set="method" line="536"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_stop_anim>
		<playAnimation public="1" set="method" line="541"><f a="anim">
	<c path="String"/>
	<x path="Void"/>
</f></playAnimation>
		<_offsets_left set="method" line="548"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_left>
		<_offsets_up set="method" line="552"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_up>
		<_offsets_down set="method" line="556"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_down>
		<_offsets_right set="method" line="560"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_right>
		<_offsets_extra_left set="method" line="564"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_extra_left>
		<_offsets_extra_up set="method" line="568"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_extra_up>
		<_offsets_extra_down set="method" line="572"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_extra_down>
		<_offsets_extra_right set="method" line="576"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_extra_right>
		<_offsets_clear set="method" line="580"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_clear>
		<changeOffset set="method" line="584">
			<f a="anim:change:?addtoUndo" v="::true">
				<c path="String"/>
				<x path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addtoUndo : true }</e></m></meta>
		</changeOffset>
		<clearOffsets set="method" line="605">
			<f a="?addtoUndo" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addtoUndo : true }</e></m></meta>
		</clearOffsets>
		<zoom set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</zoom>
		<__camZoom set="accessor" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</__camZoom>
		<set_zoom set="method" line="628"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_zoom>
		<set___camZoom set="method" line="631"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set___camZoom>
		<_view_zoomin set="method" line="635"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomin>
		<_view_zoomout set="method" line="639"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomout>
		<_view_zoomreset set="method" line="643"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomreset>
		<new public="1" set="method" line="44"><f a="character">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="funkin.editors.character.CharacterChange" params="" file="source/funkin/editors/character/CharacterEditor.hx" module="funkin.editors.character.CharacterEditor">
		<CEditInfo a="oldInfo:newInfo">
			<c path="Xml"/>
			<c path="Xml"/>
		</CEditInfo>
		<CCreateAnim a="animID:animData">
			<x path="Int"/>
			<t path="funkin.backend.utils.AnimData"/>
		</CCreateAnim>
		<CEditAnim a="name:oldData:animData">
			<c path="String"/>
			<t path="funkin.backend.utils.AnimData"/>
			<t path="funkin.backend.utils.AnimData"/>
		</CEditAnim>
		<CDeleteAnim a="animID:animData">
			<x path="Int"/>
			<t path="funkin.backend.utils.AnimData"/>
		</CDeleteAnim>
		<CChangeOffset a="name:change">
			<c path="String"/>
			<x path="flixel.math.FlxPoint"/>
		</CChangeOffset>
		<CResetOffsets a="oldOffsets"><t path="Map">
	<c path="String"/>
	<x path="flixel.math.FlxPoint"/>
</t></CResetOffsets>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="funkin.editors.character.CharacterGhostsHandler" params="" file="source/funkin/editors/character/CharacterGhostsHandler.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.game.Character"/></extends>
		<character public="1"><c path="funkin.game.Character"/></character>
		<animGhosts public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.game.Character"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</animGhosts>
		<createGhost public="1" set="method" line="19"><f a="anim">
	<c path="String"/>
	<x path="Void"/>
</f></createGhost>
		<removeGhost public="1" set="method" line="31"><f a="anim">
	<c path="String"/>
	<x path="Void"/>
</f></removeGhost>
		<updateInfos public="1" set="method" line="40"><f a="xml">
	<c path="Xml"/>
	<x path="Void"/>
</f></updateInfos>
		<updateOffsets public="1" set="method" line="50"><f a="name:change">
	<c path="String"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></updateOffsets>
		<setOffsets public="1" set="method" line="57"><f a="name:offset">
	<c path="String"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></setOffsets>
		<clearOffsets public="1" set="method" line="64"><f a=""><x path="Void"/></f></clearOffsets>
		<rePositionGhosts get="inline" set="null" line="71"><f a=""><x path="Void"/></f></rePositionGhosts>
		<new public="1" set="method" line="11"><f a="character">
	<c path="funkin.game.Character"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.character.CharacterInfoScreen" params="" file="source/funkin/editors/character/CharacterInfoScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<character public="1"><c path="funkin.game.Character"/></character>
		<spriteTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></spriteTextBox>
		<iconTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></iconTextBox>
		<iconSprite public="1"><c path="flixel.FlxSprite"/></iconSprite>
		<gameOverCharTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></gameOverCharTextBox>
		<antialiasingCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></antialiasingCheckbox>
		<flipXCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></flipXCheckbox>
		<iconColorWheel public="1"><c path="funkin.editors.ui.UIColorwheel"/></iconColorWheel>
		<positionXStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></positionXStepper>
		<positionYStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></positionYStepper>
		<cameraXStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></cameraXStepper>
		<cameraYStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></cameraYStepper>
		<scaleStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></scaleStepper>
		<singTimeStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></singTimeStepper>
		<customPropertiesButtonList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.extra.PropertyButton"/></c></customPropertiesButtonList>
		<isPlayerCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></isPlayerCheckbox>
		<isGFCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></isGFCheckbox>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<onSave public="1" expr="null">
			<f a="xml">
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onSave>
		<create public="1" set="method" line="39" override="1"><f a=""><x path="Void"/></f></create>
		<updateIcon set="method" line="146"><f a="icon">
	<c path="String"/>
	<x path="Void"/>
</f></updateIcon>
		<saveCharacterInfo set="method" line="165"><f a=""><x path="Void"/></f></saveCharacterInfo>
		<new public="1" set="method" line="33"><f a="character:?onSave">
	<c path="funkin.game.Character"/>
	<f a="xml">
		<c path="Xml"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIWindow" params="" file="source/funkin/editors/ui/UIWindow.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<titleSpr public="1"><c path="funkin.editors.ui.UIText"/></titleSpr>
		<update public="1" set="method" line="13" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="6"><f a="x:y:w:h:title">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.character.CharacterPropertiesWindow" params="" file="source/funkin/editors/character/CharacterPropertiesWindow.hx">
		<extends path="funkin.editors.ui.UIWindow"/>
		<newButton public="1"><c path="funkin.editors.ui.UIButton"/></newButton>
		<editButton public="1"><c path="funkin.editors.ui.UIButton"/></editButton>
		<characterInfo public="1"><c path="funkin.editors.ui.UIText"/></characterInfo>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.character.CharacterSelection" params="" file="source/funkin/editors/character/CharacterSelection.hx">
		<extends path="funkin.editors.EditorTreeMenu"/>
		<create public="1" set="method" line="15" override="1"><f a=""><x path="Void"/></f></create>
		<createPost public="1" set="method" line="40" override="1"><f a=""><x path="Void"/></f></createPost>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.ChartCreationScreen" params="" file="source/funkin/editors/charter/ChartCreationScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<onSave expr="null">
			<f a=":">
				<c path="String"/>
				<t path="funkin.backend.chart.ChartData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onSave>
		<charFileList public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</charFileList>
		<difficultyNameTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></difficultyNameTextBox>
		<scrollSpeedTextBox public="1"><c path="funkin.editors.ui.UINumericStepper"/></scrollSpeedTextBox>
		<stageTextBox public="1"><c path="funkin.editors.ui.UIAutoCompleteTextBox"/></stageTextBox>
		<strumLineList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.StrumLineButton"/></c></strumLineList>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<create public="1" set="method" line="29" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="137" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<createChart public="1" set="method" line="143"><f a=""><x path="Void"/></f></createChart>
		<new public="1" set="method" line="24"><f a="?onSave">
	<f a=":">
		<c path="String"/>
		<t path="funkin.backend.chart.ChartData"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.StrumLineButton" params="" file="source/funkin/editors/charter/ChartCreationScreen.hx" module="funkin.editors.charter.ChartCreationScreen">
		<extends path="funkin.editors.ui.UIButton"/>
		<idText public="1"><c path="funkin.editors.ui.UIText"/></idText>
		<charactersList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.CompactCharacterButton"/></c></charactersList>
		<typeDropdown public="1"><c path="funkin.editors.ui.UIDropDown"/></typeDropdown>
		<stagePositionDropdown public="1"><c path="funkin.editors.ui.UIDropDown"/></stagePositionDropdown>
		<hudScaleStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></hudScaleStepper>
		<hudXStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></hudXStepper>
		<hudYStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></hudYStepper>
		<visibleCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></visibleCheckbox>
		<scrollSpeedStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></scrollSpeedStepper>
		<usesChartscrollSpeed public="1"><c path="funkin.editors.ui.UICheckbox"/></usesChartscrollSpeed>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<labels public="1" expr="[]">
			<t path="Map">
				<c path="funkin.editors.ui.UISprite"/>
				<c path="funkin.editors.ui.UIText"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</labels>
		<XYComma public="1"><c path="funkin.editors.ui.UIText"/></XYComma>
		<cameraClipShader public="1"><c path="funkin.backend.shaders.CustomShader"/></cameraClipShader>
		<update public="1" set="method" line="286" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="199"><f a="id:strumLine:parent">
	<x path="Int"/>
	<t path="funkin.backend.chart.ChartStrumLine"/>
	<c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.StrumLineButton"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CompactCharacterButton" params="" file="source/funkin/editors/charter/ChartCreationScreen.hx" module="funkin.editors.charter.ChartCreationScreen">
		<extends path="funkin.editors.ui.UIButton"/>
		<charIcon public="1"><c path="funkin.game.HealthIcon"/></charIcon>
		<textBox public="1"><c path="funkin.editors.ui.UIAutoCompleteTextBox"/></textBox>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<update public="1" set="method" line="354" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="318"><f a="char:charsList:parent">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.CompactCharacterButton"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.ChartDataScreen" params="" file="source/funkin/editors/charter/ChartDataScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<data public="1"><t path="funkin.backend.chart.ChartData"/></data>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<scrollSpeedStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></scrollSpeedStepper>
		<stageTextBox public="1"><c path="funkin.editors.ui.UIAutoCompleteTextBox"/></stageTextBox>
		<create public="1" set="method" line="23" override="1"><f a=""><x path="Void"/></f></create>
		<saveInfo public="1" set="method" line="65"><f a=""><x path="Void"/></f></saveInfo>
		<new public="1" set="method" line="18"><f a="data">
	<t path="funkin.backend.chart.ChartData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.Charter" params="" file="source/funkin/editors/charter/Charter.hx">
		<extends path="funkin.editors.ui.UIState"/>
		<__song public="1" static="1"><c path="String"/></__song>
		<__diff static="1"><c path="String"/></__diff>
		<__reload static="1"><x path="Bool"/></__reload>
		<instance public="1" get="accessor" set="null" static="1"><c path="funkin.editors.charter.Charter"/></instance>
		<get_instance get="inline" set="null" line="41" static="1"><f a=""><x path="Null"><c path="funkin.editors.charter.Charter"/></x></f></get_instance>
		<autoSaveTimer public="1" expr="0" line="90" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</autoSaveTimer>
		<selection public="1" static="1"><x path="funkin.editors.charter.Selection"/></selection>
		<playtestInfo public="1" static="1"><t path="funkin.editors.charter.PlaytestInfo"/></playtestInfo>
		<undos public="1" static="1"><c path="funkin.editors.UndoList"><e path="funkin.editors.charter.CharterChange"/></c></undos>
		<clipboard public="1" expr="[]" line="97" static="1">
			<c path="Array"><e path="funkin.editors.charter.CharterCopyboardObject"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</clipboard>
		<waveformHandler public="1" static="1"><c path="funkin.editors.charter.CharterWaveformHandler"/></waveformHandler>
		<startTime public="1" expr="0" line="1251" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</startTime>
		<startHere public="1" expr="false" line="1252" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</startHere>
		<chart get="accessor" set="null"><t path="funkin.backend.chart.ChartData"/></chart>
		<get_chart set="method" line="36"><f a=""><t path="funkin.backend.chart.ChartData"/></f></get_chart>
		<charterBG public="1"><c path="funkin.backend.FunkinSprite"/></charterBG>
		<uiGroup public="1" expr="new FlxTypedGroup&lt;FlxSprite&gt;()">
			<c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxSprite"/></c>
			<meta><m n=":value"><e>new FlxTypedGroup&lt;FlxSprite&gt;()</e></m></meta>
		</uiGroup>
		<topMenu public="1"><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></topMenu>
		<playbackIndex expr="7">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>7</e></m>
				<m n=":noCompletion"/>
			</meta>
		</playbackIndex>
		<snapIndex expr="6">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>6</e></m>
				<m n=":noCompletion"/>
			</meta>
		</snapIndex>
		<noteIndex expr="5">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>5</e></m>
				<m n=":noCompletion"/>
			</meta>
		</noteIndex>
		<scrollBar public="1"><c path="funkin.editors.ui.UIScrollBar"/></scrollBar>
		<songPosInfo public="1"><c path="funkin.editors.ui.UIText"/></songPosInfo>
		<quantButtons public="1" expr="[]">
			<c path="Array"><c path="funkin.editors.charter.CharterQuantButton"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</quantButtons>
		<playBackSlider public="1"><c path="funkin.editors.ui.UISlider"/></playBackSlider>
		<topMenuSpr public="1"><c path="funkin.editors.ui.UITopMenu"/></topMenuSpr>
		<gridBackdrops public="1"><c path="funkin.editors.charter.CharterBackdropGroup"/></gridBackdrops>
		<eventsBackdrop public="1"><c path="funkin.editors.charter.EventBackdrop"/></eventsBackdrop>
		<addEventSpr public="1"><c path="funkin.editors.charter.CharterEventAdd"/></addEventSpr>
		<gridBackdropDummy public="1"><c path="funkin.editors.charter.CharterBackdropDummy"/></gridBackdropDummy>
		<noteHoverer public="1"><c path="funkin.editors.charter.CharterNoteHoverer"/></noteHoverer>
		<noteDeleteAnims public="1"><c path="funkin.editors.charter.CharterDeleteAnim"/></noteDeleteAnims>
		<strumlineInfoBG public="1"><c path="flixel.FlxSprite"/></strumlineInfoBG>
		<strumlineAddButton public="1"><c path="funkin.editors.charter.CharterStrumlineButton"/></strumlineAddButton>
		<strumlineLockButton public="1"><c path="funkin.editors.charter.CharterStrumlineButton"/></strumlineLockButton>
		<hitsound public="1"><c path="flixel.sound.FlxSound"/></hitsound>
		<metronome public="1"><c path="flixel.sound.FlxSound"/></metronome>
		<vocals public="1"><c path="flixel.sound.FlxSound"/></vocals>
		<quant public="1" expr="16">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</quant>
		<quants public="1" expr="[4, 8, 12, 16, 20, 24, 32, 48, 64, 192]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[4, 8, 12, 16, 20, 24, 32, 48, 64, 192]</e></m></meta>
		</quants>
		<noteType public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</noteType>
		<noteTypes public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</noteTypes>
		<noteTypeText public="1"><c path="funkin.editors.ui.UIText"/></noteTypeText>
		<strumLines public="1" expr="new CharterStrumLineGroup()">
			<c path="funkin.editors.charter.CharterStrumLineGroup"/>
			<meta><m n=":value"><e>new CharterStrumLineGroup()</e></m></meta>
		</strumLines>
		<notesGroup public="1" expr="new CharterNoteGroup()">
			<c path="funkin.editors.charter.CharterNoteGroup"/>
			<meta><m n=":value"><e>new CharterNoteGroup()</e></m></meta>
		</notesGroup>
		<eventsGroup public="1" expr="new CharterEventGroup()">
			<c path="funkin.editors.charter.CharterEventGroup"/>
			<meta><m n=":value"><e>new CharterEventGroup()</e></m></meta>
		</eventsGroup>
		<charterCamera public="1"><c path="flixel.FlxCamera"/></charterCamera>
		<uiCamera public="1"><c path="flixel.FlxCamera"/></uiCamera>
		<selectionBox public="1"><c path="funkin.editors.ui.UISliceSprite"/></selectionBox>
		<autoSaveNotif public="1"><c path="funkin.editors.charter.CharterAutoSaveUI"/></autoSaveNotif>
		<create public="1" set="method" line="109" override="1"><f a=""><x path="Void"/></f></create>
		<destroy public="1" set="method" line="517" override="1"><f a=""><x path="Void"/></f></destroy>
		<loadSong public="1" set="method" line="528"><f a=""><x path="Void"/></f></loadSong>
		<__endStep public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__endStep>
		<refreshBPMSensitive public="1" set="method" line="599"><f a=""><x path="Void"/></f></refreshBPMSensitive>
		<isSoundLoaded get="inline" set="null" line="610"><f a="sound">
	<c path="flixel.sound.FlxSound"/>
	<x path="Bool"/>
</f></isSoundLoaded>
		<updateWaveforms public="1" set="method" line="615"><f a=""><x path="Void"/></f></updateWaveforms>
		<beatHit public="1" set="method" line="662" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<gridActionType public="1" expr="NONE">
			<x path="funkin.editors.charter.CharterGridActionType"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
			<haxe_doc>* NOTE AND CHARTER GRID LOGIC HERE</haxe_doc>
		</gridActionType>
		<dragStartPos public="1" expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</dragStartPos>
		<mousePos public="1" expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</mousePos>
		<selectionDragging public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selectionDragging>
		<updateSelectionLogic public="1" set="method" line="679"><f a=""><x path="Void"/></f></updateSelectionLogic>
		<__autoSaveLocation expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</__autoSaveLocation>
		<updateAutoSaving public="1" set="method" line="702"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></updateAutoSaving>
		<deletedNotes expr="new Selection()">
			<x path="funkin.editors.charter.Selection"/>
			<meta><m n=":value"><e>new Selection()</e></m></meta>
		</deletedNotes>
		<updateNoteLogic public="1" set="method" line="731"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></updateNoteLogic>
		<quantStep public="1" set="method" line="951"><f a="step">
	<x path="Float"/>
	<x path="Float"/>
</f></quantStep>
		<quantStepRounded public="1" set="method" line="956">
			<f a="step:?roundRatio" v=":0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ roundRatio : 0.5 }</e></m></meta>
		</quantStepRounded>
		<ratioRound public="1" set="method" line="962"><f a="val:ratio">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></ratioRound>
		<getHoveredEvent public="1" set="method" line="964"><f a="y">
	<x path="Float"/>
	<c path="funkin.editors.charter.CharterEvent"/>
</f></getHoveredEvent>
		<deleteSingleSelection public="1" set="method" line="976">
			<f a="selected:?addToUndo" v=":true">
				<c path="funkin.editors.charter.ICharterSelectable"/>
				<x path="Bool"/>
				<x path="Null"><c path="funkin.editors.charter.ICharterSelectable"/></x>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</deleteSingleSelection>
		<createSelection public="1" set="method" line="997">
			<f a="selection:?addToUndo" v=":true">
				<x path="funkin.editors.charter.Selection"/>
				<x path="Bool"/>
				<c path="Array"><unknown/></c>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</createSelection>
		<deleteSelection public="1" set="method" line="1024">
			<f a="selection:?addToUndo" v=":true">
				<x path="funkin.editors.charter.Selection"/>
				<x path="Bool"/>
				<c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</deleteSelection>
		<createStrumline public="1" set="method" line="1053">
			<f a="strumLineID:strL:?addToUndo:?__createNotes" v="::true:true">
				<x path="Int"/>
				<t path="funkin.backend.chart.ChartStrumLine"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ __createNotes : true, addToUndo : true }</e></m></meta>
		</createStrumline>
		<deleteStrumline public="1" set="method" line="1073">
			<f a="strumLineID:?addToUndo" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</deleteStrumline>
		<getStrumlineID public="1" set="method" line="1099"><f a="strL">
	<t path="funkin.backend.chart.ChartStrumLine"/>
	<x path="Int"/>
</f></getStrumlineID>
		<createStrumWithUI public="1" set="method" line="1107"><f a=""><x path="Void"/></f></createStrumWithUI>
		<deleteStrumlineFromData public="1" get="inline" set="null" line="1119"><f a="strL">
	<t path="funkin.backend.chart.ChartStrumLine"/>
	<x path="Void"/>
</f></deleteStrumlineFromData>
		<editStrumline public="1" get="inline" set="null" line="1121"><f a="strL">
	<t path="funkin.backend.chart.ChartStrumLine"/>
	<x path="Void"/>
</f></editStrumline>
		<removeStrumlineFromSelection public="1" get="inline" set="null" line="1135"><f a="strumLineID">
	<x path="Int"/>
	<x path="Void"/>
</f></removeStrumlineFromSelection>
		<__crochet><x path="Float"/></__crochet>
		<__firstFrame expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__firstFrame>
		<update public="1" set="method" line="1150" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updateDisplaySprites set="method" line="1254"><f a=""><x path="Void"/></f></updateDisplaySprites>
		<zoom set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</zoom>
		<__camZoom set="accessor" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</__camZoom>
		<set_zoom set="method" line="1273"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_zoom>
		<set___camZoom set="method" line="1276"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set___camZoom>
		<_file_exit set="method" line="1282"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_exit>
		<_file_save set="method" line="1287"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_save>
		<_file_saveas set="method" line="1296"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_saveas>
		<_file_save_no_events set="method" line="1303"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_save_no_events>
		<_file_saveas_no_events set="method" line="1312"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_saveas_no_events>
		<_file_meta_save set="method" line="1319"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_meta_save>
		<_file_meta_saveas set="method" line="1330"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_meta_saveas>
		<_file_saveas_fnflegacy set="method" line="1336"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_saveas_fnflegacy>
		<_file_saveas_psych set="method" line="1342"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_saveas_psych>
		<_file_events_save set="method" line="1348"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_events_save>
		<_file_events_saveas set="method" line="1359"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_events_saveas>
		<saveTo set="method" line="1368">
			<f a="path:?separateEvents" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ separateEvents : false }</e></m></meta>
		</saveTo>
		<_edit_copy set="method" line="1374"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_copy>
		<_edit_paste set="method" line="1392"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_paste>
		<_edit_cut set="method" line="1417"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_cut>
		<_edit_delete set="method" line="1424"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_delete>
		<_edit_undo set="method" line="1432"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_undo>
		<_edit_redo set="method" line="1478"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_redo>
		<_chart_playtest get="inline" set="null" line="1524"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_chart_playtest>
		<_chart_playtest_here get="inline" set="null" line="1526"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_chart_playtest_here>
		<_chart_playtest_opponent get="inline" set="null" line="1528"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_chart_playtest_opponent>
		<_chart_playtest_opponent_here get="inline" set="null" line="1530"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_chart_playtest_opponent_here>
		<_chart_enablescripts set="method" line="1531"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_chart_enablescripts>
		<chart_edit_data set="method" line="1536"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></chart_edit_data>
		<chart_edit_metadata set="method" line="1538"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></chart_edit_metadata>
		<_playback_play set="method" line="1540"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_play>
		<_playback_speed_raise set="method" line="1558"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_speed_raise>
		<_playback_speed_reset set="method" line="1559"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_speed_reset>
		<_playback_speed_lower set="method" line="1560"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_speed_lower>
		<_playback_metronome set="method" line="1562"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_playback_metronome>
		<_song_muteinst set="method" line="1565"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_song_muteinst>
		<_song_mutevoices set="method" line="1569"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_song_mutevoices>
		<_playback_back set="method" line="1574"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_back>
		<_playback_forward set="method" line="1578"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_forward>
		<_song_start set="method" line="1582"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_song_start>
		<_song_end set="method" line="1586"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_song_end>
		<_view_zoomin set="method" line="1590"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomin>
		<_view_zoomout set="method" line="1594"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomout>
		<_view_zoomreset set="method" line="1598"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomreset>
		<_view_showeventSecSeparator set="method" line="1602"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_view_showeventSecSeparator>
		<_view_showeventBeatSeparator set="method" line="1606"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_view_showeventBeatSeparator>
		<_view_switchWaveformDetail set="method" line="1610"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_view_switchWaveformDetail>
		<_snap_increasesnap get="inline" set="null" line="1615"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_snap_increasesnap>
		<_snap_decreasesnap get="inline" set="null" line="1616"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_snap_decreasesnap>
		<_snap_resetsnap get="inline" set="null" line="1617"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_snap_resetsnap>
		<changequant get="inline" set="null" line="1619"><f a="change">
	<x path="Int"/>
	<x path="Void"/>
</f></changequant>
		<setquant get="inline" set="null" line="1620"><f a="newquant">
	<x path="Int"/>
	<x path="Void"/>
</f></setquant>
		<buildSnapsUI set="method" line="1622"><f a=""><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></f></buildSnapsUI>
		<_note_addsustain get="inline" set="null" line="1654"><f a="t">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_note_addsustain>
		<_note_subtractsustain get="inline" set="null" line="1657"><f a="t">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_note_subtractsustain>
		<_note_selectall set="method" line="1659"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_note_selectall>
		<_note_selectmeasure set="method" line="1663"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_note_selectmeasure>
		<changeNoteSustain set="method" line="1670"><f a="change">
	<x path="Float"/>
	<x path="Void"/>
</f></changeNoteSustain>
		<changeNoteType public="1" get="inline" set="null" line="1685">
			<f a="?newID:?checkSelection" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkSelection : true }</e></m></meta>
		</changeNoteType>
		<editNoteTypesList set="method" line="1706"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></editNoteTypesList>
		<buildNoteTypesUI set="method" line="1708"><f a=""><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></f></buildNoteTypesUI>
		<playtestChart public="1" set="method" line="1762">
			<f a="?time:?opponentMode:?here" v="0:false:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ here : false, opponentMode : false, time : 0 }</e></m></meta>
		</playtestChart>
		<buildNote public="1" get="inline" set="null" line="1771"><f a="note">
	<c path="funkin.editors.charter.CharterNote"/>
	<t path="funkin.backend.chart.ChartNote"/>
</f></buildNote>
		<buildChart public="1" set="method" line="1781"><f a=""><x path="Void"/></f></buildChart>
		<buildEvents public="1" set="method" line="1796"><f a=""><x path="Void"/></f></buildEvents>
		<updateBPMEvents public="1" set="method" line="1807"><f a=""><x path="Void"/></f></updateBPMEvents>
		<hitsoundsEnabled public="1" get="inline" set="null" line="1817"><f a="id">
	<x path="Int"/>
	<x path="Bool"/>
</f></hitsoundsEnabled>
		<__fixSelection public="1" get="inline" set="null" line="1819"><f a="selection">
	<x path="funkin.editors.charter.Selection"/>
	<x path="funkin.editors.charter.Selection"/>
</f></__fixSelection>
		<__relinkSingleSelection public="1" set="method" line="1827">
			<f a="selectable">
				<c path="funkin.editors.charter.ICharterSelectable"/>
				<c path="funkin.editors.charter.ICharterSelectable"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__relinkSingleSelection>
		<__relinkSelection public="1" set="method" line="1835">
			<f a="selection">
				<x path="funkin.editors.charter.Selection"/>
				<x path="funkin.editors.charter.Selection"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__relinkSelection>
		<__relinkUndos public="1" get="inline" set="null" line="1842">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__relinkUndos>
		<__resetStatics public="1" set="method" line="1886">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__resetStatics>
		<__clearStatics public="1" set="method" line="1894">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__clearStatics>
		<__updatePlaytestInfo public="1" set="method" line="1899">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__updatePlaytestInfo>
		<__applyPlaytestInfo public="1" set="method" line="1912">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__applyPlaytestInfo>
		<new public="1" set="method" line="100">
			<f a="song:diff:?reload" v="::true">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ reload : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="funkin.editors.charter.CharterChange" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter">
		<CCreateStrumLine a="strumLineID:strumLine">
			<x path="Int"/>
			<t path="funkin.backend.chart.ChartStrumLine"/>
		</CCreateStrumLine>
		<CEditStrumLine a="strumLineID:oldStrumLine:newStrumLine">
			<x path="Int"/>
			<t path="funkin.backend.chart.ChartStrumLine"/>
			<t path="funkin.backend.chart.ChartStrumLine"/>
		</CEditStrumLine>
		<COrderStrumLine a="strumLineID:oldID:newID">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</COrderStrumLine>
		<CDeleteStrumLine a="strumLineID:strumLine">
			<x path="Int"/>
			<t path="funkin.backend.chart.ChartStrumLine"/>
		</CDeleteStrumLine>
		<CCreateSelection a="selection"><x path="funkin.editors.charter.Selection"/></CCreateSelection>
		<CDeleteSelection a="selection"><x path="funkin.editors.charter.Selection"/></CDeleteSelection>
		<CSelectionDrag a="selectionDrags"><c path="Array"><t path="funkin.editors.charter.SelectionDragChange"/></c></CSelectionDrag>
		<CEditSustains a="notes"><c path="Array"><t path="funkin.editors.charter.NoteSustainChange"/></c></CEditSustains>
		<CEditEvent a="event:oldEvents:newEvents">
			<c path="funkin.editors.charter.CharterEvent"/>
			<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
			<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
		</CEditEvent>
		<CEditChartData a="oldData:newData">
			<a>
				<stage><c path="String"/></stage>
				<speed><x path="Float"/></speed>
			</a>
			<a>
				<stage><c path="String"/></stage>
				<speed><x path="Float"/></speed>
			</a>
		</CEditChartData>
		<CEditNoteTypes a="oldArray:newArray">
			<c path="Array"><c path="String"/></c>
			<c path="Array"><c path="String"/></c>
		</CEditNoteTypes>
		<CEditSpecNotesType a="notes:oldNoteTypes:newNoteTypes">
			<c path="Array"><c path="funkin.editors.charter.CharterNote"/></c>
			<c path="Array"><x path="Int"/></c>
			<c path="Array"><x path="Int"/></c>
		</CEditSpecNotesType>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="funkin.editors.charter.CharterCopyboardObject" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter">
		<CNote a="step:id:strumLineID:susLength:type">
			<x path="Float"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Int"/>
		</CNote>
		<CEvent a="step:events">
			<x path="Float"/>
			<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
		</CEvent>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="funkin.editors.charter.NoteSustainChange" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter"><a>
	<note><c path="funkin.editors.charter.CharterNote"/></note>
	<before><x path="Float"/></before>
	<after><x path="Float"/></after>
</a></typedef>
	<typedef path="funkin.editors.charter.SelectionDragChange" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter"><a>
	<selectable><c path="funkin.editors.charter.ICharterSelectable"/></selectable>
	<change><x path="flixel.math.FlxPoint"/></change>
</a></typedef>
	<abstract path="funkin.editors.charter.Selection" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter">
		<from><icast><c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c></icast></from>
		<this><c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c></this>
		<to><icast><c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="funkin.editors.charter._Charter.Selection_Impl_" params="" file="source/funkin/editors/charter/Charter.hx" private="1" module="funkin.editors.charter.Charter" final="1">
	<_new public="1" get="inline" set="null" line="1962" static="1">
		<f a="?array">
			<c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c>
			<x path="funkin.editors.charter.Selection"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<loop public="1" get="inline" set="null" line="1966" static="1">
		<f a="this:onNote:?onEvent:?draggableOnly" v=":::true">
			<c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c>
			<f a="">
				<c path="funkin.editors.charter.CharterNote"/>
				<x path="Void"/>
			</f>
			<f a="">
				<c path="funkin.editors.charter.CharterEvent"/>
				<x path="Void"/>
			</f>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ draggableOnly : true }</e></m></meta>
	</loop>
</class></impl>
	</abstract>
	<class path="funkin.editors.charter._Charter.Selection_Impl_" params="" file="source/funkin/editors/charter/Charter.hx" private="1" module="funkin.editors.charter.Charter" final="1">
		<_new public="1" get="inline" set="null" line="1962" static="1">
			<f a="?array">
				<c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c>
				<x path="funkin.editors.charter.Selection"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<loop public="1" get="inline" set="null" line="1966" static="1">
			<f a="this:onNote:?onEvent:?draggableOnly" v=":::true">
				<c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c>
				<f a="">
					<c path="funkin.editors.charter.CharterNote"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="funkin.editors.charter.CharterEvent"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ draggableOnly : true }</e></m></meta>
		</loop>
	</class>
	<class path="funkin.editors.charter.ICharterSelectable" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter" interface="1">
		<set_x public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":noCompletion"/>
			</meta>
		</set_x>
		<set_y public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":noCompletion"/>
			</meta>
		</set_y>
		<x public="1" set="accessor"><x path="Float"/></x>
		<y public="1" set="accessor"><x path="Float"/></y>
		<ID public="1"><x path="Int"/></ID>
		<step public="1"><x path="Float"/></step>
		<selected public="1"><x path="Bool"/></selected>
		<hovered public="1"><x path="Bool"/></hovered>
		<draggable public="1"><x path="Bool"/></draggable>
		<handleSelection public="1" set="method"><f a="selectionBox">
	<c path="funkin.editors.ui.UISliceSprite"/>
	<x path="Bool"/>
</f></handleSelection>
		<handleDrag public="1" set="method"><f a="change">
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></handleDrag>
	</class>
	<abstract path="funkin.editors.charter.CharterGridActionType" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.editors.charter._Charter.CharterGridActionType_Impl_" params="" file="source/funkin/editors/charter/Charter.hx" private="1" module="funkin.editors.charter.Charter" extern="1" final="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="1991" static="1">
		<x path="funkin.editors.charter.CharterGridActionType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<BOX_SELECTION public="1" get="inline" set="null" expr="cast 1" line="1992" static="1">
		<x path="funkin.editors.charter.CharterGridActionType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BOX_SELECTION>
	<NOTE_DRAG public="1" get="inline" set="null" expr="cast 2" line="1993" static="1">
		<x path="funkin.editors.charter.CharterGridActionType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOTE_DRAG>
	<INVALID_DRAG public="1" get="inline" set="null" expr="cast 3" line="1994" static="1">
		<x path="funkin.editors.charter.CharterGridActionType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INVALID_DRAG>
	<SUSTAIN_DRAG public="1" get="inline" set="null" expr="cast 4" line="1995" static="1">
		<x path="funkin.editors.charter.CharterGridActionType"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SUSTAIN_DRAG>
	<DELETE_SELECTION public="1" get="inline" set="null" expr="cast 5" line="1996" static="1">
		<x path="funkin.editors.charter.CharterGridActionType"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DELETE_SELECTION>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.editors.charter._Charter.CharterGridActionType_Impl_" params="" file="source/funkin/editors/charter/Charter.hx" private="1" module="funkin.editors.charter.Charter" extern="1" final="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="1991" static="1">
			<x path="funkin.editors.charter.CharterGridActionType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<BOX_SELECTION public="1" get="inline" set="null" expr="cast 1" line="1992" static="1">
			<x path="funkin.editors.charter.CharterGridActionType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BOX_SELECTION>
		<NOTE_DRAG public="1" get="inline" set="null" expr="cast 2" line="1993" static="1">
			<x path="funkin.editors.charter.CharterGridActionType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOTE_DRAG>
		<INVALID_DRAG public="1" get="inline" set="null" expr="cast 3" line="1994" static="1">
			<x path="funkin.editors.charter.CharterGridActionType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INVALID_DRAG>
		<SUSTAIN_DRAG public="1" get="inline" set="null" expr="cast 4" line="1995" static="1">
			<x path="funkin.editors.charter.CharterGridActionType"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SUSTAIN_DRAG>
		<DELETE_SELECTION public="1" get="inline" set="null" expr="cast 5" line="1996" static="1">
			<x path="funkin.editors.charter.CharterGridActionType"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DELETE_SELECTION>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="funkin.editors.charter.PlaytestInfo" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter"><a>
	<waveforms><c path="Array"><x path="Int"/></c></waveforms>
	<strumlinesDraggable><x path="Bool"/></strumlinesDraggable>
	<songPosition><x path="Float"/></songPosition>
	<quantSelected><x path="Int"/></quantSelected>
	<playbackSpeed><x path="Float"/></playbackSpeed>
	<noteTypeSelected><x path="Int"/></noteTypeSelected>
	<mutedVocals><c path="Array"><x path="Bool"/></c></mutedVocals>
	<hitSounds><c path="Array"><x path="Bool"/></c></hitSounds>
</a></typedef>
	<class path="funkin.editors.charter.CharterAutoSaveUI" params="" file="source/funkin/editors/charter/CharterAutoSaveUI.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<icon public="1"><c path="flixel.FlxSprite"/></icon>
		<autosavingText public="1"><c path="funkin.editors.ui.UIText"/></autosavingText>
		<progressBarBack public="1"><c path="flixel.FlxSprite"/></progressBarBack>
		<progressBar public="1"><c path="flixel.FlxSprite"/></progressBar>
		<cancelButton public="1"><c path="funkin.editors.ui.UIButton"/></cancelButton>
		<cancelIcon public="1"><c path="flixel.FlxSprite"/></cancelIcon>
		<showedAnimation public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</showedAnimation>
		<cancelled public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</cancelled>
		<__timer><c path="flixel.util.FlxTimer"/></__timer>
		<__tween><c path="flixel.tweens.FlxTween"/></__tween>
		<startAutoSave public="1" set="method" line="66"><f a="time:sucessText">
	<x path="Float"/>
	<c path="String"/>
	<x path="Void"/>
</f></startAutoSave>
		<progress public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</progress>
		<update public="1" set="method" line="87" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<appearAnimation public="1" set="method" line="111"><f a=""><x path="Void"/></f></appearAnimation>
		<disappearAnimation public="1" set="method" line="122">
			<f a="?canned" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ canned : false }</e></m></meta>
		</disappearAnimation>
		<new public="1" set="method" line="21"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterBackdropGroup" params="" file="source/funkin/editors/charter/CharterBackdropGroup.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.editors.charter.CharterBackdrop"/></extends>
		<strumLineGroup public="1"><c path="funkin.editors.charter.CharterStrumLineGroup"/></strumLineGroup>
		<notesGroup public="1"><c path="funkin.editors.charter.CharterNoteGroup"/></notesGroup>
		<__gridGraphic><c path="flixel.graphics.FlxGraphic"/></__gridGraphic>
		<conductorSprY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</conductorSprY>
		<bottomLimitY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bottomLimitY>
		<sectionsVisible public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</sectionsVisible>
		<beatsVisible public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</beatsVisible>
		<strumlinesAmount public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</strumlinesAmount>
		<createGrids public="1" set="method" line="38">
			<f a="?amount" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ amount : 0 }</e></m></meta>
		</createGrids>
		<update public="1" set="method" line="46" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draggingObj public="1" expr="null">
			<c path="funkin.editors.charter.CharterBackdrop"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</draggingObj>
		<draw public="1" set="method" line="82" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="21"><f a="strumLineGroup">
	<c path="funkin.editors.charter.CharterStrumLineGroup"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterBackdrop" params="" file="source/funkin/editors/charter/CharterBackdropGroup.hx" module="funkin.editors.charter.CharterBackdropGroup">
		<extends path="flixel.group.FlxTypedGroup"><d/></extends>
		<gridBackDrop public="1"><c path="flixel.addons.display.FlxBackdrop"/></gridBackDrop>
		<topLimit public="1"><c path="flixel.FlxSprite"/></topLimit>
		<topSeparator public="1"><c path="flixel.FlxSprite"/></topSeparator>
		<bottomLimit public="1"><c path="flixel.FlxSprite"/></bottomLimit>
		<bottomSeparator public="1"><c path="flixel.FlxSprite"/></bottomSeparator>
		<waveformSprite public="1"><c path="flixel.FlxSprite"/></waveformSprite>
		<conductorFollowerSpr public="1"><c path="flixel.FlxSprite"/></conductorFollowerSpr>
		<beatSeparator public="1"><c path="flixel.addons.display.FlxBackdrop"/></beatSeparator>
		<sectionSeparator public="1"><c path="flixel.addons.display.FlxBackdrop"/></sectionSeparator>
		<notesGroup public="1" expr="new FlxTypedGroup&lt;CharterNote&gt;()">
			<c path="flixel.group.FlxTypedGroup"><c path="funkin.editors.charter.CharterNote"/></c>
			<meta><m n=":value"><e>new FlxTypedGroup&lt;CharterNote&gt;()</e></m></meta>
		</notesGroup>
		<strumLine public="1"><c path="funkin.editors.charter.CharterStrumline"/></strumLine>
		<updateSprites public="1" set="method" line="194"><f a=""><x path="Void"/></f></updateSprites>
		<new public="1" set="method" line="128"><f a="gridGraphic">
	<c path="flixel.graphics.FlxGraphic"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterBackdropDummy" params="" file="source/funkin/editors/charter/CharterBackdropGroup.hx" module="funkin.editors.charter.CharterBackdropGroup">
		<extends path="funkin.editors.ui.UISprite"/>
		<parent><c path="funkin.editors.charter.CharterBackdropGroup"/></parent>
		<updateButton public="1" set="method" line="249" override="1"><f a=""><x path="Void"/></f></updateButton>
		<draw public="1" set="method" line="254" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="242"><f a="parent">
	<c path="funkin.editors.charter.CharterBackdropGroup"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.EventBackdrop" params="" file="source/funkin/editors/charter/CharterBackdropGroup.hx" module="funkin.editors.charter.CharterBackdropGroup">
		<extends path="flixel.addons.display.FlxBackdrop"/>
		<eventBeatSeparator public="1"><c path="flixel.addons.display.FlxBackdrop"/></eventBeatSeparator>
		<eventSecSeparator public="1"><c path="flixel.addons.display.FlxBackdrop"/></eventSecSeparator>
		<topSeparator public="1"><c path="flixel.FlxSprite"/></topSeparator>
		<bottomSeparator public="1"><c path="flixel.FlxSprite"/></bottomSeparator>
		<draw public="1" set="method" line="308" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="267"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterNote" params="" file="source/funkin/editors/charter/CharterNote.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<implements path="funkin.editors.charter.ICharterSelectable"/>
		<colors expr="[0xFFC24B99, 0xFF00FFFF, 0xFF12FA05, 0xFFF9393F]" line="16" static="1">
			<c path="Array"><x path="flixel.util.FlxColor"/></c>
			<meta><m n=":value"><e>[0xFFC24B99, 0xFF00FFFF, 0xFF12FA05, 0xFFF9393F]</e></m></meta>
		</colors>
		<angleTween><c path="flixel.tweens.FlxTween"/></angleTween>
		<__doAnim expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__doAnim>
		<__animSpeed expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</__animSpeed>
		<__susInstaLerp expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__susInstaLerp>
		<sustainSpr public="1"><c path="funkin.editors.ui.UISprite"/></sustainSpr>
		<tempSusLength public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tempSusLength>
		<sustainDraggable public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</sustainDraggable>
		<typeText public="1"><c path="funkin.editors.ui.UIText"/></typeText>
		<selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selected>
		<draggable public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</draggable>
		<updateButtonHandler public="1" set="method" line="52" override="1"><f a=""><x path="Void"/></f></updateButtonHandler>
		<step public="1"><x path="Float"/></step>
		<id public="1"><x path="Int"/></id>
		<susLength public="1"><x path="Float"/></susLength>
		<type public="1"><x path="Int"/></type>
		<strumLine public="1"><c path="funkin.editors.charter.CharterStrumline"/></strumLine>
		<strumLineID public="1" get="accessor" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</strumLineID>
		<get_strumLineID public="1" set="method" line="68"><f a=""><x path="Int"/></f></get_strumLineID>
		<snappedToStrumline public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</snappedToStrumline>
		<fullID public="1" get="accessor" set="null"><x path="Int"/></fullID>
		<get_fullID public="1" set="method" line="74"><f a=""><x path="Int"/></f></get_fullID>
		<updatePos public="1" set="method" line="76">
			<f a="step:id:?susLength:?type:?strumLine" v="::0:0:null">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="funkin.editors.charter.CharterStrumline"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ strumLine : null, type : 0, susLength : 0 }</e></m></meta>
		</updatePos>
		<kill public="1" set="method" line="116" override="1"><f a=""><x path="Void"/></f></kill>
		<__passed expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__passed>
		<update public="1" set="method" line="133" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<handleSelection public="1" set="method" line="167"><f a="selectionBox">
	<c path="funkin.editors.ui.UISliceSprite"/>
	<x path="Bool"/>
</f></handleSelection>
		<handleDrag public="1" set="method" line="176"><f a="change">
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></handleDrag>
		<draw public="1" set="method" line="183" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterDeleteAnim" params="" file="source/funkin/editors/charter/CharterDeleteAnim.hx">
		<extends path="funkin.editors.charter.CharterNote"/>
		<garbageIcon public="1"><c path="flixel.FlxSprite"/></garbageIcon>
		<garbageCircle public="1"><c path="flixel.FlxSprite"/></garbageCircle>
		<deleteNotes public="1" expr="[]">
			<c path="Array"><a>
	<time><x path="Float"/></time>
	<note><c path="funkin.editors.charter.CharterNote"/></note>
</a></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</deleteNotes>
		<deleteTime public="1" expr=".4">
			<x path="Float"/>
			<meta><m n=":value"><e>.4</e></m></meta>
		</deleteTime>
		<__garbageAlpha expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__garbageAlpha>
		<__deletionTimer expr=".1">
			<x path="Float"/>
			<meta><m n=":value"><e>.1</e></m></meta>
		</__deletionTimer>
		<__mousePos expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta>
				<m n=":value"><e>FlxPoint.get()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__mousePos>
		<update public="1" set="method" line="29" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="57" override="1"><f a=""><x path="Void"/></f></draw>
		<destroy public="1" set="method" line="82" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterEvent" params="" file="source/funkin/editors/charter/CharterEvent.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<implements path="funkin.editors.charter.ICharterSelectable"/>
		<generateDefaultIcon set="method" line="47" static="1"><f a="name">
	<c path="String"/>
	<c path="flixel.FlxSprite"/>
</f></generateDefaultIcon>
		<generateEventIcon public="1" set="method" line="60" static="1"><f a="event">
	<t path="funkin.backend.chart.ChartEvent"/>
	<c path="flixel.FlxSprite"/>
</f></generateEventIcon>
		<events public="1"><c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c></events>
		<step public="1"><x path="Float"/></step>
		<icons public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxSprite"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</icons>
		<selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selected>
		<draggable public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</draggable>
		<eventsBackdrop public="1"><c path="funkin.editors.charter.EventBackdrop"/></eventsBackdrop>
		<snappedToGrid public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</snappedToGrid>
		<update public="1" set="method" line="29" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<onHovered public="1" set="method" line="80" override="1"><f a=""><x path="Void"/></f></onHovered>
		<handleSelection public="1" set="method" line="88"><f a="selectionBox">
	<c path="funkin.editors.ui.UISliceSprite"/>
	<x path="Bool"/>
</f></handleSelection>
		<handleDrag public="1" set="method" line="92"><f a="change">
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></handleDrag>
		<refreshEventIcons public="1" set="method" line="97"><f a=""><x path="Void"/></f></refreshEventIcons>
		<new public="1" set="method" line="21"><f a="step:?events">
	<x path="Float"/>
	<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterEventAdd" params="" file="source/funkin/editors/charter/CharterEventAdd.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<text><c path="funkin.editors.ui.UIText"/></text>
		<sprAlpha public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</sprAlpha>
		<step public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</step>
		<curCharterEvent public="1" expr="null">
			<c path="funkin.editors.charter.CharterEvent"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curCharterEvent>
		<onHovered public="1" set="method" line="19" override="1"><f a=""><x path="Void"/></f></onHovered>
		<update public="1" set="method" line="29" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updatePos public="1" set="method" line="37"><f a="step">
	<x path="Float"/>
	<x path="Void"/>
</f></updatePos>
		<updateEdit public="1" set="method" line="46"><f a="event">
	<c path="funkin.editors.charter.CharterEvent"/>
	<x path="Void"/>
</f></updateEdit>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterEventGroup" params="" file="source/funkin/editors/charter/CharterEventGroup.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.editors.charter.CharterEvent"/></extends>
		<eventsBackdrop public="1"><c path="funkin.editors.charter.EventBackdrop"/></eventsBackdrop>
		<autoSort public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoSort>
		<__lastSort expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__lastSort>
		<update public="1" set="method" line="12" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<remove public="1" set="method" line="20" override="1">
			<f a="v:?force" v=":true">
				<c path="funkin.editors.charter.CharterEvent"/>
				<x path="Bool"/>
				<c path="funkin.editors.charter.CharterEvent"/>
			</f>
			<meta><m n=":value"><e>{ force : true }</e></m></meta>
		</remove>
		<draw public="1" set="method" line="25" override="1"><f a=""><x path="Void"/></f></draw>
		<sortEvents public="1" get="inline" set="null" line="33"><f a=""><x path="Void"/></f></sortEvents>
		<updateEventsIDs public="1" get="inline" set="null" line="42"><f a=""><x path="Void"/></f></updateEventsIDs>
		<filterEvents public="1" get="inline" set="null" line="44"><f a=""><x path="Void"/></f></filterEvents>
		<new public="1" set="method" line="6"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterEventScreen" params="" file="source/funkin/editors/charter/CharterEventScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<chartEvent public="1"><c path="funkin.editors.charter.CharterEvent"/></chartEvent>
		<step public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</step>
		<events public="1" expr="[]">
			<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</events>
		<eventsList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.EventButton"/></c></eventsList>
		<eventName public="1"><c path="funkin.editors.ui.UIText"/></eventName>
		<paramsPanel public="1"><t path="flixel.group.FlxGroup"/></paramsPanel>
		<paramsFields public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxBasic"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</paramsFields>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<create public="1" set="method" line="33" override="1"><f a=""><x path="Void"/></f></create>
		<curEvent public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</curEvent>
		<changeTab public="1" set="method" line="106">
			<f a="id:?save" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ save : true }</e></m></meta>
		</changeTab>
		<saveCurTab public="1" set="method" line="181"><f a=""><x path="Void"/></f></saveCurTab>
		<new public="1" set="method" line="27"><f a="step:?chartEvent">
	<x path="Float"/>
	<c path="funkin.editors.charter.CharterEvent"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.EventButton" params="" file="source/funkin/editors/charter/CharterEventScreen.hx" module="funkin.editors.charter.CharterEventScreen">
		<extends path="funkin.editors.ui.UIButton"/>
		<icon public="1" expr="null">
			<c path="flixel.FlxSprite"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</icon>
		<event public="1" expr="null">
			<t path="funkin.backend.chart.ChartEvent"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</event>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<update public="1" set="method" line="245" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="218"><f a="event:icon:id:substate:parent">
	<t path="funkin.backend.chart.ChartEvent"/>
	<c path="flixel.FlxSprite"/>
	<x path="Int"/>
	<c path="funkin.editors.charter.CharterEventScreen"/>
	<c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.EventButton"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterEventTypeSelection" params="" file="source/funkin/editors/charter/CharterEventTypeSelection.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<callback><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></callback>
		<buttons expr="[]">
			<c path="Array"><c path="funkin.editors.ui.UIButton"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</buttons>
		<buttonsBG><c path="funkin.editors.ui.UISliceSprite"/></buttonsBG>
		<buttonCameras><c path="flixel.FlxCamera"/></buttonCameras>
		<upIndicator><c path="funkin.editors.ui.UIText"/></upIndicator>
		<downIndicator><c path="funkin.editors.ui.UIText"/></downIndicator>
		<create public="1" set="method" line="21" override="1"><f a=""><x path="Void"/></f></create>
		<sinner expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</sinner>
		<update public="1" set="method" line="77" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="100" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="16"><f a="callback">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterMetaDataScreen" params="" file="source/funkin/editors/charter/CharterMetaDataScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<metadata public="1"><t path="funkin.backend.chart.ChartMetaData"/></metadata>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<songNameTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></songNameTextBox>
		<bpmStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></bpmStepper>
		<beatsPerMeasureStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></beatsPerMeasureStepper>
		<stepsPerBeatStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></stepsPerBeatStepper>
		<needsVoicesCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></needsVoicesCheckbox>
		<customPropertiesButtonList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.extra.PropertyButton"/></c></customPropertiesButtonList>
		<displayNameTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></displayNameTextBox>
		<iconTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></iconTextBox>
		<iconSprite public="1"><c path="flixel.FlxSprite"/></iconSprite>
		<opponentModeCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></opponentModeCheckbox>
		<coopAllowedCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></coopAllowedCheckbox>
		<colorWheel public="1"><c path="funkin.editors.ui.UIColorwheel"/></colorWheel>
		<difficulitesTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></difficulitesTextBox>
		<create public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></create>
		<updateIcon set="method" line="131"><f a="icon">
	<c path="String"/>
	<x path="Void"/>
</f></updateIcon>
		<saveMeta public="1" set="method" line="150"><f a=""><x path="Void"/></f></saveMeta>
		<new public="1" set="method" line="29"><f a="metadata">
	<t path="funkin.backend.chart.ChartMetaData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterNoteGroup" params="" file="source/funkin/editors/charter/CharterNoteGroup.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.editors.charter.CharterNote"/></extends>
		<getVar set="method" line="52" static="1"><f a="n">
	<c path="funkin.editors.charter.CharterNote"/>
	<x path="Float"/>
</f></getVar>
		<getVarForEachAdd set="method" line="55" static="1"><f a="n">
	<c path="funkin.editors.charter.CharterNote"/>
	<x path="Float"/>
</f></getVarForEachAdd>
		<getVarForEachRemove set="method" line="57" static="1"><f a="n">
	<c path="funkin.editors.charter.CharterNote"/>
	<x path="Float"/>
</f></getVarForEachRemove>
		<__loopSprite><c path="funkin.editors.charter.CharterNote"/></__loopSprite>
		<i expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</i>
		<max expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</max>
		<__currentlyLooping expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__currentlyLooping>
		<autoSort public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoSort>
		<__lastSort expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__lastSort>
		<forEach public="1" set="method" line="15" override="1">
			<f a="noteFunc:?recursive" v=":false">
				<f a="">
					<c path="funkin.editors.charter.CharterNote"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : false }</e></m></meta>
		</forEach>
		<add public="1" set="method" line="41" override="1"><f a="v">
	<c path="funkin.editors.charter.CharterNote"/>
	<c path="funkin.editors.charter.CharterNote"/>
</f></add>
		<remove public="1" set="method" line="46" override="1">
			<f a="v:?force" v=":true">
				<c path="funkin.editors.charter.CharterNote"/>
				<x path="Bool"/>
				<c path="funkin.editors.charter.CharterNote"/>
			</f>
			<meta><m n=":value"><e>{ force : true }</e></m></meta>
		</remove>
		<draw public="1" set="method" line="59" override="1"><f a=""><x path="Void"/></f></draw>
		<update public="1" set="method" line="61" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<sortNotes public="1" set="method" line="78"><f a=""><x path="Void"/></f></sortNotes>
		<updateNoteIDs public="1" get="inline" set="null" line="89"><f a=""><x path="Void"/></f></updateNoteIDs>
		<preallocate public="1" get="inline" set="null" line="91"><f a="len">
	<x path="Int"/>
	<x path="Void"/>
</f></preallocate>
		<new public="1" set="method" line="6"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterNoteHoverer" params="" file="source/funkin/editors/charter/CharterNoteHoverer.hx">
		<extends path="funkin.editors.charter.CharterNote"/>
		<showHoverer public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</showHoverer>
		<__mousePos expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta>
				<m n=":value"><e>FlxPoint.get()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__mousePos>
		<update public="1" set="method" line="14" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="39" override="1"><f a=""><x path="Void"/></f></draw>
		<destroy public="1" set="method" line="84" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterNoteTypesList" params="" file="source/funkin/editors/charter/CharterNoteTypesList.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<pathString public="1" expr="&quot;data/notes/&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"data/notes/"</e></m></meta>
		</pathString>
		<noteTypesList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.NoteTypeButton"/></c></noteTypesList>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<create public="1" set="method" line="13" override="1"><f a=""><x path="Void"/></f></create>
		<getNoteTypesList public="1" set="method" line="50">
			<f a="?mods" v="false">
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ mods : false }</e></m></meta>
		</getNoteTypesList>
		<saveList public="1" set="method" line="60"><f a=""><x path="Void"/></f></saveList>
		<new public="1" set="method" line="6"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.NoteTypeButton" params="" file="source/funkin/editors/charter/CharterNoteTypesList.hx" module="funkin.editors.charter.CharterNoteTypesList">
		<extends path="funkin.editors.ui.UIButton"/>
		<IDText public="1"><c path="funkin.editors.ui.UIText"/></IDText>
		<noteSpr public="1"><c path="flixel.FlxSprite"/></noteSpr>
		<textBox public="1"><c path="funkin.editors.ui.UIAutoCompleteTextBox"/></textBox>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<updateNote public="1" set="method" line="105"><f a="notetype">
	<c path="String"/>
	<x path="Void"/>
</f></updateNote>
		<update public="1" set="method" line="120" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="78"><f a="x:y:name:noteID:suggestList:parent">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Int"/>
	<c path="Array"><c path="String"/></c>
	<c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.NoteTypeButton"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UITopMenuButton" params="" file="source/funkin/editors/ui/UITopMenu.hx" module="funkin.editors.ui.UITopMenu">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<label public="1"><c path="funkin.editors.ui.UIText"/></label>
		<contextMenu public="1"><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></contextMenu>
		<parent public="1"><c path="funkin.editors.ui.UITopMenu"/></parent>
		<curMenu public="1" expr="null">
			<c path="funkin.editors.ui.UIContextMenu"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curMenu>
		<justClosed expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</justClosed>
		<autoAnim expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoAnim>
		<update public="1" set="method" line="57" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<onHovered public="1" set="method" line="85" override="1"><f a=""><x path="Void"/></f></onHovered>
		<openContextMenu public="1" set="method" line="96"><f a=""><x path="Void"/></f></openContextMenu>
		<new public="1" set="method" line="42"><f a="x:y:parent:label:contextMenu">
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.editors.ui.UITopMenu"/>
	<c path="String"/>
	<c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UITopButton" params="" file="source/funkin/editors/ui/UITopMenu.hx" module="funkin.editors.ui.UITopMenu">
		<extends path="funkin.editors.ui.UITopMenuButton"/>
		<onClick public="1"><f a=""><x path="Void"/></f></onClick>
		<update public="1" set="method" line="111" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<openContextMenu public="1" set="method" line="117" override="1"><f a=""><x path="Void"/></f></openContextMenu>
		<new public="1" set="method" line="109"><f a="x:y:name">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="funkin.editors.charter.CharterQuantButton" params="" file="source/funkin/editors/charter/CharterQuantButton.hx">
		<extends path="funkin.editors.ui.UITopButton"/>
		<quant public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</quant>
		<new public="1" set="method" line="5"><f a="x:y:quant">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterSelection" params="" file="source/funkin/editors/charter/CharterSelection.hx">
		<extends path="funkin.editors.EditorTreeMenu"/>
		<freeplayList public="1"><c path="funkin.menus.FreeplaySonglist"/></freeplayList>
		<curSong public="1"><t path="funkin.backend.chart.ChartMetaData"/></curSong>
		<create public="1" set="method" line="19" override="1"><f a=""><x path="Void"/></f></create>
		<createPost public="1" set="method" line="53" override="1"><f a=""><x path="Void"/></f></createPost>
		<update public="1" set="method" line="59" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<onMenuChange public="1" set="method" line="70" override="1"><f a=""><x path="Void"/></f></onMenuChange>
		<saveSong public="1" set="method" line="91"><f a="creation">
	<t path="funkin.editors.charter.SongCreationData"/>
	<x path="Void"/>
</f></saveSong>
		<saveChart public="1" set="method" line="136"><f a="name:data">
	<c path="String"/>
	<t path="funkin.backend.chart.ChartData"/>
	<x path="Void"/>
</f></saveChart>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterStrumLineGroup" params="" file="source/funkin/editors/charter/CharterStrumLineGroup.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.editors.charter.CharterStrumline"/></extends>
		<__pastStrumlines><c path="Array"><c path="funkin.editors.charter.CharterStrumline"/></c></__pastStrumlines>
		<draggingObj expr="null">
			<c path="funkin.editors.charter.CharterStrumline"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</draggingObj>
		<draggingOffset expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</draggingOffset>
		<draggable public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</draggable>
		<isDragging public="1" get="accessor" set="null"><x path="Bool"/></isDragging>
		<get_isDragging public="1" set="method" line="14"><f a=""><x path="Bool"/></f></get_isDragging>
		<update public="1" set="method" line="16" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<snapStrums public="1" set="method" line="53"><f a=""><x path="Void"/></f></snapStrums>
		<orderStrumline public="1" set="method" line="58"><f a="strumLine:newID">
	<c path="funkin.editors.charter.CharterStrumline"/>
	<x path="Int"/>
	<x path="Void"/>
</f></orderStrumline>
		<finishDrag public="1" set="method" line="67">
			<f a="?addToUndo" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</finishDrag>
		<fixEvents public="1" get="inline" set="null" line="82"><f a=""><x path="Void"/></f></fixEvents>
		<draw public="1" set="method" line="95" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="6"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterStrumline" params="" file="source/funkin/editors/charter/CharterStrumline.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<strumLine public="1"><t path="funkin.backend.chart.ChartStrumLine"/></strumLine>
		<hitsounds public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</hitsounds>
		<draggingSprite public="1"><c path="funkin.editors.ui.UISprite"/></draggingSprite>
		<healthIcons public="1"><t path="flixel.group.FlxSpriteGroup"/></healthIcons>
		<button public="1"><c path="funkin.editors.charter.CharterStrumlineOptions"/></button>
		<draggable public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</draggable>
		<dragging public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</dragging>
		<curMenu public="1" expr="null">
			<c path="funkin.editors.ui.UIContextMenu"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curMenu>
		<vocals public="1"><c path="flixel.sound.FlxSound"/></vocals>
		<selectedWaveform public="1" set="accessor" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</selectedWaveform>
		<set_selectedWaveform public="1" set="method" line="27"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_selectedWaveform>
		<waveformShader public="1"><c path="funkin.backend.shaders.CustomShader"/></waveformShader>
		<__healthYOffset expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__healthYOffset>
		<__draggingYOffset expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__draggingYOffset>
		<update public="1" set="method" line="82" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updateInfo public="1" set="method" line="102"><f a=""><x path="Void"/></f></updateInfo>
		<new public="1" set="method" line="37"><f a="strumLine">
	<t path="funkin.backend.chart.ChartStrumLine"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterStrumlineOptions" params="" file="source/funkin/editors/charter/CharterStrumline.hx" module="funkin.editors.charter.CharterStrumline">
		<extends path="funkin.editors.ui.UITopMenuButton"/>
		<strLine><c path="funkin.editors.charter.CharterStrumline"/></strLine>
		<update public="1" set="method" line="132" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<openContextMenu public="1" set="method" line="137" override="1"><f a=""><x path="Void"/></f></openContextMenu>
		<new public="1" set="method" line="125"><f a="parent">
	<c path="funkin.editors.charter.CharterStrumline"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterStrumlineButton" params="" file="source/funkin/editors/charter/CharterStrumlineButton.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<button public="1"><c path="funkin.editors.ui.UISprite"/></button>
		<text public="1"><c path="funkin.editors.ui.UIText"/></text>
		<onClick public="1"><f a=""><x path="Void"/></f></onClick>
		<animationOnClick public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</animationOnClick>
		<buttonScale expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</buttonScale>
		<buttonScaleOffset expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</buttonScaleOffset>
		<buttonYOffset expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</buttonYOffset>
		<jumpTween><c path="flixel.tweens.FlxTween"/></jumpTween>
		<scaleTween><c path="flixel.tweens.FlxTween"/></scaleTween>
		<angleTween><c path="flixel.tweens.FlxTween"/></angleTween>
		<shakeTimer expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</shakeTimer>
		<textTweenColor public="1"><c path="funkin.backend.utils.FlxInterpolateColor"/></textTweenColor>
		<textColorLerp public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</textColorLerp>
		<update public="1" set="method" line="50" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="81" override="1"><f a=""><x path="Void"/></f></destroy>
		<pressAnimation public="1" set="method" line="88">
			<f a="?extra" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ extra : false }</e></m></meta>
		</pressAnimation>
		<new public="1" set="method" line="13"><f a="imagePath:text">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterStrumlineScreen" params="" file="source/funkin/editors/charter/CharterStrumlineScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<strumLineID public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</strumLineID>
		<strumLine public="1"><t path="funkin.backend.chart.ChartStrumLine"/></strumLine>
		<charactersList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.CharacterButton"/></c></charactersList>
		<typeDropdown public="1"><c path="funkin.editors.ui.UIDropDown"/></typeDropdown>
		<vocalsSuffixDropDown public="1"><c path="funkin.editors.ui.UIDropDown"/></vocalsSuffixDropDown>
		<stagePositionDropdown public="1"><c path="funkin.editors.ui.UIDropDown"/></stagePositionDropdown>
		<hudScaleStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></hudScaleStepper>
		<hudXStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></hudXStepper>
		<hudYStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></hudYStepper>
		<visibleCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></visibleCheckbox>
		<scrollSpeedStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></scrollSpeedStepper>
		<usesChartscrollSpeed public="1"><c path="funkin.editors.ui.UICheckbox"/></usesChartscrollSpeed>
		<characterIcons public="1" expr="[]">
			<c path="Array"><c path="funkin.game.HealthIcon"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</characterIcons>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<onSave expr="null">
			<f a="">
				<t path="funkin.backend.chart.ChartStrumLine"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onSave>
		<create public="1" set="method" line="38" override="1"><f a=""><x path="Void"/></f></create>
		<saveStrumline set="method" line="163"><f a=""><x path="Void"/></f></saveStrumline>
		<new public="1" set="method" line="31"><f a="strumLineID:strumLine:?onSave">
	<x path="Int"/>
	<t path="funkin.backend.chart.ChartStrumLine"/>
	<f a="">
		<t path="funkin.backend.chart.ChartStrumLine"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharacterButton" params="" file="source/funkin/editors/charter/CharterStrumlineScreen.hx" module="funkin.editors.charter.CharterStrumlineScreen">
		<extends path="funkin.editors.ui.UIButton"/>
		<charIcon public="1"><c path="funkin.game.HealthIcon"/></charIcon>
		<textBox public="1"><c path="funkin.editors.ui.UIAutoCompleteTextBox"/></textBox>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<update public="1" set="method" line="227" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="192"><f a="x:y:char:charsList:parent">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.CharacterButton"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterWaveformHandler" params="" file="source/funkin/editors/charter/CharterWaveformHandler.hx">
		<extends path="flixel.FlxBasic"/>
		<ampsNeeded public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ampsNeeded>
		<ampSqrt public="1" get="accessor" set="null"><x path="Int"/></ampSqrt>
		<get_ampSqrt public="1" set="method" line="12"><f a=""><x path="Int"/></f></get_ampSqrt>
		<waveDatas public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="openfl.display.BitmapData"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</waveDatas>
		<waveShaders public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.backend.shaders.CustomShader"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</waveShaders>
		<sounds public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="flixel.sound.FlxSound"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</sounds>
		<analyzers public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.backend.utils.AudioAnalyzer"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</analyzers>
		<waveformList public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</waveformList>
		<generateData public="1" set="method" line="29"><f a="name:sound">
	<c path="String"/>
	<c path="flixel.sound.FlxSound"/>
	<c path="openfl.display.BitmapData"/>
</f></generateData>
		<generateShader public="1" set="method" line="65"><f a="name:sound">
	<c path="String"/>
	<c path="flixel.sound.FlxSound"/>
	<c path="funkin.backend.shaders.CustomShader"/>
</f></generateShader>
		<clearWaveform public="1" set="method" line="81"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></clearWaveform>
		<clearWaveforms public="1" set="method" line="95"><f a=""><x path="Void"/></f></clearWaveforms>
		<destroy public="1" set="method" line="106" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.charter.SongCreationData" params="" file="source/funkin/editors/charter/SongCreationScreen.hx" module="funkin.editors.charter.SongCreationScreen"><a>
	<voicesBytes><c path="haxe.io.Bytes"/></voicesBytes>
	<meta><t path="funkin.backend.chart.ChartMetaData"/></meta>
	<instBytes><c path="haxe.io.Bytes"/></instBytes>
</a></typedef>
	<class path="funkin.editors.charter.SongCreationScreen" params="" file="source/funkin/editors/charter/SongCreationScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<onSave expr="null">
			<f a="">
				<x path="Null"><t path="funkin.editors.charter.SongCreationData"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onSave>
		<songNameTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></songNameTextBox>
		<bpmStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></bpmStepper>
		<beatsPerMeasureStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></beatsPerMeasureStepper>
		<stepsPerBeatStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></stepsPerBeatStepper>
		<needsVoicesCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></needsVoicesCheckbox>
		<instExplorer public="1"><c path="funkin.editors.ui.UIFileExplorer"/></instExplorer>
		<voicesExplorer public="1"><c path="funkin.editors.ui.UIFileExplorer"/></voicesExplorer>
		<displayNameTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></displayNameTextBox>
		<iconTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></iconTextBox>
		<iconSprite public="1"><c path="flixel.FlxSprite"/></iconSprite>
		<opponentModeCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></opponentModeCheckbox>
		<coopAllowedCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></coopAllowedCheckbox>
		<colorWheel public="1"><c path="funkin.editors.ui.UIColorwheel"/></colorWheel>
		<difficulitesTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></difficulitesTextBox>
		<backButton public="1"><c path="funkin.editors.ui.UIButton"/></backButton>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<songDataGroup public="1" expr="new FlxGroup()">
			<t path="flixel.group.FlxGroup"/>
			<meta><m n=":value"><e>new FlxGroup()</e></m></meta>
		</songDataGroup>
		<menuDataGroup public="1" expr="new FlxGroup()">
			<t path="flixel.group.FlxGroup"/>
			<meta><m n=":value"><e>new FlxGroup()</e></m></meta>
		</menuDataGroup>
		<pages public="1" expr="[]">
			<c path="Array"><t path="flixel.group.FlxGroup"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pages>
		<pageSizes public="1" expr="[]">
			<c path="Array"><x path="flixel.math.FlxPoint"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pageSizes>
		<curPage public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curPage>
		<create public="1" set="method" line="50" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="196" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<refreshPages set="method" line="208"><f a=""><x path="Void"/></f></refreshPages>
		<updatePagesTexts set="method" line="213"><f a=""><x path="Void"/></f></updatePagesTexts>
		<updateIcon set="method" line="233"><f a="icon">
	<c path="String"/>
	<x path="Void"/>
</f></updateIcon>
		<saveSongInfo set="method" line="252"><f a=""><x path="Void"/></f></saveSongInfo>
		<new public="1" set="method" line="45"><f a="?onSave">
	<f a="">
		<t path="funkin.editors.charter.SongCreationData"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.extra.PropertyButton" params="" file="source/funkin/editors/extra/PropertyButton.hx">
		<extends path="funkin.editors.ui.UIButton"/>
		<propertyText public="1"><c path="funkin.editors.ui.UITextBox"/></propertyText>
		<valueText public="1"><c path="funkin.editors.ui.UITextBox"/></valueText>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<update public="1" set="method" line="26" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="9"><f a="property:value:parent">
	<c path="String"/>
	<c path="String"/>
	<a><remove set="null"><f a="">
	<c path="funkin.editors.extra.PropertyButton"/>
	<x path="Void"/>
</f></remove></a>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.IUIFocusable" params="" file="source/funkin/editors/ui/IUIFocusable.hx" interface="1">
		<onKeyDown public="1" set="method"><f a="e:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyDown>
		<onKeyUp public="1" set="method"><f a="e:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyUp>
		<onTextInput public="1" set="method"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></onTextInput>
		<onTextEdit public="1" set="method"><f a="text:start:end">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onTextEdit>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIAudioPlayer" params="" file="source/funkin/editors/ui/UIAudioPlayer.hx">
		<extends path="funkin.editors.ui.UIButton"/>
		<sound public="1"><c path="flixel.sound.FlxSound"/></sound>
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<playingSprite public="1"><c path="flixel.FlxSprite"/></playingSprite>
		<timeText public="1"><c path="funkin.editors.ui.UIText"/></timeText>
		<timeBar public="1"><c path="flixel.ui.FlxBar"/></timeBar>
		<timeBarPlayer public="1"><c path="flixel.FlxSprite"/></timeBarPlayer>
		<timeBarSpr public="1"><c path="funkin.editors.ui.UISprite"/></timeBarSpr>
		<volumeIcon public="1"><c path="flixel.FlxSprite"/></volumeIcon>
		<volumeBar public="1"><c path="flixel.ui.FlxBar"/></volumeBar>
		<volumeBarSpr public="1"><c path="funkin.editors.ui.UISprite"/></volumeBarSpr>
		<draggingObj public="1" expr="null">
			<c path="flixel.ui.FlxBar"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</draggingObj>
		<wasPlaying public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</wasPlaying>
		<nextPlayerColor public="1" expr="0x440364">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0x440364</e></m></meta>
		</nextPlayerColor>
		<update public="1" set="method" line="83" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="136" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="29"><f a="x:y:bytes">
	<x path="Float"/>
	<x path="Float"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UITextBox" params="" file="source/funkin/editors/ui/UITextBox.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<implements path="funkin.editors.ui.IUIFocusable"/>
		<label public="1"><c path="funkin.editors.ui.UIText"/></label>
		<position public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</position>
		<multiline public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</multiline>
		<caretSpr public="1"><c path="flixel.FlxSprite"/></caretSpr>
		<onChange public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></onChange>
		<__wasFocused expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__wasFocused>
		<cacheRect expr="new Rectangle()">
			<c path="openfl.geom.Rectangle"/>
			<meta><m n=":value"><e>new Rectangle()</e></m></meta>
		</cacheRect>
		<update public="1" set="method" line="39" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<onKeyDown public="1" set="method" line="103"><f a="e:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyDown>
		<changeSelection public="1" set="method" line="133"><f a="change">
	<x path="Int"/>
	<x path="Void"/>
</f></changeSelection>
		<onKeyUp public="1" set="method" line="136"><f a="e:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyUp>
		<onTextInput public="1" set="method" line="138"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></onTextInput>
		<onTextEdit public="1" set="method" line="143"><f a="text:start:end">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onTextEdit>
		<new public="1" set="method" line="20">
			<f a="x:y:?text:?width:?height:?multiline" v="::&quot;&quot;:320:32:false">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ multiline : false, height : 32, width : 320, text : "" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIAutoCompleteTextBox" params="" file="source/funkin/editors/ui/UIAutoCompleteTextBox.hx">
		<extends path="funkin.editors.ui.UITextBox"/>
		<suggestionText public="1"><c path="funkin.editors.ui.UIText"/></suggestionText>
		<suggestItems public="1" set="accessor" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</suggestItems>
		<suggestIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</suggestIndex>
		<update public="1" set="method" line="21" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<onKeyDown public="1" set="method" line="31" override="1"><f a="e:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyDown>
		<_suggestions expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_suggestions>
		<updateSuggestion public="1" set="method" line="57">
			<f a="?refreshSuggestions" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ refreshSuggestions : true }</e></m></meta>
		</updateSuggestion>
		<onTextInput public="1" set="method" line="79" override="1"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></onTextInput>
		<onTextEdit public="1" set="method" line="85" override="1"><f a="text:start:end">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onTextEdit>
		<set_suggestItems set="method" line="91"><f a="v">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><c path="String"/></c>
</f></set_suggestItems>
		<new public="1" set="method" line="12">
			<f a="x:y:?text:?width:?height:?multiline" v="::&quot;&quot;:320:32:false">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ multiline : false, height : 32, width : 320, text : "" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIBackdrop" params="" file="source/funkin/editors/ui/UIBackdrop.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<draw public="1" set="method" line="6" override="1"><f a=""><x path="Void"/></f></draw>
		<destroy public="1" set="method" line="37" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="5"><f a="?X:?Y:?SimpleGraphic">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Null"><t path="flixel.system.FlxGraphicAsset"/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="funkin.editors.ui.UIButtonList" params="T" file="source/funkin/editors/ui/UIButtonList.hx">
		<extends path="funkin.editors.ui.UIWindow"/>
		<buttons public="1" expr="new FlxTypedGroup&lt;T&gt;()">
			<c path="flixel.group.FlxTypedGroup"><c path="funkin.editors.ui.UIButtonList.T"/></c>
			<meta><m n=":value"><e>new FlxTypedGroup&lt;T&gt;()</e></m></meta>
		</buttons>
		<addButton public="1"><c path="funkin.editors.ui.UIButton"/></addButton>
		<addIcon public="1"><c path="flixel.FlxSprite"/></addIcon>
		<buttonCameras public="1"><c path="flixel.FlxCamera"/></buttonCameras>
		<cameraSpacing public="1" expr="30">
			<x path="Int"/>
			<meta><m n=":value"><e>30</e></m></meta>
		</cameraSpacing>
		<buttonSpacing public="1" expr="16">
			<x path="Float"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</buttonSpacing>
		<buttonSize public="1" expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</buttonSize>
		<buttonOffset public="1" expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</buttonOffset>
		<dragging public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</dragging>
		<dragCallback public="1"><f a="::">
	<c path="funkin.editors.ui.UIButtonList.T"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></dragCallback>
		<curMoving expr="null">
			<c path="funkin.editors.ui.UIButtonList.T"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curMoving>
		<curMovingInterval expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curMovingInterval>
		<add public="1" get="inline" set="null" line="50"><f a="button">
	<c path="funkin.editors.ui.UIButtonList.T"/>
	<x path="Void"/>
</f></add>
		<insert public="1" get="inline" set="null" line="57"><f a="button:position">
	<c path="funkin.editors.ui.UIButtonList.T"/>
	<x path="Int"/>
	<x path="Void"/>
</f></insert>
		<remove public="1" get="inline" set="null" line="63"><f a="button">
	<c path="funkin.editors.ui.UIButtonList.T"/>
	<x path="Void"/>
</f></remove>
		<updateButtonsPos public="1" get="inline" set="null" line="69"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></updateButtonsPos>
		<nextscrollY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextscrollY>
		<update public="1" set="method" line="101" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="135" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="26"><f a="x:y:width:height:windowName:buttonSize:?buttonOffset:?buttonSpacing">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UICheckbox" params="" file="source/funkin/editors/ui/UICheckbox.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<checked public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</checked>
		<onChecked public="1" expr="null">
			<f a="">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onChecked>
		<field public="1"><c path="funkin.editors.ui.UIText"/></field>
		<check public="1"><c path="flixel.FlxSprite"/></check>
		<update public="1" set="method" line="28" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updatePositions public="1" get="inline" set="null" line="43"><f a=""><x path="Void"/></f></updatePositions>
		<draw public="1" set="method" line="48" override="1"><f a=""><x path="Void"/></f></draw>
		<onHovered public="1" set="method" line="53" override="1"><f a=""><x path="Void"/></f></onHovered>
		<updateButton public="1" set="method" line="67" override="1"><f a=""><x path="Void"/></f></updateButton>
		<new public="1" set="method" line="10">
			<f a="x:y:text:?checked:?w" v=":::false:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 0, checked : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIColorwheel" params="" file="source/funkin/editors/ui/UIColorwheel.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<hitBoxExtenstion get="inline" set="null" expr="8" line="126" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</hitBoxExtenstion>
		<colorPicker><c path="flixel.FlxSprite"/></colorPicker>
		<colorPickerShader><c path="funkin.backend.shaders.CustomShader"/></colorPickerShader>
		<colorPickerSelector><c path="funkin.editors.ui.UIColorWheelSelector"/></colorPickerSelector>
		<colorSlider><c path="flixel.FlxSprite"/></colorSlider>
		<colorSliderSelector><c path="funkin.editors.ui.UIColorWheelSelector"/></colorSliderSelector>
		<colorHexTextBox><c path="funkin.editors.ui.UITextBox"/></colorHexTextBox>
		<rgbNumSteppers expr="[]">
			<c path="Array"><c path="funkin.editors.ui.UINumericStepper"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</rgbNumSteppers>
		<curColor public="1"><x path="Null"><x path="flixel.util.FlxColor"/></x></curColor>
		<curColorString public="1" expr="&quot;#FFFFFF&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"#FFFFFF"</e></m></meta>
		</curColorString>
		<saturation public="1"><x path="Float"/></saturation>
		<brightness public="1"><x path="Float"/></brightness>
		<hue public="1"><x path="Float"/></hue>
		<updateColorPickerSelector get="inline" set="null" line="94"><f a=""><x path="Void"/></f></updateColorPickerSelector>
		<updateColorPickerMouse get="inline" set="null" line="96"><f a="mousePos">
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></updateColorPickerMouse>
		<updateColorSliderPickerSelector get="inline" set="null" line="101"><f a=""><x path="Void"/></f></updateColorSliderPickerSelector>
		<updateColorSliderMouse get="inline" set="null" line="104"><f a="mousePos">
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></updateColorSliderMouse>
		<updateWheel public="1" set="method" line="106">
			<f a="?checkChanged" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkChanged : true }</e></m></meta>
		</updateWheel>
		<colorChanged public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</colorChanged>
		<update public="1" set="method" line="128" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="27"><f a="x:y:?color">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIColorWheelSelector" params="" file="source/funkin/editors/ui/UIColorwheel.hx" module="funkin.editors.ui.UIColorwheel">
		<extends path="flixel.group.FlxTypedGroup"><c path="flixel.FlxSprite"/></extends>
		<curColor public="1" expr="FlxColor.WHITE">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>FlxColor.WHITE</e></m></meta>
		</curColor>
		<selector public="1"><c path="flixel.FlxSprite"/></selector>
		<colorCircle public="1"><c path="flixel.FlxSprite"/></colorCircle>
		<update public="1" set="method" line="171" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="160"><f a="x:y:?color">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIContextMenu" params="" file="source/funkin/editors/ui/UIContextMenu.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<options public="1"><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></options>
		<x><x path="Float"/></x>
		<y><x path="Float"/></y>
		<contextCam><c path="flixel.FlxCamera"/></contextCam>
		<bg><c path="funkin.editors.ui.UISliceSprite"/></bg>
		<callback><t path="funkin.editors.ui.UIContextMenuCallback"/></callback>
		<contextMenuOptions public="1" expr="[]">
			<c path="Array"><c path="funkin.editors.ui.UIContextMenuOptionSpr"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</contextMenuOptions>
		<separators public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxSprite"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</separators>
		<__oobDeletion expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__oobDeletion>
		<preventOutOfBoxClickDeletion public="1" get="inline" set="null" line="21"><f a=""><x path="Void"/></f></preventOutOfBoxClickDeletion>
		<create public="1" set="method" line="33" override="1"><f a=""><x path="Void"/></f></create>
		<select public="1" set="method" line="88"><f a="option">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></select>
		<update public="1" set="method" line="98" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="110" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="25"><f a="options:callback:x:y">
	<c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c>
	<t path="funkin.editors.ui.UIContextMenuCallback"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.ui.UIContextMenuCallback" params="" file="source/funkin/editors/ui/UIContextMenu.hx" module="funkin.editors.ui.UIContextMenu"><f a="::">
	<c path="funkin.editors.ui.UIContextMenu"/>
	<x path="Int"/>
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></typedef>
	<typedef path="funkin.editors.ui.UIContextMenuOption" params="" file="source/funkin/editors/ui/UIContextMenu.hx" module="funkin.editors.ui.UIContextMenu"><a>
	<onSelect>
		<x path="Null"><f a="">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</onSelect>
	<onCreate>
		<x path="Null"><f a="">
	<c path="funkin.editors.ui.UIContextMenuOptionSpr"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</onCreate>
	<label><c path="String"/></label>
	<keybinds>
		<x path="Null"><c path="Array"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></c></x>
		<meta><m n=":optional"/></meta>
	</keybinds>
	<keybindText>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</keybindText>
	<keybind>
		<x path="Null"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></x>
		<meta><m n=":optional"/></meta>
	</keybind>
	<icon>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</icon>
	<color>
		<x path="Null"><x path="flixel.util.FlxColor"/></x>
		<meta><m n=":optional"/></meta>
	</color>
	<closeOnSelect>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</closeOnSelect>
	<childs>
		<x path="Null"><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></x>
		<meta><m n=":optional"/></meta>
	</childs>
	<button>
		<x path="Null"><c path="funkin.editors.ui.UIContextMenuOptionSpr"/></x>
		<meta><m n=":optional"/></meta>
	</button>
</a></typedef>
	<class path="funkin.editors.ui.UIContextMenuOptionSpr" params="" file="source/funkin/editors/ui/UIContextMenu.hx" module="funkin.editors.ui.UIContextMenu">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<label public="1"><c path="funkin.editors.ui.UIText"/></label>
		<labelKeybind public="1"><c path="funkin.editors.ui.UIText"/></labelKeybind>
		<icon public="1"><c path="flixel.FlxSprite"/></icon>
		<option public="1"><t path="funkin.editors.ui.UIContextMenuOption"/></option>
		<parent><c path="funkin.editors.ui.UIContextMenu"/></parent>
		<draw public="1" set="method" line="183" override="1"><f a=""><x path="Void"/></f></draw>
		<onHovered public="1" set="method" line="195" override="1"><f a=""><x path="Void"/></f></onHovered>
		<new public="1" set="method" line="141"><f a="x:y:option:parent">
	<x path="Float"/>
	<x path="Float"/>
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<c path="funkin.editors.ui.UIContextMenu"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIDropDown" params="" file="source/funkin/editors/ui/UIDropDown.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<dropButton public="1"><c path="funkin.editors.ui.UIButton"/></dropButton>
		<label public="1"><c path="funkin.editors.ui.UIText"/></label>
		<index public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</index>
		<options public="1"><c path="Array"><c path="String"/></c></options>
		<onChange public="1"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></onChange>
		<curMenu expr="null">
			<c path="funkin.editors.ui.UIContextMenu"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curMenu>
		<setOption public="1" set="method" line="29"><f a="newIndex">
	<x path="Int"/>
	<x path="Void"/>
</f></setOption>
		<update public="1" set="method" line="37" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<openContextMenu public="1" set="method" line="53"><f a=""><x path="Void"/></f></openContextMenu>
		<new public="1" set="method" line="14">
			<f a="x:y:?width:?height:options:?index" v="::320:32::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ index : 0, height : 32, width : 320 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIFileExplorer" params="" file="source/funkin/editors/ui/UIFileExplorer.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<uploadButton public="1"><c path="funkin.editors.ui.UIButton"/></uploadButton>
		<uploadIcon public="1"><c path="flixel.FlxSprite"/></uploadIcon>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<file public="1" expr="null">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</file>
		<onFile public="1"><f a="">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></onFile>
		<uiElement public="1"><c path="funkin.editors.ui.UISprite"/></uiElement>
		<update public="1" set="method" line="50" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<removeFile public="1" set="method" line="63"><f a=""><x path="Void"/></f></removeFile>
		<new public="1" set="method" line="18">
			<f a="x:y:?w:?h:?fileType:?onFile" v="::::&quot;txt&quot;:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<f a="">
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fileType : "txt" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UINumericStepper" params="" file="source/funkin/editors/ui/UINumericStepper.hx">
		<extends path="funkin.editors.ui.UITextBox"/>
		<value public="1" set="accessor"><x path="Float"/></value>
		<precision public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</precision>
		<min public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</min>
		<max public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</max>
		<step public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</step>
		<__onChange set="method" line="25"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></__onChange>
		<set_value set="method" line="32"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_value>
		<new public="1" set="method" line="10">
			<f a="x:y:?value:?step:?precision:?min:?max:?w:?h" v="::0:1:0:::180:32">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : 32, w : 180, precision : 0, step : 1, value : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIScrollBar" params="" file="source/funkin/editors/ui/UIScrollBar.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<length public="1"><x path="Float"/></length>
		<start public="1"><x path="Float"/></start>
		<size public="1"><x path="Float"/></size>
		<thumb public="1"><c path="funkin.editors.ui.UISliceSprite"/></thumb>
		<thumbIcon public="1"><c path="flixel.FlxSprite"/></thumbIcon>
		<value public="1"><x path="Float"/></value>
		<onChange public="1"><f a="">
	<x path="Float"/>
	<x path="Void"/>
</f></onChange>
		<update public="1" set="method" line="35" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="17">
			<f a="x:y:length:start:size:?w:?h" v=":::::20:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 20 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.ui.SliderSegement" params="" file="source/funkin/editors/ui/UISlider.hx" module="funkin.editors.ui.UISlider"><a>
	<start><x path="Float"/></start>
	<size><x path="Float"/></size>
	<end><x path="Float"/></end>
</a></typedef>
	<class path="funkin.editors.ui.UISlider" params="" file="source/funkin/editors/ui/UISlider.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<segments public="1" expr="[]">
			<c path="Array"><t path="funkin.editors.ui.SliderSegement"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</segments>
		<barWidth public="1" expr="120">
			<x path="Int"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</barWidth>
		<progressbar public="1"><c path="funkin.editors.ui.UISprite"/></progressbar>
		<progressCentered public="1"><x path="Bool"/></progressCentered>
		<startText public="1"><c path="funkin.editors.ui.UIText"/></startText>
		<endText public="1"><c path="funkin.editors.ui.UIText"/></endText>
		<selectableBar public="1"><c path="funkin.editors.ui.UISprite"/></selectableBar>
		<selectableBarHighlight public="1"><c path="funkin.editors.ui.UISprite"/></selectableBarHighlight>
		<selectableHitbox public="1"><c path="funkin.editors.ui.UISprite"/></selectableHitbox>
		<value public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</value>
		<set_value public="1" set="method" line="28"><f a="newVal">
	<x path="Float"/>
	<x path="Float"/>
</f></set_value>
		<valueStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></valueStepper>
		<onChange public="1"><f a="">
	<x path="Float"/>
	<x path="Void"/>
</f></onChange>
		<__barProgress expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__barProgress>
		<visualProgress expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</visualProgress>
		<__stepperWidth expr="25">
			<x path="Int"/>
			<meta><m n=":value"><e>25</e></m></meta>
		</__stepperWidth>
		<update public="1" set="method" line="95" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<__calcValue set="method" line="129"><f a="progress">
	<x path="Float"/>
	<x path="Float"/>
</f></__calcValue>
		<__calcProgress set="method" line="141"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></__calcProgress>
		<new public="1" set="method" line="37">
			<f a="x:y:?width:value:segments:centered" v="::120:::">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><t path="funkin.editors.ui.SliderSegement"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ width : 120 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIText" params="" file="source/funkin/editors/ui/UIText.hx">
		<extends path="funkin.backend.FunkinText"/>
		<optimized public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</optimized>
		<applyBorderStyle public="1" set="method" line="25" override="1"><f a=""><x path="Void"/></f></applyBorderStyle>
		<new public="1" set="method" line="9">
			<f a="x:y:w:text:?size:?color:?outline" v="::::15:0xFFFFFFFF:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Null"><c path="String"/></x>
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ outline : true, color : 0xFFFFFFFF, size : 15 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UITopMenu" params="" file="source/funkin/editors/ui/UITopMenu.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<options><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></options>
		<anyMenuOpened public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</anyMenuOpened>
		<update public="1" set="method" line="22" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="7"><f a="options">
	<c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIUtil" params="" file="source/funkin/editors/ui/UIUtil.hx">
		<follow public="1" set="method" line="7" static="1">
			<f a="spr:target:?x:?y" v="::0:0">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</follow>
		<contextMenuOpened public="1" set="method" line="13" static="1"><f a="contextMenu">
	<c path="funkin.editors.ui.UIContextMenu"/>
	<x path="Bool"/>
</f></contextMenuOpened>
		<processShortcuts public="1" set="method" line="21" static="1">
			<f a="topMenuOptions">
				<c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Process all options with shortcuts present in a `Array&lt;UIContextMenuOption&gt;`. Also checks childrens.
	 * @param topMenuOptions</haxe_doc>
		</processShortcuts>
		<toUIString public="1" set="method" line="81" static="1"><f a="key">
	<x path="flixel.input.keyboard.FlxKey"/>
	<c path="String"/>
</f></toUIString>
		<prettify public="1" get="inline" set="null" line="116" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></prettify>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIWarningSubstate" params="" file="source/funkin/editors/ui/UIWarningSubstate.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<camShaders expr="[]">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</camShaders>
		<blurShader expr="new CustomShader(Options.intensiveBlur ? &quot;engine/editorBlur&quot; : &quot;engine/editorBlurFast&quot;)">
			<c path="funkin.backend.shaders.CustomShader"/>
			<meta><m n=":value"><e>new CustomShader(Options.intensiveBlur ? "engine/editorBlur" : "engine/editorBlurFast")</e></m></meta>
		</blurShader>
		<title><c path="String"/></title>
		<message><c path="String"/></message>
		<buttons><c path="Array"><t path="funkin.editors.ui.WarningButton"/></c></buttons>
		<isError expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</isError>
		<titleSpr><c path="funkin.editors.ui.UIText"/></titleSpr>
		<messageSpr><c path="funkin.editors.ui.UIText"/></messageSpr>
		<warnCam><c path="flixel.FlxCamera"/></warnCam>
		<onSubstateOpen public="1" set="method" line="22" override="1"><f a=""><x path="Void"/></f></onSubstateOpen>
		<create public="1" set="method" line="28" override="1"><f a=""><x path="Void"/></f></create>
		<destroy public="1" set="method" line="95" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="104">
			<f a="title:message:buttons:?isError" v=":::true">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><t path="funkin.editors.ui.WarningButton"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isError : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.ui.WarningButton" params="" file="source/funkin/editors/ui/UIWarningSubstate.hx" module="funkin.editors.ui.UIWarningSubstate"><a>
	<onClick><f a="">
	<c path="funkin.editors.ui.UIWarningSubstate"/>
	<x path="Void"/>
</f></onClick>
	<label><c path="String"/></label>
	<color>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</color>
</a></typedef>
	<class path="funkin.game.Character" params="" file="source/funkin/game/Character.hx">
		<extends path="funkin.backend.FunkinSprite"/>
		<implements path="funkin.backend.system.interfaces.IOffsetCompatible"/>
		<implements path="funkin.backend.system.interfaces.IBeatReceiver"/>
		<characterProperties public="1" expr="[&quot;x&quot;, &quot;y&quot;, &quot;sprite&quot;, &quot;scale&quot;, &quot;antialiasing&quot;, &quot;flipX&quot;, &quot;camx&quot;, &quot;camy&quot;, &quot;isPlayer&quot;, &quot;icon&quot;, &quot;color&quot;, &quot;gameOverChar&quot;, &quot;holdTime&quot;]" line="356" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["x", "y", "sprite", "scale", "antialiasing", "flipX", "camx", "camy", "isPlayer", "icon", "color", "gameOverChar", "holdTime"]</e></m></meta>
		</characterProperties>
		<characterAnimProperties public="1" expr="[&quot;name&quot;, &quot;anim&quot;, &quot;x&quot;, &quot;y&quot;, &quot;fps&quot;, &quot;loop&quot;, &quot;indices&quot;]" line="361" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["name", "anim", "x", "y", "fps", "loop", "indices"]</e></m></meta>
		</characterAnimProperties>
		<FALLBACK_CHARACTER public="1" expr="&quot;bf&quot;" line="462" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"bf"</e></m></meta>
		</FALLBACK_CHARACTER>
		<FALLBACK_DEAD_CHARACTER public="1" expr="&quot;bf-dead&quot;" line="463" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"bf-dead"</e></m></meta>
		</FALLBACK_DEAD_CHARACTER>
		<getXMLFromCharName public="1" set="method" line="464" static="1"><f a="character">
	<x path="flixel.util.typeLimit.OneOfTwo">
		<c path="String"/>
		<c path="funkin.game.Character"/>
	</x>
	<x path="haxe.xml.Access"/>
</f></getXMLFromCharName>
		<getIconFromCharName public="1" set="method" line="499" static="1"><f a="?character">
	<c path="String"/>
	<c path="String"/>
</f></getIconFromCharName>
		<getList public="1" set="method" line="510" static="1">
			<f a="?mods" v="false">
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ mods : false }</e></m></meta>
		</getList>
		<isPlayer public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isPlayer>
		<curCharacter public="1" expr="&quot;bf&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"bf"</e></m></meta>
		</curCharacter>
		<sprite public="1" expr="&quot;bf&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"bf"</e></m></meta>
		</sprite>
		<lastHit public="1" expr="Math.NEGATIVE_INFINITY">
			<x path="Float"/>
			<meta><m n=":value"><e>Math.NEGATIVE_INFINITY</e></m></meta>
		</lastHit>
		<holdTime public="1" expr="4">
			<x path="Float"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</holdTime>
		<playerOffsets public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</playerOffsets>
		<icon public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</icon>
		<iconColor public="1" expr="null">
			<x path="Null"><x path="flixel.util.FlxColor"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</iconColor>
		<gameOverCharacter public="1" expr="Character.FALLBACK_DEAD_CHARACTER">
			<c path="String"/>
			<meta><m n=":value"><e>Character.FALLBACK_DEAD_CHARACTER</e></m></meta>
		</gameOverCharacter>
		<cameraOffset public="1" expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</cameraOffset>
		<globalOffset public="1" expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</globalOffset>
		<xml public="1"><x path="haxe.xml.Access"/></xml>
		<scripts public="1"><c path="funkin.backend.scripting.ScriptPack"/></scripts>
		<xmlImportedScripts public="1" expr="[]">
			<c path="Array"><c path="funkin.backend.utils.XMLImportedScriptInfo"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</xmlImportedScripts>
		<script public="1" set="accessor"><c path="funkin.backend.scripting.Script"/></script>
		<prepareInfos public="1" set="method" line="56"><f a="node">
	<x path="haxe.xml.Access"/>
	<c path="funkin.backend.utils.XMLImportedScriptInfo"/>
</f></prepareInfos>
		<idleSuffix public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</idleSuffix>
		<stunned public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</stunned>
		<__stunnedTime expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__stunnedTime>
		<__lockAnimThisFrame expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__lockAnimThisFrame>
		<__switchAnims expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__switchAnims>
		<__swappedLeftRightAnims expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__swappedLeftRightAnims>
		<__autoInterval expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__autoInterval>
		<fixChar public="1" set="method" line="96">
			<f a="?switchAnims:?autoInterval" v="false:false">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ autoInterval : false, switchAnims : false }</e></m></meta>
		</fixChar>
		<swapLeftRightAnimations public="1" set="method" line="110"><f a=""><x path="Void"/></f></swapLeftRightAnimations>
		<__baseFlipped expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__baseFlipped>
		<isDanceLeftDanceRight expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</isDanceLeftDanceRight>
		<update public="1" set="method" line="123" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<danced expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</danced>
		<dance public="1" set="method" line="140"><f a=""><x path="Void"/></f></dance>
		<tryDance public="1" set="method" line="153"><f a=""><x path="Void"/></f></tryDance>
		<danceOnBeat public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the character should dance on beat or not. Set to false for `gf`, since the dance animation is automatically handled by PlayState.</haxe_doc>
		</danceOnBeat>
		<beatHit public="1" set="method" line="173" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method" line="181" override="1"><f a="curStep">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<__reverseDrawProcedure expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__reverseDrawProcedure>
		<getScreenBounds public="1" set="method" line="184" override="1"><f a="?newRect:?camera">
	<c path="flixel.math.FlxRect"/>
	<c path="flixel.FlxCamera"/>
	<c path="flixel.math.FlxRect"/>
</f></getScreenBounds>
		<isOnScreen public="1" set="method" line="194" override="1"><f a="?camera">
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></isOnScreen>
		<isFlippedOffsets public="1" set="method" line="200"><f a=""><x path="Bool"/></f></isFlippedOffsets>
		<draw public="1" set="method" line="202" override="1"><f a=""><x path="Void"/></f></draw>
		<singAnims public="1" expr="[&quot;singLEFT&quot;, &quot;singDOWN&quot;, &quot;singUP&quot;, &quot;singRIGHT&quot;]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["singLEFT", "singDOWN", "singUP", "singRIGHT"]</e></m></meta>
		</singAnims>
		<playSingAnim public="1" set="method" line="217">
			<f a="direction:?suffix:?Context:?Force:?Reversed:?Frame" v=":&quot;&quot;:SING:null:false:0">
				<x path="Int"/>
				<c path="String"/>
				<x path="funkin.backend.scripting.events.PlayAnimContext"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Frame : 0, Reversed : false, Force : null, Context : SING, suffix : "" }</e></m></meta>
		</playSingAnim>
		<playAnim public="1" set="method" line="224" override="1">
			<f a="AnimName:?Force:?Context:?Reversed:?Frame" v="::NONE:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="funkin.backend.scripting.events.PlayAnimContext"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Frame : 0, Reversed : false, Context : NONE }</e></m></meta>
		</playAnim>
		<getCameraPosition public="1" get="inline" set="null" line="236"><f a=""><x path="flixel.math.FlxPoint"/></f></getCameraPosition>
		<destroy public="1" set="method" line="247" override="1"><f a=""><x path="Void"/></f></destroy>
		<__reverseTrailProcedure expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__reverseTrailProcedure>
		<beforeTrailCache public="1" set="dynamic" line="260"><f a=""><x path="Void"/></f></beforeTrailCache>
		<afterTrailCache public="1" set="dynamic" line="268"><f a=""><x path="Void"/></f></afterTrailCache>
		<applyXML public="1" set="method" line="274"><f a="xml">
	<x path="haxe.xml.Access"/>
	<x path="Void"/>
</f></applyXML>
		<buildCharacter public="1" get="inline" set="null" line="290"><f a="xml">
	<x path="haxe.xml.Access"/>
	<x path="Void"/>
</f></buildCharacter>
		<buildXML public="1" get="inline" set="null" line="365"><f a="?animsOrder">
	<c path="Array"><c path="String"/></c>
	<c path="Xml"/>
</f></buildXML>
		<getIcon public="1" get="inline" set="null" line="427"><f a=""><c path="String"/></f></getIcon>
		<getAnimOrder public="1" set="method" line="430"><f a=""><c path="Array"><c path="String"/></c></f></getAnimOrder>
		<set_stunned set="method" line="432">
			<f a="b">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_stunned>
		<danceInterval public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</danceInterval>
		<set_danceInterval set="method" line="441">
			<f a="v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_danceInterval>
		<get_danceInterval set="method" line="443">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_danceInterval>
		<set_script set="method" line="445"><f a="script">
	<c path="funkin.backend.scripting.Script"/>
	<c path="funkin.backend.scripting.Script"/>
</f></set_script>
		<new public="1" set="method" line="66">
			<f a="x:y:?character:?isPlayer:?switchAnims:?disableScripts" v="::&quot;bf&quot;:false:true:false">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ disableScripts : false, switchAnims : true, isPlayer : false, character : "bf" }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.desktop.editors.CharacterEditor</e></m>
			<m n=":allow"><e>funkin.game.StrumLine</e></m>
			<m n=":allow"><e>funkin.game.PlayState</e></m>
		</meta>
	</class>
	<class path="funkin.game.GameOverSubstate" params="" file="source/funkin/game/GameOverSubstate.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<script public="1" expr="&quot;&quot;" line="27" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</script>
		<character><c path="funkin.game.Character"/></character>
		<characterName public="1"><c path="String"/></characterName>
		<gameOverSong public="1"><c path="String"/></gameOverSong>
		<gameOverSongBPM public="1"><x path="Float"/></gameOverSongBPM>
		<lossSFXName public="1"><c path="String"/></lossSFXName>
		<retrySFX public="1"><c path="String"/></retrySFX>
		<player public="1"><x path="Bool"/></player>
		<camFollow><c path="flixel.FlxObject"/></camFollow>
		<gameoverScript public="1"><c path="funkin.backend.scripting.Script"/></gameoverScript>
		<game public="1" expr="PlayState.instance">
			<c path="funkin.game.PlayState"/>
			<meta><m n=":value"><e>PlayState.instance</e></m></meta>
		</game>
		<__cancelDefault expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__cancelDefault>
		<x expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<lossSFX public="1"><c path="flixel.sound.FlxSound"/></lossSFX>
		<create public="1" set="method" line="52" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="95" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<beatHit public="1" set="method" line="136" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method" line="149" override="1"><f a="curStep">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<isEnding expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isEnding>
		<endBullshit set="method" line="157"><f a=""><x path="Void"/></f></endBullshit>
		<destroy public="1" set="method" line="196" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="39">
			<f a="x:y:?character:?player:?gameOverSong:?lossSFX:?retrySFX" v="::&quot;bf-dead&quot;:true:&quot;gameOver&quot;:&quot;gameOverSFX&quot;:&quot;gameOverEnd&quot;">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ retrySFX : "gameOverEnd", lossSFX : "gameOverSFX", gameOverSong : "gameOver", player : true, character : "bf-dead" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.HealthIcon" params="" file="source/funkin/game/HealthIcon.hx">
		<extends path="flixel.FlxSprite"/>
		<sprTracker public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Used for FreeplayState! If you use it elsewhere, prob gonna annoying</haxe_doc>
		</sprTracker>
		<curCharacter public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The currently showing icon</haxe_doc>
		</curCharacter>
		<isPlayer public="1">
			<x path="Bool"/>
			<haxe_doc>* If the character is for the player</haxe_doc>
		</isPlayer>
		<healthSteps public="1" expr="null">
			<t path="Map">
				<x path="Int"/>
				<x path="Int"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Health steps in this format:
	 * Min Percentage =&gt; Frame Index</haxe_doc>
		</healthSteps>
		<setHealthSteps public="1" set="method" line="31">
			<f a="steps">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper for HScript who can't make maps
	 * @param steps Something like this: `[[0, 1], [20, 0]]`</haxe_doc>
		</setHealthSteps>
		<setIcon public="1" set="method" line="56">
			<f a="char:?width:?height" v=":150:150">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 150, width : 150 }</e></m></meta>
		</setIcon>
		<update public="1" set="method" line="79" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="46">
			<f a="?char:?isPlayer" v="&quot;bf&quot;:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isPlayer : false, char : "bf" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.HudCamera" params="" file="source/funkin/game/HudCamera.hx">
		<extends path="flixel.FlxCamera"/>
		<downscroll public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</downscroll>
		<alterScreenPosition public="1" set="method" line="25" override="1"><f a="spr:pos">
	<c path="flixel.FlxObject"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="flixel.math.FlxPoint"/>
</f></alterScreenPosition>
		<new public="1" set="method" line="6"><f a="?X:?Y:?Width:?Height:?Zoom">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.Note" params="" file="source/funkin/game/Note.hx">
		<extends path="flixel.FlxSprite"/>
		<swagWidth public="1" expr="160 * 0.7" line="89" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>160 * 0.7</e></m></meta>
		</swagWidth>
		<__customNoteTypeExists expr="[]" line="91" static="1">
			<t path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__customNoteTypeExists>
		<customTypePathExists set="method" line="96" static="1"><f a="path">
	<c path="String"/>
	<x path="Null"><x path="Bool"/></x>
</f></customTypePathExists>
		<__notePosFrameOffset expr="new FlxPoint()" line="224" static="1">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</__notePosFrameOffset>
		<__posPoint expr="new FlxPoint()" line="225" static="1">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</__posPoint>
		<extra public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</extra>
		<strumTime public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</strumTime>
		<mustPress public="1" get="accessor" set="null"><x path="Bool"/></mustPress>
		<strumLine public="1" set="accessor"><c path="funkin.game.StrumLine"/></strumLine>
		<set_strumLine set="method" line="20"><f a="strLine">
	<c path="funkin.game.StrumLine"/>
	<c path="funkin.game.StrumLine"/>
</f></set_strumLine>
		<get_mustPress set="method" line="30"><f a=""><x path="Bool"/></f></get_mustPress>
		<noteData public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</noteData>
		<canBeHit public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</canBeHit>
		<tooLate public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</tooLate>
		<wasGoodHit public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</wasGoodHit>
		<avoid public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever that note should be avoided by Botplay.</haxe_doc>
		</avoid>
		<prevNote public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>* The note that comes before this one (sustain and not)</haxe_doc>
		</prevNote>
		<nextNote public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>* The note that comes after this one (sustain and not)</haxe_doc>
		</nextNote>
		<nextSustain public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>* The next sustain after this one</haxe_doc>
		</nextSustain>
		<splash public="1" expr="&quot;default&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"default"</e></m></meta>
			<haxe_doc>* Name of the splash.</haxe_doc>
		</splash>
		<strumID public="1" get="accessor" set="null"><x path="Int"/></strumID>
		<get_strumID set="method" line="62"><f a=""><x path="Int"/></f></get_strumID>
		<sustainLength public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</sustainLength>
		<isSustainNote public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isSustainNote>
		<flipSustain public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</flipSustain>
		<noteTypeID public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</noteTypeID>
		<scrollSpeed public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</scrollSpeed>
		<noteAngle public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</noteAngle>
		<noteType public="1" get="accessor" set="null"><c path="String"/></noteType>
		<__strumCameras public="1" expr="null">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__strumCameras>
		<__strum public="1" expr="null">
			<c path="funkin.game.Strum"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__strum>
		<__noteAngle public="1" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__noteAngle>
		<get_noteType set="method" line="84"><f a=""><c path="String"/></f></get_noteType>
		<animSuffix public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</animSuffix>
		<lastScrollSpeed public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastScrollSpeed>
		<angleOffsets public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</angleOffsets>
		<gapFix public="1" expr="0">
			<x path="Single"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</gapFix>
		<useAntialiasingFix public="1" get="accessor" set="accessor"><x path="Bool"/></useAntialiasingFix>
		<set_useAntialiasingFix get="inline" set="null" line="197"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useAntialiasingFix>
		<get_useAntialiasingFix get="inline" set="null" line="203"><f a=""><x path="Bool"/></f></get_useAntialiasingFix>
		<strumRelativePos public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the position of the note should be relative to the strum position or not.
	 * For example, if this is true, a note at the position 0; 0 will be on the strum, instead of at the top left of the screen.</haxe_doc>
		</strumRelativePos>
		<drawComplex set="method" line="213" override="1"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></drawComplex>
		<draw public="1" set="method" line="227" override="1"><f a=""><x path="Void"/></f></draw>
		<earlyPressWindow public="1" expr="0.5">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</earlyPressWindow>
		<latePressWindow public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</latePressWindow>
		<updateSustain public="1" set="method" line="268"><f a="strum">
	<c path="funkin.game.Strum"/>
	<x path="Void"/>
</f></updateSustain>
		<setClipRect public="1" set="method" line="293"><f a="rect">
	<c path="flixel.math.FlxRect"/>
	<x path="Void"/>
</f></setClipRect>
		<set_clipRect set="method" line="299" override="1">
			<f a="rect">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_clipRect>
		<destroy public="1" set="method" line="308" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="101">
			<f a="strumLine:noteData:?sustain:?sustainLength:?sustainOffset:?prev" v="::false:0:0:">
				<c path="funkin.game.StrumLine"/>
				<t path="funkin.backend.chart.ChartNote"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="funkin.game.Note"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sustainOffset : 0, sustainLength : 0, sustain : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.game.PlayState</e></m>
		</meta>
	</class>
	<class path="funkin.game.NoteGroup" params="" file="source/funkin/game/NoteGroup.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.game.Note"/></extends>
		<__loopSprite><c path="funkin.game.Note"/></__loopSprite>
		<i expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</i>
		<__currentlyLooping expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__currentlyLooping>
		<__time expr="-1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>-1.0</e></m></meta>
		</__time>
		<limit public="1" expr="1500">
			<x path="Float"/>
			<meta><m n=":value"><e>1500</e></m></meta>
			<haxe_doc>* How many ms it should show a note before it should be hit</haxe_doc>
		</limit>
		<preallocate public="1" get="inline" set="null" line="20">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Preallocates the members array with nulls, but if theres anything in the array already it clears it</haxe_doc>
		</preallocate>
		<addNotes public="1" get="inline" set="null" line="25"><f a="notes">
	<c path="Array"><c path="funkin.game.Note"/></c>
	<x path="Void"/>
</f></addNotes>
		<sortNotes public="1" get="inline" set="null" line="30"><f a=""><x path="Void"/></f></sortNotes>
		<__forcedSongPos public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__forcedSongPos>
		<__getSongPos get="inline" set="null" line="41">
			<f a=""><x path="Null"><x path="Float"/></x></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</__getSongPos>
		<update public="1" set="method" line="43" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="58" override="1"><f a=""><x path="Void"/></f></draw>
		<get public="1" set="method" line="83">
			<f a="id">
				<x path="Int"/>
				<c path="funkin.game.Note"/>
			</f>
			<haxe_doc>* Gets the correct order of notes</haxe_doc>
		</get>
		<forEach public="1" set="method" line="87" override="1">
			<f a="noteFunc:?recursive" v=":false">
				<f a="">
					<c path="funkin.game.Note"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : false }</e></m></meta>
		</forEach>
		<forEachAlive public="1" set="method" line="104" override="1">
			<f a="noteFunc:?recursive" v=":false">
				<f a="">
					<c path="funkin.game.Note"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : false }</e></m></meta>
		</forEachAlive>
		<remove public="1" set="method" line="111" override="1">
			<f a="Object:?Splice" v=":false">
				<c path="funkin.game.Note"/>
				<x path="Bool"/>
				<c path="funkin.game.Note"/>
			</f>
			<meta><m n=":value"><e>{ Splice : false }</e></m></meta>
		</remove>
		<new public="1" set="method" line="6"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.PlayState" params="" file="source/funkin/game/PlayState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<instance public="1" expr="null" line="44" static="1">
			<c path="funkin.game.PlayState"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Current PlayState instance.</haxe_doc>
		</instance>
		<SONG public="1" static="1">
			<t path="funkin.backend.chart.ChartData"/>
			<haxe_doc>* SONG DATA (Chart, Metadata)</haxe_doc>
		</SONG>
		<isStoryMode public="1" expr="false" line="53" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the song is being played in Story Mode.</haxe_doc>
		</isStoryMode>
		<storyWeek public="1" expr="null" line="57" static="1">
			<t path="funkin.menus.WeekData"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The week data of the current week</haxe_doc>
		</storyWeek>
		<storyPlaylist public="1" expr="[]" line="61" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* The remaining songs in the Story Mode playlist.</haxe_doc>
		</storyPlaylist>
		<difficulty public="1" expr="&quot;normal&quot;" line="65" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"normal"</e></m></meta>
			<haxe_doc>* The selected difficulty name</haxe_doc>
		</difficulty>
		<fromMods public="1" expr="false" line="69" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the week is coming from the mods folder or not.</haxe_doc>
		</fromMods>
		<chartingMode public="1" expr="false" line="73" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever Charting Mode has been enabled for this song.</haxe_doc>
		</chartingMode>
		<opponentMode public="1" expr="false" line="77" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the song has been started with opponent mode on.</haxe_doc>
		</opponentMode>
		<coopMode public="1" expr="false" line="81" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the song has been started with co-op mode on.</haxe_doc>
		</coopMode>
		<deathCounter public="1" expr="0" line="96" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Death counter on current week (or song if from freeplay).</haxe_doc>
		</deathCounter>
		<smoothTransitionData static="1">
			<t path="funkin.game.PlayStateTransitionData"/>
			<haxe_doc>* Previous cam follow.</haxe_doc>
		</smoothTransitionData>
		<campaignScore public="1" expr="0" line="343" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Score for the current week.</haxe_doc>
		</campaignScore>
		<campaignMisses public="1" expr="0" line="348" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Misses for the current week.</haxe_doc>
		</campaignMisses>
		<campaignAccuracy public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* Accuracy for the current week</haxe_doc>
		</campaignAccuracy>
		<campaignAccuracyTotal public="1" expr="0" line="355" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</campaignAccuracyTotal>
		<campaignAccuracyCount public="1" expr="0" line="356" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</campaignAccuracyCount>
		<daPixelZoom public="1" expr="6" line="379" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>6</e></m></meta>
			<haxe_doc>* Zoom for the pixel assets.</haxe_doc>
		</daPixelZoom>
		<seenCutscene public="1" expr="false" line="392" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the game has already played a specific cutscene for the current song. Check `startCutscene` for more details.</haxe_doc>
		</seenCutscene>
		<resetSongInfos public="1" set="method" line="981" static="1"><f a=""><x path="Void"/></f></resetSongInfos>
		<getSongChanges get="inline" set="null" line="1471" static="1"><f a=""><c path="Array"><e path="funkin.savedata.HighscoreChange"/></c></f></getSongChanges>
		<get_campaignAccuracy get="inline" set="null" line="1881" static="1"><f a=""><x path="Float"/></f></get_campaignAccuracy>
		<loadWeek public="1" set="method" line="1889" static="1">
			<f a="weekData:?difficulty" v=":&quot;normal&quot;">
				<t path="funkin.menus.WeekData"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ difficulty : "normal" }</e></m></meta>
			<haxe_doc>* Load a week into PlayState.
	 * @param weekData Week Data
	 * @param difficulty Week Difficulty</haxe_doc>
		</loadWeek>
		<loadSong public="1" set="method" line="1909" static="1">
			<f a="name:?difficulty:?opponentMode:?coopMode" v=":&quot;normal&quot;:false:false">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ coopMode : false, opponentMode : false, difficulty : "normal" }</e></m></meta>
			<haxe_doc>* Loads a song into PlayState
	 * @param name Song name
	 * @param difficulty Chart difficulty (if invalid, will load an empty chart)
	 * @param opponentMode Whenever opponent mode is on
	 * @param coopMode Whenever co-op mode is on.</haxe_doc>
		</loadSong>
		<__loadSong public="1" set="method" line="1922" static="1">
			<f a="name:difficulty">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* (INTERNAL) Loads a song without resetting story mode/opponent mode/coop mode values.
	 * @param name Song name
	 * @param difficulty Song difficulty</haxe_doc>
		</__loadSong>
		<scripts public="1">
			<c path="funkin.backend.scripting.ScriptPack"/>
			<haxe_doc>* Script Pack of all the scripts being ran.</haxe_doc>
		</scripts>
		<strumLines public="1" expr="new FlxTypedGroup&lt;StrumLine&gt;()">
			<c path="flixel.group.FlxTypedGroup"><c path="funkin.game.StrumLine"/></c>
			<meta><m n=":value"><e>new FlxTypedGroup&lt;StrumLine&gt;()</e></m></meta>
			<haxe_doc>* Array of all the players in the stage.</haxe_doc>
		</strumLines>
		<gameOverSong public="1" expr="&quot;gameOver&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"gameOver"</e></m></meta>
			<haxe_doc>* Game Over Song. (assets/music/gameOver.ogg)</haxe_doc>
		</gameOverSong>
		<lossSFX public="1" expr="&quot;gameOverSFX&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"gameOverSFX"</e></m></meta>
			<haxe_doc>* Game Over Song. (assets/sounds/gameOverSFX.ogg)</haxe_doc>
		</lossSFX>
		<retrySFX public="1" expr="&quot;gameOverEnd&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"gameOverEnd"</e></m></meta>
			<haxe_doc>* Game Over End SFX, used when retrying. (assets/sounds/gameOverEnd.ogg)</haxe_doc>
		</retrySFX>
		<stage public="1">
			<c path="funkin.game.Stage"/>
			<haxe_doc>* Current Stage.</haxe_doc>
		</stage>
		<validScore public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the score will save when you beat the song.</haxe_doc>
		</validScore>
		<canDie public="1" expr="!opponentMode &amp;&amp; !coopMode">
			<x path="Bool"/>
			<meta><m n=":value"><e>!opponentMode &amp;&amp; !coopMode</e></m></meta>
			<haxe_doc>* Whenever the player can die.</haxe_doc>
		</canDie>
		<ghostTapping public="1" expr="Options.ghostTapping">
			<x path="Bool"/>
			<meta><m n=":value"><e>Options.ghostTapping</e></m></meta>
			<haxe_doc>* Whenever Ghost Tapping is enabled.</haxe_doc>
		</ghostTapping>
		<canDadDie public="1" expr="opponentMode &amp;&amp; !coopMode">
			<x path="Bool"/>
			<meta><m n=":value"><e>opponentMode &amp;&amp; !coopMode</e></m></meta>
			<haxe_doc>* Whenever the opponent can die.</haxe_doc>
		</canDadDie>
		<scrollSpeed public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current scroll speed for all strums.
	 * To set a scroll speed for a specific strum, use `strum.scrollSpeed`.</haxe_doc>
		</scrollSpeed>
		<downscroll public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whenever the game is in downscroll or not. (Can be set)</haxe_doc>
		</downscroll>
		<set_downscroll set="method" line="140">
			<f a="v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</set_downscroll>
		<get_downscroll set="method" line="141">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</get_downscroll>
		<inst public="1">
			<c path="flixel.sound.FlxSound"/>
			<haxe_doc>* Instrumental sound (Inst.ogg).</haxe_doc>
		</inst>
		<vocals public="1">
			<c path="flixel.sound.FlxSound"/>
			<haxe_doc>* Vocals sound (Vocals.ogg).</haxe_doc>
		</vocals>
		<dad public="1" get="accessor" set="accessor">
			<c path="funkin.game.Character"/>
			<haxe_doc>* Dad character</haxe_doc>
		</dad>
		<gf public="1" get="accessor" set="accessor">
			<c path="funkin.game.Character"/>
			<haxe_doc>* Girlfriend character</haxe_doc>
		</gf>
		<boyfriend public="1" get="accessor" set="accessor">
			<c path="funkin.game.Character"/>
			<haxe_doc>* Boyfriend character</haxe_doc>
		</boyfriend>
		<strumLine public="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Strum line position</haxe_doc>
		</strumLine>
		<ratingNum public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Number of ratings.</haxe_doc>
		</ratingNum>
		<camFollow public="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Object defining the camera follow target.</haxe_doc>
		</camFollow>
		<playerStrums public="1" get="accessor" set="null">
			<c path="funkin.game.StrumLine"/>
			<haxe_doc>* Player strums.</haxe_doc>
		</playerStrums>
		<cpuStrums public="1" get="accessor" set="null">
			<c path="funkin.game.StrumLine"/>
			<haxe_doc>* CPU strums.</haxe_doc>
		</cpuStrums>
		<player public="1" get="accessor" set="accessor">
			<c path="funkin.game.StrumLine"/>
			<haxe_doc>* Shortcut to `playerStrums`.</haxe_doc>
		</player>
		<cpu public="1" get="accessor" set="accessor">
			<c path="funkin.game.StrumLine"/>
			<haxe_doc>* Shortcut to `cpuStrums`.</haxe_doc>
		</cpu>
		<splashHandler public="1">
			<c path="funkin.game.SplashHandler"/>
			<haxe_doc>* Note splashes container</haxe_doc>
		</splashHandler>
		<muteVocalsOnMiss public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the vocals should be muted when a note is missed.</haxe_doc>
		</muteVocalsOnMiss>
		<canAccessDebugMenus public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the player can press 7, 8 or 9 to access the debug menus.</haxe_doc>
		</canAccessDebugMenus>
		<allowGitaroo public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether or not to show the secret gitaroo pause.</haxe_doc>
		</allowGitaroo>
		<doIconBop public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether or not to bop the icons on beat.</haxe_doc>
		</doIconBop>
		<camZooming public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever cam zooming is enabled, enables on a note hit if not cancelled.</haxe_doc>
		</camZooming>
		<camZoomingInterval public="1" expr="4">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
			<haxe_doc>* Interval of cam zooming (beats).
	 * For example: if set to 4, the camera will zoom every 4 beats.</haxe_doc>
		</camZoomingInterval>
		<camZoomingStrength public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* How strong the cam zooms should be (defaults to 1)</haxe_doc>
		</camZoomingStrength>
		<maxCamZoom public="1" expr="1.35">
			<x path="Float"/>
			<meta><m n=":value"><e>1.35</e></m></meta>
			<haxe_doc>* Maximum amount of zoom for the camera.</haxe_doc>
		</maxCamZoom>
		<curSong public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
			<haxe_doc>* Current song name (lowercase)</haxe_doc>
		</curSong>
		<curStage public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* Current stage name</haxe_doc>
		</curStage>
		<gfSpeed public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Interval at which Girlfriend dances.</haxe_doc>
		</gfSpeed>
		<health public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Current health. Goes from 0 to maxHealth (defaults to 2)</haxe_doc>
		</health>
		<maxHealth public="1" get="accessor" set="accessor" expr="2">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>2</e></m>
				<m n=":isVar"/>
			</meta>
			<haxe_doc>* Maximum health the player can have. Defaults to 2.</haxe_doc>
		</maxHealth>
		<combo public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current combo.</haxe_doc>
		</combo>
		<comboBreaks public="1" expr="!Options.ghostTapping">
			<x path="Bool"/>
			<meta><m n=":value"><e>!Options.ghostTapping</e></m></meta>
			<haxe_doc>* Whenever the misses should show "Combo Breaks" instead of "Misses"</haxe_doc>
		</comboBreaks>
		<healthBarBG public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Health bar background.</haxe_doc>
		</healthBarBG>
		<healthBar public="1">
			<c path="flixel.ui.FlxBar"/>
			<haxe_doc>* Health bar.</haxe_doc>
		</healthBar>
		<generatedMusic public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the music has been generated.</haxe_doc>
		</generatedMusic>
		<startingSong public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the song is currently being started.</haxe_doc>
		</startingSong>
		<iconP1 public="1">
			<c path="funkin.game.HealthIcon"/>
			<haxe_doc>* Player's icon</haxe_doc>
		</iconP1>
		<iconP2 public="1">
			<c path="funkin.game.HealthIcon"/>
			<haxe_doc>* Opponent's icon</haxe_doc>
		</iconP2>
		<camHUD public="1">
			<c path="funkin.game.HudCamera"/>
			<haxe_doc>* Camera for the HUD (notes, misses).</haxe_doc>
		</camHUD>
		<camGame public="1">
			<c path="flixel.FlxCamera"/>
			<haxe_doc>* Camera for the game (stages, characters)</haxe_doc>
		</camGame>
		<songScore public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The player's current score.</haxe_doc>
		</songScore>
		<misses public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The player's amount of misses.</haxe_doc>
		</misses>
		<accuracy public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The player's accuracy (shortcut to `accuracyPressedNotes / totalAccuracyAmount`).</haxe_doc>
		</accuracy>
		<accuracyPressedNotes public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The number of pressed notes.</haxe_doc>
		</accuracyPressedNotes>
		<totalAccuracyAmount public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The total accuracy amount.</haxe_doc>
		</totalAccuracyAmount>
		<scoreTxt public="1">
			<c path="funkin.backend.FunkinText"/>
			<haxe_doc>* FunkinText that shows your score.</haxe_doc>
		</scoreTxt>
		<missesTxt public="1">
			<c path="funkin.backend.FunkinText"/>
			<haxe_doc>* FunkinText that shows your amount of misses.</haxe_doc>
		</missesTxt>
		<accuracyTxt public="1">
			<c path="funkin.backend.FunkinText"/>
			<haxe_doc>* FunkinText that shows your accuracy.</haxe_doc>
		</accuracyTxt>
		<defaultCamZoom public="1" expr="1.05">
			<x path="Float"/>
			<meta><m n=":value"><e>1.05</e></m></meta>
			<haxe_doc>* Camera zoom at which the game lerps to.</haxe_doc>
		</defaultCamZoom>
		<camGameZoomLerp public="1" expr="0.05">
			<x path="Float"/>
			<meta><m n=":value"><e>0.05</e></m></meta>
			<haxe_doc>* Speed at which the game camera zoom lerps to.</haxe_doc>
		</camGameZoomLerp>
		<defaultHudZoom public="1" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
			<haxe_doc>* Camera zoom at which the hud lerps to.</haxe_doc>
		</defaultHudZoom>
		<camHUDZoomLerp public="1" expr="0.05">
			<x path="Float"/>
			<meta><m n=":value"><e>0.05</e></m></meta>
			<haxe_doc>* Speed at which the hud camera zoom lerps to.</haxe_doc>
		</camHUDZoomLerp>
		<inCutscene public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the game is currently in a cutscene or not.</haxe_doc>
		</inCutscene>
		<playCutscenes public="1" expr="isStoryMode">
			<x path="Bool"/>
			<meta><m n=":value"><e>isStoryMode</e></m></meta>
			<haxe_doc>* Whenever the game should play the cutscenes. Defaults to whenever the game is currently in Story Mode or not.</haxe_doc>
		</playCutscenes>
		<cutscene public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Cutscene script path.</haxe_doc>
		</cutscene>
		<endCutscene public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* End cutscene script path.</haxe_doc>
		</endCutscene>
		<curRating public="1">
			<c path="funkin.game.ComboRating"/>
			<haxe_doc>* Last rating (may be null)</haxe_doc>
		</curRating>
		<startTimer public="1">
			<c path="flixel.util.FlxTimer"/>
			<haxe_doc>* Timer for the start countdown</haxe_doc>
		</startTimer>
		<events public="1" expr="[]">
			<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Remaining events</haxe_doc>
		</events>
		<curCameraTarget public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current camera target. -1 means no automatic camera targetting.</haxe_doc>
		</curCameraTarget>
		<introLength public="1" expr="5">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
			<haxe_doc>* Length of the intro countdown.</haxe_doc>
		</introLength>
		<introSprites public="1" expr="[null, &quot;game/ready&quot;, &quot;game/set&quot;, &quot;game/go&quot;]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[null, "game/ready", "game/set", "game/go"]</e></m></meta>
			<haxe_doc>* Array of sprites for the intro.</haxe_doc>
		</introSprites>
		<introSounds public="1" expr="[&quot;intro3&quot;, &quot;intro2&quot;, &quot;intro1&quot;, &quot;introGo&quot;]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["intro3", "intro2", "intro1", "introGo"]</e></m></meta>
			<haxe_doc>* Array of sounds for the intro.</haxe_doc>
		</introSounds>
		<paused public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the game is paused or not.</haxe_doc>
		</paused>
		<startedCountdown public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the countdown has started or not.</haxe_doc>
		</startedCountdown>
		<canPause public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the game can be paused or not.</haxe_doc>
		</canPause>
		<accFormat public="1" expr="new FlxTextFormat(0xFF888888, false, false, 0)">
			<c path="flixel.text.FlxTextFormat"/>
			<meta><m n=":value"><e>new FlxTextFormat(0xFF888888, false, false, 0)</e></m></meta>
			<haxe_doc>* Format for the accuracy rating.</haxe_doc>
		</accFormat>
		<endingSong public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the song is ending or not.</haxe_doc>
		</endingSong>
		<comboGroup public="1">
			<c path="funkin.backend.system.RotatingSpriteGroup"/>
			<haxe_doc>* Group containing all of the combo sprites.</haxe_doc>
		</comboGroup>
		<noteTypesArray public="1" expr="[null]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[null]</e></m></meta>
			<haxe_doc>* Array containing all of the note types names.</haxe_doc>
		</noteTypesArray>
		<hitWindow public="1" expr="Options.hitWindow">
			<x path="Float"/>
			<meta><m n=":value"><e>Options.hitWindow</e></m></meta>
			<haxe_doc>* Hit window, in milliseconds. Defaults to 250ms unless changed in options.
	 * Base game hit window is 175ms.</haxe_doc>
		</hitWindow>
		<_startCountdownCalled expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_startCountdownCalled>
		<_endSongCalled expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_endSongCalled>
		<__vocalOffsetViolation expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__vocalOffsetViolation>
		<get_accuracy set="method" line="475"><f a=""><x path="Float"/></f></get_accuracy>
		<set_accuracy set="method" line="479"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_accuracy>
		<comboRatings public="1" expr="[new ComboRating(0, &quot;F&quot;, 0xFFFF4444), new ComboRating(0.5, &quot;E&quot;, 0xFFFF8844), new ComboRating(0.7, &quot;D&quot;, 0xFFFFAA44), new ComboRating(0.8, &quot;C&quot;, 0xFFFFFF44), new ComboRating(0.85, &quot;B&quot;, 0xFFAAFF44), new ComboRating(0.9, &quot;A&quot;, 0xFF88FF44), new ComboRating(0.95, &quot;S&quot;, 0xFF44FFFF), new ComboRating(1, &quot;S++&quot;, 0xFF44FFFF)]">
			<c path="Array"><c path="funkin.game.ComboRating"/></c>
			<meta><m n=":value"><e>[new ComboRating(0, "F", 0xFFFF4444), new ComboRating(0.5, "E", 0xFFFF8844), new ComboRating(0.7, "D", 0xFFFFAA44), new ComboRating(0.8, "C", 0xFFFFFF44), new ComboRating(0.85, "B", 0xFFAAFF44), new ComboRating(0.9, "A", 0xFF88FF44), new ComboRating(0.95, "S", 0xFF44FFFF), new ComboRating(1, "S++", 0xFF44FFFF)]</e></m></meta>
			<haxe_doc>* All combo ratings.</haxe_doc>
		</comboRatings>
		<detailsText public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</detailsText>
		<detailsPausedText public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</detailsPausedText>
		<__cachedGraphics expr="[]">
			<c path="Array"><c path="flixel.graphics.FlxGraphic"/></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n=":unreflective"/>
			</meta>
		</__cachedGraphics>
		<updateRating public="1" set="method" line="507">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the rating.</haxe_doc>
		</updateRating>
		<get_maxHealth get="inline" set="null" line="521"><f a=""><x path="Float"/></f></get_maxHealth>
		<set_maxHealth set="method" line="522"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxHealth>
		<get_curStage get="inline" set="null" line="530"><f a=""><c path="String"/></f></get_curStage>
		<set_curStage get="inline" set="null" line="532"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></set_curStage>
		<create public="1" set="method" line="538" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</create>
		<createPost public="1" set="method" line="787" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</createPost>
		<updateDiscordPresence public="1" set="dynamic" line="807">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Function used to update Discord Presence.
	 * This function is dynamic, which means you can do `updateDiscordPresence = function() {}` in scripts.</haxe_doc>
		</updateDiscordPresence>
		<startCutscene public="1" set="method" line="816">
			<f a="?prefix:?cutsceneScriptPath:?callback:?checkSeen" v="&quot;&quot;:::false">
				<c path="String"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkSeen : false, prefix : "" }</e></m></meta>
			<haxe_doc>* Starts a cutscene.
	 * @param prefix Custom prefix. Using `midsong-` will require you to for example rename your video cutscene to `songs/song/midsong-cutscene.mp4` instead of `songs/song/cutscene.mp4`
	 * @param cutsceneScriptPath Optional: Custom script path.
	 * @param callback Callback called after the cutscene ended. If equals to `null`, `startCountdown` will be called.
	 * @param checkSeen Bool that by default is false, if true and `seenCutscene` is also true, it won't play the cutscene but directly call `callback` (PS: `seenCutscene` becomes true if the cutscene gets played and `checkSeen` was true)</haxe_doc>
		</startCutscene>
		<startCountdown public="1" set="method" line="856">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</startCountdown>
		<countdown public="1" set="method" line="880">
			<f a="swagCounter">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a fake countdown.</haxe_doc>
		</countdown>
		<startSong set="method" line="928">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</startSong>
		<destroy public="1" set="method" line="959" override="1"><f a=""><x path="Void"/></f></destroy>
		<generateSong set="method" line="987">
			<f a="?songData">
				<x path="Null"><t path="funkin.backend.chart.ChartData"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</generateSong>
		<sortByShit set="method" line="1022">
			<f a="Obj1:Obj2">
				<c path="funkin.game.Note"/>
				<c path="funkin.game.Note"/>
				<x path="Int"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</sortByShit>
		<generateStrums get="inline" set="null" line="1028">
			<f a="?amount" v="4">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ amount : 4 }</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</generateStrums>
		<openSubState public="1" set="method" line="1033" override="1">
			<f a="SubState">
				<c path="flixel.FlxSubState"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</openSubState>
		<closeSubState public="1" set="method" line="1059" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</closeSubState>
		<getIconRPC public="1" get="inline" set="null" line="1084">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns the Discord RPC icon.</haxe_doc>
		</getIconRPC>
		<onFocus public="1" set="method" line="1088" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onFocus>
		<onFocusLost public="1" set="method" line="1101" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onFocusLost>
		<resyncVocals set="method" line="1114">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</resyncVocals>
		<pauseGame public="1" set="method" line="1132">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pauses the game.</haxe_doc>
		</pauseGame>
		<saveWarn public="1" set="method" line="1153">
			<f a="?closingWindow" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ closingWindow : true }</e></m></meta>
		</saveWarn>
		<updateIconPositions set="method" line="1197"><f a=""><x path="Void"/></f></updateIconPositions>
		<updateRatingStuff set="method" line="1211"><f a=""><x path="Void"/></f></updateRatingStuff>
		<update public="1" set="method" line="1229" override="1">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</update>
		<draw public="1" set="method" line="1335" override="1"><f a=""><x path="Void"/></f></draw>
		<scrollSpeedTween public="1" expr="null">
			<c path="flixel.tweens.FlxTween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</scrollSpeedTween>
		<executeEvent public="1" set="method" line="1344"><f a="event">
	<t path="funkin.backend.chart.ChartEvent"/>
	<x path="Void"/>
</f></executeEvent>
		<__updateNote_event public="1" expr="null">
			<c path="funkin.backend.scripting.events.NoteUpdateEvent"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__updateNote_event>
		<gameOver public="1" set="method" line="1406">
			<f a="?character:?deathCharID:?gameOverSong:?lossSFX:?retrySFX">
				<c path="funkin.game.Character"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Forces a game over.
	 * @param character Character which died. Default to `boyfriend`.
	 * @param deathCharID Character ID (name) for game over. Default to whatever is specified in the character's XML.
	 * @param gameOverSong Song for the game over screen. Default to `this.gameOverSong` (`gameOver`)
	 * @param lossSFX SFX at the beginning of the game over (Mic drop). Default to `this.lossSFX` (`gameOverSFX`)
	 * @param retrySFX SFX played whenever the player retries. Defaults to `retrySFX` (`gameOverEnd`)</haxe_doc>
		</gameOver>
		<endSong public="1" set="method" line="1442">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Ends the song.</haxe_doc>
		</endSong>
		<nextSong public="1" set="method" line="1483">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Immediately switches to the next song, or goes back to the Story/Freeplay menu.</haxe_doc>
		</nextSong>
		<registerSmoothTransition public="1" set="method" line="1532"><f a=""><x path="Void"/></f></registerSmoothTransition>
		<keyShit get="inline" set="null" line="1546"><f a=""><x path="Void"/></f></keyShit>
		<noteMiss public="1" set="method" line="1559">
			<f a="strumLine:note:?direction:?player">
				<c path="funkin.game.StrumLine"/>
				<c path="funkin.game.Note"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Misses a note
	 * @param strumLine The strumline the miss happened on.
	 * @param note Note to miss.
	 * @param direction Specify a custom direction in case note is null.
	 * @param player Specify a custom player in case note is null.</haxe_doc>
		</noteMiss>
		<getNoteType public="1" set="method" line="1605">
			<f a="id">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</getNoteType>
		<goodNoteHit public="1" set="method" line="1614">
			<f a="strumLine:note">
				<c path="funkin.game.StrumLine"/>
				<c path="funkin.game.Note"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Hits a note
	 * @param note Note to hit.</haxe_doc>
		</goodNoteHit>
		<displayRating public="1" set="method" line="1700">
			<f a="myRating:?evt" v=":null">
				<c path="String"/>
				<c path="funkin.backend.scripting.events.NoteHitEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ evt : null }</e></m></meta>
		</displayRating>
		<displayCombo public="1" set="method" line="1724">
			<f a="?evt" v="null">
				<c path="funkin.backend.scripting.events.NoteHitEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ evt : null }</e></m></meta>
		</displayCombo>
		<deleteNote public="1" get="inline" set="null" line="1779"><f a="note">
	<c path="funkin.game.Note"/>
	<x path="Void"/>
</f></deleteNote>
		<stepHit public="1" set="method" line="1784" override="1">
			<f a="curStep">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</stepHit>
		<measureHit public="1" set="method" line="1791" override="1">
			<f a="curMeasure">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</measureHit>
		<beatHit public="1" set="method" line="1798" override="1">
			<f a="curBeat">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</beatHit>
		<addScript public="1" set="method" line="1820"><f a="file">
	<c path="String"/>
	<x path="Void"/>
</f></addScript>
		<get_player get="inline" set="null" line="1829"><f a=""><c path="funkin.game.StrumLine"/></f></get_player>
		<set_player get="inline" set="null" line="1831"><f a="s">
	<c path="funkin.game.StrumLine"/>
	<c path="funkin.game.StrumLine"/>
</f></set_player>
		<get_cpu get="inline" set="null" line="1834"><f a=""><c path="funkin.game.StrumLine"/></f></get_cpu>
		<set_cpu get="inline" set="null" line="1836"><f a="s">
	<c path="funkin.game.StrumLine"/>
	<c path="funkin.game.StrumLine"/>
</f></set_cpu>
		<get_boyfriend set="method" line="1838"><f a=""><c path="funkin.game.Character"/></f></get_boyfriend>
		<set_boyfriend set="method" line="1843"><f a="bf">
	<c path="funkin.game.Character"/>
	<c path="funkin.game.Character"/>
</f></set_boyfriend>
		<get_dad set="method" line="1848"><f a=""><c path="funkin.game.Character"/></f></get_dad>
		<set_dad set="method" line="1853"><f a="dad">
	<c path="funkin.game.Character"/>
	<c path="funkin.game.Character"/>
</f></set_dad>
		<get_gf set="method" line="1858"><f a=""><c path="funkin.game.Character"/></f></get_gf>
		<set_gf set="method" line="1863"><f a="gf">
	<c path="funkin.game.Character"/>
	<c path="funkin.game.Character"/>
</f></set_gf>
		<get_cpuStrums get="inline" set="null" line="1869"><f a=""><c path="funkin.game.StrumLine"/></f></get_cpuStrums>
		<get_playerStrums get="inline" set="null" line="1871"><f a=""><c path="funkin.game.StrumLine"/></f></get_playerStrums>
		<get_gfSpeed get="inline" set="null" line="1873"><f a=""><x path="Int"/></f></get_gfSpeed>
		<set_gfSpeed get="inline" set="null" line="1874"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_gfSpeed>
		<new public="1" set="method" line="39"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>flixel.text.FlxText.FlxTextFormatRange</e></m>
			<m n=":access"><e>funkin.game.StrumLine</e></m>
		</meta>
	</class>
	<class path="funkin.game.ComboRating" params="" file="source/funkin/game/PlayState.hx" module="funkin.game.PlayState" final="1">
		<percent public="1"><x path="Float"/></percent>
		<rating public="1"><c path="String"/></rating>
		<color public="1"><x path="flixel.util.FlxColor"/></color>
		<new public="1" set="method" line="1935"><f a="percent:rating:color">
	<x path="Float"/>
	<c path="String"/>
	<x path="flixel.util.FlxColor"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.game.PlayStateTransitionData" params="" file="source/funkin/game/PlayState.hx" module="funkin.game.PlayState"><a>
	<stage><c path="String"/></stage>
	<camZoom><x path="Float"/></camZoom>
	<camY><x path="Float"/></camY>
	<camX><x path="Float"/></camX>
	<camFollowY><x path="Float"/></camFollowY>
	<camFollowX><x path="Float"/></camFollowX>
</a></typedef>
	<class path="funkin.game.SplashGroup" params="" file="source/funkin/game/SplashGroup.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.backend.FunkinSprite"/></extends>
		<valid public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the splash group has successfully loaded or not.</haxe_doc>
		</valid>
		<xml public="1">
			<x path="haxe.xml.Access"/>
			<haxe_doc>* XML data for the note splashes.</haxe_doc>
		</xml>
		<animationNames public="1" expr="[]">
			<c path="Array"><c path="Array"><c path="String"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Animation names sorted by strum IDs.
	 * Use `getSplashAnim` to get one.</haxe_doc>
		</animationNames>
		<createSplash set="method" line="48"><f a="imagePath">
	<c path="String"/>
	<c path="funkin.backend.FunkinSprite"/>
</f></createSplash>
		<setupAnims set="method" line="59"><f a="xml:splash">
	<x path="haxe.xml.Access"/>
	<c path="funkin.backend.FunkinSprite"/>
	<x path="Void"/>
</f></setupAnims>
		<pregenerateSplashes set="method" line="88"><f a="splash">
	<c path="funkin.backend.FunkinSprite"/>
	<x path="Void"/>
</f></pregenerateSplashes>
		<getSplashAnim public="1" set="method" line="99"><f a="id">
	<x path="Int"/>
	<c path="String"/>
</f></getSplashAnim>
		<__splash><c path="funkin.backend.FunkinSprite"/></__splash>
		<showOnStrum public="1" set="method" line="107"><f a="strum">
	<c path="funkin.game.Strum"/>
	<c path="funkin.backend.FunkinSprite"/>
</f></showOnStrum>
		<new public="1" set="method" line="26">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new Splash group
	 * @param path Path to the splash data (xml)</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.SplashHandler" params="" file="source/funkin/game/SplashHandler.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.backend.FunkinSprite"/></extends>
		<grpMap public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.game.SplashGroup"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Map containing all of the splashes group.</haxe_doc>
		</grpMap>
		<getSplashGroup public="1" set="method" line="18">
			<f a="name">
				<c path="String"/>
				<x path="Null"><c path="funkin.game.SplashGroup"/></x>
			</f>
			<haxe_doc>* Returns a group of splashes, and creates it if it doesn't exist.
	 * @param path Path to the splashes XML (`Paths.xml('splashes/splash')`)</haxe_doc>
		</getSplashGroup>
		<destroy public="1" set="method" line="26" override="1"><f a=""><x path="Void"/></f></destroy>
		<_firstDraw expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</_firstDraw>
		<draw public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></draw>
		<__grp><c path="funkin.game.SplashGroup"/></__grp>
		<showSplash public="1" set="method" line="42"><f a="name:strum">
	<c path="String"/>
	<c path="funkin.game.Strum"/>
	<x path="Void"/>
</f></showSplash>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.Stage" params="" file="source/funkin/game/Stage.hx">
		<extends path="flixel.FlxBasic"/>
		<implements path="funkin.backend.system.interfaces.IBeatReceiver"/>
		<getList public="1" set="method" line="273" static="1">
			<f a="?mods" v="false">
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ mods : false }</e></m></meta>
		</getList>
		<stageName public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</stageName>
		<stageXML public="1"><x path="haxe.xml.Access"/></stageXML>
		<stagePath public="1"><c path="String"/></stagePath>
		<stageSprites public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</stageSprites>
		<stageScript public="1"><c path="funkin.backend.scripting.Script"/></stageScript>
		<state public="1"><c path="flixel.FlxState"/></state>
		<characterPoses public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.game.StageCharPos"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</characterPoses>
		<xmlImportedScripts public="1" expr="[]">
			<c path="Array"><c path="funkin.backend.utils.XMLImportedScriptInfo"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</xmlImportedScripts>
		<spritesParentFolder expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</spritesParentFolder>
		<getSprite public="1" set="method" line="29"><f a="name">
	<c path="String"/>
	<x path="Null"><c path="flixel.FlxSprite"/></x>
</f></getSprite>
		<setStagesSprites public="1" set="method" line="32"><f a="script">
	<c path="funkin.backend.scripting.Script"/>
	<x path="Void"/>
</f></setStagesSprites>
		<prepareInfos public="1" set="method" line="35"><f a="node">
	<x path="haxe.xml.Access"/>
	<c path="funkin.backend.utils.XMLImportedScriptInfo"/>
</f></prepareInfos>
		<__pushNcheckNode set="method" line="206">
			<f a="array:node">
				<c path="Array"><x path="haxe.xml.Access"/></c>
				<x path="haxe.xml.Access"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</__pushNcheckNode>
		<addCharPos public="1" set="method" line="212"><f a="name:node:?nonXMLInfo">
	<c path="String"/>
	<x path="haxe.xml.Access"/>
	<x path="Null"><t path="funkin.game.StageCharPosInfo"/></x>
	<c path="funkin.game.StageCharPos"/>
</f></addCharPos>
		<isCharFlipped public="1" get="inline" set="null" line="255">
			<f a="posName:?def" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ def : false }</e></m></meta>
		</isCharFlipped>
		<applyCharStuff public="1" set="method" line="257">
			<f a="char:posName:?id" v="::0">
				<c path="funkin.game.Character"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0 }</e></m></meta>
		</applyCharStuff>
		<beatHit public="1" set="method" line="267"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method" line="269"><f a="curStep">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<measureHit public="1" set="method" line="271"><f a="curMeasure">
	<x path="Int"/>
	<x path="Void"/>
</f></measureHit>
		<new public="1" set="method" line="37"><f a="stage:?state">
	<c path="String"/>
	<c path="flixel.FlxState"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.StageCharPos" params="" file="source/funkin/game/Stage.hx" module="funkin.game.Stage">
		<extends path="flixel.FlxObject"/>
		<charSpacingX public="1" expr="20">
			<x path="Float"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</charSpacingX>
		<charSpacingY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</charSpacingY>
		<camxoffset public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</camxoffset>
		<camyoffset public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</camyoffset>
		<skewX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewX>
		<skewY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewY>
		<alpha public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</alpha>
		<flipX public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</flipX>
		<scale public="1" expr="FlxPoint.get(1, 1)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(1, 1)</e></m></meta>
		</scale>
		<destroy public="1" set="method" line="302" override="1"><f a=""><x path="Void"/></f></destroy>
		<prepareCharacter public="1" set="method" line="307">
			<f a="char:?id" v=":0">
				<c path="funkin.game.Character"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0 }</e></m></meta>
		</prepareCharacter>
		<new public="1" set="method" line="296"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.game.StageCharPosInfo" params="" file="source/funkin/game/Stage.hx" module="funkin.game.Stage"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<scroll><x path="Float"/></scroll>
	<flip><x path="Bool"/></flip>
</a></typedef>
	<class path="funkin.game.Strum" params="" file="source/funkin/game/Strum.hx">
		<extends path="flixel.FlxSprite"/>
		<PIX180 final="1" public="1" set="null" expr="565.4866776461628" line="81" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>565.4866776461628</e></m>
				<m n=":noCompletion"/>
			</meta>
		</PIX180>
		<N_WIDTHDIV2 final="1" public="1" set="null" expr="Note.swagWidth / 2" line="82" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>Note.swagWidth / 2</e></m>
				<m n=":noCompletion"/>
			</meta>
		</N_WIDTHDIV2>
		<extra public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</extra>
		<animSuffix public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
			<haxe_doc>* Which animation suffix on characters that should be used when hitting notes.</haxe_doc>
		</animSuffix>
		<cpu public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</cpu>
		<lastHit public="1" expr="-5000">
			<x path="Float"/>
			<meta><m n=":value"><e>-5000</e></m></meta>
		</lastHit>
		<scrollSpeed public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</scrollSpeed>
		<noteAngle public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</noteAngle>
		<lastDrawCameras public="1" set="null" expr="[]">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</lastDrawCameras>
		<getPressed public="1" expr="null">
			<f a="">
				<c path="funkin.game.StrumLine"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</getPressed>
		<getJustPressed public="1" expr="null">
			<f a="">
				<c path="funkin.game.StrumLine"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</getJustPressed>
		<getJustReleased public="1" expr="null">
			<f a="">
				<c path="funkin.game.StrumLine"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</getJustReleased>
		<__getPressed public="1" get="inline" set="null" line="26"><f a="strumLine">
	<c path="funkin.game.StrumLine"/>
	<x path="Bool"/>
</f></__getPressed>
		<__getJustPressed public="1" get="inline" set="null" line="35"><f a="strumLine">
	<c path="funkin.game.StrumLine"/>
	<x path="Bool"/>
</f></__getJustPressed>
		<__getJustReleased public="1" get="inline" set="null" line="44"><f a="strumLine">
	<c path="funkin.game.StrumLine"/>
	<x path="Bool"/>
</f></__getJustReleased>
		<getScrollSpeed public="1" get="inline" set="null" line="54"><f a="?note">
	<c path="funkin.game.Note"/>
	<x path="Float"/>
</f></getScrollSpeed>
		<getNotesAngle public="1" get="inline" set="null" line="61"><f a="?note">
	<c path="funkin.game.Note"/>
	<x path="Float"/>
</f></getNotesAngle>
		<update public="1" set="method" line="67" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="76" override="1"><f a=""><x path="Void"/></f></draw>
		<updateNotePosition public="1" set="method" line="84"><f a="daNote">
	<c path="funkin.game.Note"/>
	<x path="Void"/>
</f></updateNotePosition>
		<updateNotePos get="inline" set="null" line="96"><f a="daNote">
	<c path="funkin.game.Note"/>
	<x path="Void"/>
</f></updateNotePos>
		<updateSustain public="1" get="inline" set="null" line="131"><f a="daNote">
	<c path="funkin.game.Note"/>
	<x path="Void"/>
</f></updateSustain>
		<updatePlayerInput public="1" set="method" line="136"><f a="pressed:justPressed:justReleased">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></updatePlayerInput>
		<press public="1" get="inline" set="null" line="152"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></press>
		<playAnim public="1" set="method" line="157">
			<f a="anim:?force" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : true }</e></m></meta>
		</playAnim>
		<getAnim public="1" set="method" line="162"><f a=""><c path="String"/></f></getAnim>
		<new public="1" set="method" line="6"><f a="?X:?Y:?SimpleGraphic">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Null"><t path="flixel.system.FlxGraphicAsset"/></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.StrumLine" params="" file="source/funkin/game/StrumLine.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.game.Strum"/></extends>
		<onHit public="1" expr="new FlxTypedSignal&lt;NoteHitEvent&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="funkin.backend.scripting.events.NoteHitEvent"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;NoteHitEvent&gt;()</e></m></meta>
			<haxe_doc>* Signal that triggers whenever a note is hit. Similar to onPlayerHit and onDadHit, except strumline specific.
	 * To add a listener, do
	 * `strumLine.onHit.add(function(e:NoteHitEvent) {});`</haxe_doc>
		</onHit>
		<onMiss public="1" expr="new FlxTypedSignal&lt;NoteMissEvent&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="funkin.backend.scripting.events.NoteMissEvent"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;NoteMissEvent&gt;()</e></m></meta>
			<haxe_doc>* Signal that triggers whenever a note is missed. Similar to onPlayerMiss, except strumline specific.
	 * To add a listener, do
	 * `strumLine.onMiss.add(function(e:NoteMissEvent) {});`</haxe_doc>
		</onMiss>
		<onNoteUpdate public="1" expr="new FlxTypedSignal&lt;NoteUpdateEvent&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="funkin.backend.scripting.events.NoteUpdateEvent"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;NoteUpdateEvent&gt;()</e></m></meta>
			<haxe_doc>* Signal that triggers whenever a note is being updated. Similar to onNoteUpdate, except strumline specific.
	 * To add a listener, do
	 * `strumLine.onNoteUpdate.add(function(e:NoteUpdateEvent) {});`</haxe_doc>
		</onNoteUpdate>
		<onNoteDelete public="1" expr="new FlxTypedSignal&lt;SimpleNoteEvent&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="funkin.backend.scripting.events.SimpleNoteEvent"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;SimpleNoteEvent&gt;()</e></m></meta>
			<haxe_doc>* Signal that triggers whenever a note is being deleted. Similar to onNoteDelete, except strumline specific.
	 * To add a listener, do
	 * `strumLine.onNoteDelete.add(function(e:SimpleNoteEvent) {});`</haxe_doc>
		</onNoteDelete>
		<characters public="1">
			<c path="Array"><c path="funkin.game.Character"/></c>
			<haxe_doc>* Array containing all of the characters "attached" to those strums.</haxe_doc>
		</characters>
		<cpu public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever this strumline is controlled by cpu or not.</haxe_doc>
		</cpu>
		<opponentSide public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever this strumline is from the opponent side or the player side.</haxe_doc>
		</opponentSide>
		<controls public="1" expr="null">
			<c path="funkin.backend.system.Controls"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Controls assigned to this strumline.</haxe_doc>
		</controls>
		<data public="1" expr="null">
			<t path="funkin.backend.chart.ChartStrumLine"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Chart JSON data assigned to this StrumLine (Codename format)</haxe_doc>
		</data>
		<ghostTapping public="1" get="accessor" set="accessor" expr="null">
			<x path="Null"><x path="Bool"/></x>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":isVar"/>
			</meta>
			<haxe_doc>* Whenever Ghost Tapping is enabled.</haxe_doc>
		</ghostTapping>
		<notes public="1">
			<c path="funkin.game.NoteGroup"/>
			<haxe_doc>* Group of all of the notes in this strumline. Using `forEach` on this group will only loop through the first notes for performance reasons.</haxe_doc>
		</notes>
		<altAnim public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whenever alt animation is enabled on this strumline.</haxe_doc>
		</altAnim>
		<animSuffix public="1" set="accessor" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
			<haxe_doc>* Which animation suffix on characters that should be used when hitting notes.</haxe_doc>
		</animSuffix>
		<strumAnimPrefix public="1" expr="[&quot;left&quot;, &quot;down&quot;, &quot;up&quot;, &quot;right&quot;]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["left", "down", "up", "right"]</e></m></meta>
			<haxe_doc>* TODO: Write documention about this being a variable that can help when making multi key</haxe_doc>
		</strumAnimPrefix>
		<vocals public="1">
			<c path="flixel.sound.FlxSound"/>
			<haxe_doc>* Vocals sound (Vocals.ogg). Used for individual vocals per strumline.</haxe_doc>
		</vocals>
		<extra public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</extra>
		<get_ghostTapping set="method" line="85"><f a=""><x path="Null"><x path="Bool"/></x></f></get_ghostTapping>
		<set_ghostTapping get="inline" set="null" line="92"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ghostTapping>
		<startingPos expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</startingPos>
		<strumScale expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</strumScale>
		<generate public="1" set="method" line="110"><f a="strumLine:?startTime">
	<t path="funkin.backend.chart.ChartStrumLine"/>
	<x path="Float"/>
	<x path="Void"/>
</f></generate>
		<update public="1" set="method" line="154" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="159" override="1"><f a=""><x path="Void"/></f></draw>
		<updateNotes public="1" get="inline" set="null" line="165"><f a=""><x path="Void"/></f></updateNotes>
		<__updateNote_strum><c path="funkin.game.Strum"/></__updateNote_strum>
		<__updateNote_songPos><x path="Float"/></__updateNote_songPos>
		<__updateNote_event><c path="funkin.backend.scripting.events.NoteUpdateEvent"/></__updateNote_event>
		<updateNote public="1" set="method" line="174"><f a="daNote">
	<c path="funkin.game.Note"/>
	<x path="Void"/>
</f></updateNote>
		<__funcsToExec expr="[]">
			<c path="Array"><f a="">
	<c path="funkin.game.Note"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__funcsToExec>
		<__pressed expr="[]">
			<c path="Array"><x path="Bool"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__pressed>
		<__justPressed expr="[]">
			<c path="Array"><x path="Bool"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__justPressed>
		<__justReleased expr="[]">
			<c path="Array"><x path="Bool"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__justReleased>
		<__notePerStrum expr="[]">
			<c path="Array"><c path="funkin.game.Note"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__notePerStrum>
		<__inputProcessPressed set="method" line="217"><f a="note">
	<c path="funkin.game.Note"/>
	<x path="Void"/>
</f></__inputProcessPressed>
		<__inputProcessJustPressed set="method" line="222"><f a="note">
	<c path="funkin.game.Note"/>
	<x path="Void"/>
</f></__inputProcessJustPressed>
		<updateInput public="1" set="method" line="229">
			<f a="?id" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0 }</e></m></meta>
		</updateInput>
		<addHealth public="1" get="inline" set="null" line="284"><f a="health">
	<x path="Float"/>
	<x path="Void"/>
</f></addHealth>
		<generateStrums public="1" get="inline" set="null" line="286">
			<f a="?amount" v="4">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ amount : 4 }</e></m></meta>
		</generateStrums>
		<destroy public="1" set="method" line="291" override="1"><f a=""><x path="Void"/></f></destroy>
		<createStrum public="1" set="method" line="302">
			<f a="i:?animPrefix">
				<x path="Int"/>
				<c path="String"/>
				<c path="funkin.game.Strum"/>
			</f>
			<haxe_doc>* Creates a strum and returns the created strum (needs to be added manually).
	 * @param i Index of the strum
	 * @param animPrefix (Optional) Animation prefix (`left` = `arrowLEFT`, `left press`, `left confirm`).</haxe_doc>
		</createStrum>
		<deleteNote public="1" set="method" line="353">
			<f a="note">
				<c path="funkin.game.Note"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Deletes a note from this strumline.
	 * @param note Note to delete</haxe_doc>
		</deleteNote>
		<set_cpu get="inline" set="null" line="368">
			<f a="b">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* SETTERS &amp; GETTERS</haxe_doc>
		</set_cpu>
		<set_animSuffix get="inline" set="null" line="374"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></set_animSuffix>
		<set_altAnim get="inline" set="null" line="380"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_altAnim>
		<get_altAnim get="inline" set="null" line="384"><f a=""><x path="Bool"/></f></get_altAnim>
		<new public="1" set="method" line="97">
			<f a="characters:startingPos:strumScale:?cpu:?opponentSide:?controls:?vocalPrefix" v=":::false:true::&quot;&quot;">
				<c path="Array"><c path="funkin.game.Character"/></c>
				<x path="flixel.math.FlxPoint"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="funkin.backend.system.Controls"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ vocalPrefix : "", opponentSide : true, cpu : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.cutscenes.Cutscene" params="" file="source/funkin/game/cutscenes/Cutscene.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<__callback><f a=""><x path="Void"/></f></__callback>
		<game expr="PlayState.instance">
			<c path="funkin.game.PlayState"/>
			<meta><m n=":value"><e>PlayState.instance</e></m></meta>
		</game>
		<update public="1" set="method" line="14" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<close public="1" set="method" line="18" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="10"><f a="callback">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Substate made for cutscenes.</haxe_doc>
	</class>
	<class path="funkin.game.cutscenes.DialogueCutscene" params="" file="source/funkin/game/cutscenes/DialogueCutscene.hx">
		<extends path="funkin.game.cutscenes.Cutscene"/>
		<cutscene public="1" static="1"><c path="funkin.game.cutscenes.DialogueCutscene"/></cutscene>
		<dialoguePath public="1"><c path="String"/></dialoguePath>
		<dialogueData public="1"><x path="haxe.xml.Access"/></dialogueData>
		<charMap public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.game.cutscenes.dialogue.DialogueCharacter"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</charMap>
		<dialogueLines public="1" expr="[]">
			<c path="Array"><t path="funkin.game.cutscenes.DialogueLine"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</dialogueLines>
		<curLine public="1" set="accessor" expr="null">
			<t path="funkin.game.cutscenes.DialogueLine"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curLine>
		<lastLine public="1" expr="null">
			<t path="funkin.game.cutscenes.DialogueLine"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastLine>
		<dialogueBox public="1"><c path="funkin.game.cutscenes.dialogue.DialogueBox"/></dialogueBox>
		<dialogueCamera public="1"><c path="flixel.FlxCamera"/></dialogueCamera>
		<curMusic public="1" expr="null">
			<c path="flixel.sound.FlxSound"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curMusic>
		<dialogueScript public="1"><c path="funkin.backend.scripting.Script"/></dialogueScript>
		<set_curLine public="1" set="method" line="33"><f a="val">
	<t path="funkin.game.cutscenes.DialogueLine"/>
	<t path="funkin.game.cutscenes.DialogueLine"/>
</f></set_curLine>
		<parentDisabler><c path="funkin.backend.utils.FunkinParentDisabler"/></parentDisabler>
		<create public="1" set="method" line="51" override="1"><f a=""><x path="Void"/></f></create>
		<beatHit public="1" set="method" line="120" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<update public="1" set="method" line="125" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<canProceed public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Use this to cancel `next`!</haxe_doc>
		</canProceed>
		<next public="1" set="method" line="140">
			<f a="?playFirst" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ playFirst : false }</e></m></meta>
		</next>
		<close public="1" set="method" line="184" override="1"><f a=""><x path="Void"/></f></close>
		<destroy public="1" set="method" line="194" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="38"><f a="dialoguePath:callback">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Substate made for dialogue cutscenes. To use it in a scripted cutscene, call `startDialogue`.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.game.cutscenes.DialogueLine" params="" file="source/funkin/game/cutscenes/DialogueCutscene.hx" module="funkin.game.cutscenes.DialogueCutscene"><a>
	<textSound><c path="flixel.sound.FlxSound"/></textSound>
	<text><c path="String"/></text>
	<speed><x path="Float"/></speed>
	<playSound><c path="flixel.sound.FlxSound"/></playSound>
	<nextSound><c path="flixel.sound.FlxSound"/></nextSound>
	<musicVolume><x path="Null"><x path="Float"/></x></musicVolume>
	<format><c path="Array"><t path="funkin.backend.utils.TextFormat"/></c></format>
	<char><c path="String"/></char>
	<changeMusic><c path="flixel.sound.FlxSound"/></changeMusic>
	<changeDefAnim><c path="String"/></changeDefAnim>
	<callback><c path="String"/></callback>
	<bubble><c path="String"/></bubble>
</a></typedef>
	<class path="funkin.game.cutscenes.ScriptedCutscene" params="" file="source/funkin/game/cutscenes/ScriptedCutscene.hx">
		<extends path="funkin.game.cutscenes.Cutscene"/>
		<script><c path="funkin.backend.scripting.Script"/></script>
		<scriptPath><c path="String"/></scriptPath>
		<create public="1" set="method" line="24" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="34" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<beatHit public="1" set="method" line="40" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method" line="45" override="1"><f a="curStep">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<destroy public="1" set="method" line="50" override="1"><f a=""><x path="Void"/></f></destroy>
		<startVideo public="1" set="method" line="57"><f a="path:?callback">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></startVideo>
		<isVideoPlaying public="1" get="accessor" set="null"><x path="Bool"/></isVideoPlaying>
		<get_isVideoPlaying get="inline" set="null" line="68"><f a=""><x path="Bool"/></f></get_isVideoPlaying>
		<startDialogue public="1" set="method" line="73"><f a="path:?callback">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></startDialogue>
		<isDialoguePlaying public="1" get="accessor" set="null"><x path="Bool"/></isDialoguePlaying>
		<get_isDialoguePlaying get="inline" set="null" line="84"><f a=""><x path="Bool"/></f></get_isDialoguePlaying>
		<new public="1" set="method" line="15"><f a="scriptPath:callback">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Substate made for scripted cutscenes.
 * To add cutscenes to your songs, add a `cutscene.hx` file in your song's directory (ex: `songs/song/cutscene.hx`)</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.cutscenes.VideoCutscene" params="" file="source/funkin/game/cutscenes/VideoCutscene.hx">
		<extends path="funkin.game.cutscenes.Cutscene"/>
		<curVideo expr="0" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curVideo>
		<splitTime public="1" set="method" line="162" static="1"><f a="str">
	<c path="String"/>
	<x path="Float"/>
</f></splitTime>
		<path><c path="String"/></path>
		<localPath><c path="String"/></localPath>
		<video><c path="hxvlc.flixel.FlxVideo"/></video>
		<skippable public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</skippable>
		<cutsceneCamera><c path="flixel.FlxCamera"/></cutsceneCamera>
		<text><c path="funkin.backend.FunkinText"/></text>
		<loadingBackdrop><c path="flixel.addons.display.FlxBackdrop"/></loadingBackdrop>
		<videoReady expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</videoReady>
		<bg><c path="flixel.FlxSprite"/></bg>
		<subtitle><c path="funkin.backend.FunkinText"/></subtitle>
		<subtitles public="1" expr="[]">
			<c path="Array"><t path="funkin.game.cutscenes.CutsceneSubtitle"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</subtitles>
		<create public="1" set="method" line="46" override="1"><f a=""><x path="Void"/></f></create>
		<parseSubtitles public="1" set="method" line="115"><f a=""><x path="Void"/></f></parseSubtitles>
		<update public="1" set="method" line="176" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<setSubtitle public="1" set="method" line="216"><f a="sub">
	<t path="funkin.game.cutscenes.CutsceneSubtitle"/>
	<x path="Void"/>
</f></setSubtitle>
		<destroy public="1" set="method" line="227" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="41"><f a="path:callback">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Substate made for video cutscenes. To use it in a scripted cutscene, call `startVideo`.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.game.cutscenes.CutsceneSubtitle" params="" file="source/funkin/game/cutscenes/VideoCutscene.hx" module="funkin.game.cutscenes.VideoCutscene"><a>
	<time><x path="Float"/></time>
	<subtitle><c path="String"/></subtitle>
	<color><x path="flixel.util.FlxColor"/></color>
</a></typedef>
	<class path="funkin.game.cutscenes.dialogue.DialogueBox" params="" file="source/funkin/game/cutscenes/dialogue/DialogueBox.hx">
		<extends path="funkin.backend.FunkinSprite"/>
		<dialogueBoxData public="1"><x path="haxe.xml.Access"/></dialogueBoxData>
		<positions public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<t path="funkin.game.cutscenes.dialogue.CharPosDef"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</positions>
		<dialogueEnded public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</dialogueEnded>
		<nextSFX public="1" expr="Paths.sound(&quot;dialogue/next&quot;)">
			<c path="String"/>
			<meta><m n=":value"><e>Paths.sound("dialogue/next")</e></m></meta>
		</nextSFX>
		<defaultTextTypeSFX public="1"><c path="Array"><c path="flixel.sound.FlxSound"/></c></defaultTextTypeSFX>
		<text public="1"><c path="flixel.addons.text.FlxTypeText"/></text>
		<defPath public="1" expr="&quot;dialogue/boxes/&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"dialogue/boxes/"</e></m></meta>
		</defPath>
		<dialogueBoxScript public="1"><c path="funkin.backend.scripting.Script"/></dialogueBoxScript>
		<cutscene public="1" expr="DialogueCutscene.cutscene">
			<c path="funkin.game.cutscenes.DialogueCutscene"/>
			<meta><m n=":value"><e>DialogueCutscene.cutscene</e></m></meta>
		</cutscene>
		<playAnim public="1" set="method" line="100" override="1">
			<f a="AnimName:?Force:?Context:?Reversed:?Frame" v="::NONE:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="funkin.backend.scripting.events.PlayAnimContext"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Frame : 0, Reversed : false, Context : NONE }</e></m></meta>
		</playAnim>
		<beatHit public="1" set="method" line="108" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<update public="1" set="method" line="113" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<popupChar public="1" set="method" line="118">
			<f a="char:?force" v=":false">
				<c path="funkin.game.cutscenes.dialogue.DialogueCharacter"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</popupChar>
		<playBubbleAnim public="1" set="method" line="130">
			<f a="bubble:?suffix:?text:?format:?speed:?customSFX:?customTypeSFX:?setTextAfter:?allowDefault" v=":&quot;&quot;:&quot;&quot;::0.05:::false:true">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
				<x path="Float"/>
				<c path="flixel.sound.FlxSound"/>
				<c path="Array"><c path="flixel.sound.FlxSound"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ allowDefault : true, setTextAfter : false, speed : 0.05, text : "", suffix : "" }</e></m></meta>
		</playBubbleAnim>
		<resetText public="1" set="method" line="157">
			<f a="?text:?formats:?event" v="&quot;&quot;::">
				<c path="String"/>
				<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
				<c path="funkin.backend.scripting.events.dialogue.DialogueBoxSetTextEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ text : "" }</e></m></meta>
		</resetText>
		<startText public="1" set="method" line="170">
			<f a="?text:?format:?speed:?customTypeSFX" v="&quot;&quot;::0.05:">
				<c path="String"/>
				<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
				<x path="Float"/>
				<c path="Array"><c path="flixel.sound.FlxSound"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ speed : 0.05, text : "" }</e></m></meta>
		</startText>
		<destroy public="1" set="method" line="183" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="27"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.game.cutscenes.dialogue.CharPosDef" params="" file="source/funkin/game/cutscenes/dialogue/DialogueBox.hx" module="funkin.game.cutscenes.dialogue.DialogueBox"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<flipBubble><x path="Bool"/></flipBubble>
</a></typedef>
	<class path="funkin.game.cutscenes.dialogue.DialogueCharacter" params="" file="source/funkin/game/cutscenes/dialogue/DialogueCharacter.hx">
		<extends path="funkin.backend.FunkinSprite"/>
		<charData public="1"><x path="haxe.xml.Access"/></charData>
		<curTween public="1"><c path="flixel.tweens.FlxTween"/></curTween>
		<curAnimContext public="1" expr="NONE">
			<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
		</curAnimContext>
		<positionName public="1"><c path="String"/></positionName>
		<finishAnimCallback public="1" expr="null">
			<f a="">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</finishAnimCallback>
		<defaultAnim public="1" expr="&quot;normal&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"normal"</e></m></meta>
		</defaultAnim>
		<defPath public="1" expr="&quot;dialogue/characters/&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"dialogue/characters/"</e></m></meta>
		</defPath>
		<dialogueCharScript public="1"><c path="funkin.backend.scripting.Script"/></dialogueCharScript>
		<cutscene public="1" expr="DialogueCutscene.cutscene">
			<c path="funkin.game.cutscenes.DialogueCutscene"/>
			<meta><m n=":value"><e>DialogueCutscene.cutscene</e></m></meta>
		</cutscene>
		<playAnim public="1" set="method" line="64" override="1">
			<f a="AnimName:?Force:?Context:?Reversed:?Frame" v="::NONE:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="funkin.backend.scripting.events.PlayAnimContext"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Frame : 0, Reversed : false, Context : NONE }</e></m></meta>
		</playAnim>
		<beatHit public="1" set="method" line="72" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<update public="1" set="method" line="77" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<show public="1" set="method" line="82">
			<f a="x:y:?animation:?force" v=":::false">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</show>
		<hide public="1" set="method" line="107">
			<f a="?animation:?force" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</hide>
		<destroy public="1" set="method" line="126" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="23"><f a="name:position">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext" params="" file="source/funkin/game/cutscenes/dialogue/DialogueCharacter.hx" module="funkin.game.cutscenes.dialogue.DialogueCharacter">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.game.cutscenes.dialogue._DialogueCharacter.DialogueCharAnimContext_Impl_" params="" file="source/funkin/game/cutscenes/dialogue/DialogueCharacter.hx" private="1" module="funkin.game.cutscenes.dialogue.DialogueCharacter" extern="1" final="1">
	<NONE public="1" get="inline" set="null" expr="cast -1" line="135" static="1">
		<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
		<meta>
			<m n=":value"><e>cast -1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<POPIN public="1" get="inline" set="null" expr="cast 0" line="136" static="1">
		<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</POPIN>
	<POPOUT public="1" get="inline" set="null" expr="cast 1" line="137" static="1">
		<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</POPOUT>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.game.cutscenes.dialogue._DialogueCharacter.DialogueCharAnimContext_Impl_" params="" file="source/funkin/game/cutscenes/dialogue/DialogueCharacter.hx" private="1" module="funkin.game.cutscenes.dialogue.DialogueCharacter" extern="1" final="1">
		<NONE public="1" get="inline" set="null" expr="cast -1" line="135" static="1">
			<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
			<meta>
				<m n=":value"><e>cast -1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<POPIN public="1" get="inline" set="null" expr="cast 0" line="136" static="1">
			<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</POPIN>
		<POPOUT public="1" get="inline" set="null" expr="cast 1" line="137" static="1">
			<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</POPOUT>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.menus.BetaWarningState" params="" file="source/funkin/menus/BetaWarningState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<titleAlphabet><c path="funkin.menus.ui.Alphabet"/></titleAlphabet>
		<disclaimer><c path="funkin.backend.FunkinText"/></disclaimer>
		<transitioning expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</transitioning>
		<create public="1" set="method" line="13" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="36" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<goToTitle set="method" line="53"><f a=""><x path="Void"/></f></goToTitle>
		<new public="1" set="method" line="7"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.FreeplayState" params="" file="source/funkin/menus/FreeplayState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<songs public="1" expr="[]">
			<c path="Array"><t path="funkin.backend.chart.ChartMetaData"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Array containing all of the songs metadatas</haxe_doc>
		</songs>
		<curSelected public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Currently selected song</haxe_doc>
		</curSelected>
		<curDifficulty public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Currently selected difficulty</haxe_doc>
		</curDifficulty>
		<curCoopMode public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Currently selected coop/opponent mode</haxe_doc>
		</curCoopMode>
		<scoreText public="1">
			<c path="flixel.text.FlxText"/>
			<haxe_doc>* Text containing the score info (PERSONAL BEST: 0)</haxe_doc>
		</scoreText>
		<diffText public="1">
			<c path="flixel.text.FlxText"/>
			<haxe_doc>* Text containing the current difficulty (&lt; HARD &gt;)</haxe_doc>
		</diffText>
		<coopText public="1">
			<c path="flixel.text.FlxText"/>
			<haxe_doc>* Text containing the current coop/opponent mode ([TAB] Co-Op mode)</haxe_doc>
		</coopText>
		<lerpScore public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Currently lerped score. Is updated to go towards `intendedScore`.</haxe_doc>
		</lerpScore>
		<intendedScore public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Destination for the currently lerped score.</haxe_doc>
		</intendedScore>
		<songList public="1">
			<c path="funkin.menus.FreeplaySonglist"/>
			<haxe_doc>* Assigned FreeplaySonglist item.</haxe_doc>
		</songList>
		<scoreBG public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Black background around the score, the difficulty text and the co-op text.</haxe_doc>
		</scoreBG>
		<bg public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Background.</haxe_doc>
		</bg>
		<canSelect public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the player can navigate and select</haxe_doc>
		</canSelect>
		<grpSongs public="1">
			<c path="flixel.group.FlxTypedGroup"><c path="funkin.menus.ui.Alphabet"/></c>
			<haxe_doc>* Group containing all of the alphabets</haxe_doc>
		</grpSongs>
		<curPlaying public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the currently selected song is playing.</haxe_doc>
		</curPlaying>
		<iconArray public="1" expr="[]">
			<c path="Array"><c path="funkin.game.HealthIcon"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Array containing all of the icons.</haxe_doc>
		</iconArray>
		<interpColor public="1">
			<c path="funkin.backend.utils.FlxInterpolateColor"/>
			<haxe_doc>* FlxInterpolateColor object for smooth transition between Freeplay colors.</haxe_doc>
		</interpColor>
		<create public="1" set="method" line="101" override="1"><f a=""><x path="Void"/></f></create>
		<timeUntilAutoplay public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* How much time a song stays selected until it autoplays.</haxe_doc>
		</timeUntilAutoplay>
		<disableAutoPlay public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the song autoplays when hovered over.</haxe_doc>
		</disableAutoPlay>
		<disableAsyncLoading public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the autoplayed song gets async loaded.</haxe_doc>
		</disableAsyncLoading>
		<autoplayElapsed public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Time elapsed since last autoplay. If this time exceeds `timeUntilAutoplay`, the currently selected song will play.</haxe_doc>
		</autoplayElapsed>
		<songInstPlaying public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the currently selected song instrumental is playing.</haxe_doc>
		</songInstPlaying>
		<curPlayingInst public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Path to the currently playing song instrumental.</haxe_doc>
		</curPlayingInst>
		<update public="1" set="method" line="205" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<__opponentMode expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__opponentMode>
		<__coopMode expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__coopMode>
		<updateCoopModes set="method" line="270"><f a=""><x path="Void"/></f></updateCoopModes>
		<select public="1" set="method" line="286">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Selects the current song.</haxe_doc>
		</select>
		<convertChart public="1" set="method" line="302"><f a=""><x path="Void"/></f></convertChart>
		<changeDiff public="1" set="method" line="314">
			<f a="?change:?force" v="0:false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false, change : 0 }</e></m></meta>
			<haxe_doc>* Changes the current difficulty
	 * @param change How much to change.
	 * @param force Force the change if `change` is equal to 0</haxe_doc>
		</changeDiff>
		<updateScore set="method" line="333"><f a=""><x path="Void"/></f></updateScore>
		<coopLabels public="1" expr="[&quot;[TAB] Solo&quot;, &quot;[TAB] Opponent Mode&quot;, &quot;[TAB] Co-Op Mode&quot;, &quot;[TAB] Co-Op Mode (Switched)&quot;]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["[TAB] Solo", "[TAB] Opponent Mode", "[TAB] Co-Op Mode", "[TAB] Co-Op Mode (Switched)"]</e></m></meta>
			<haxe_doc>* Array containing all labels for Co-Op / Opponent modes.</haxe_doc>
		</coopLabels>
		<changeCoopMode public="1" set="method" line="361">
			<f a="?change:?force" v="0:false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false, change : 0 }</e></m></meta>
			<haxe_doc>* Change the current coop mode context.
	 * @param change How much to change
	 * @param force Force the change, even if `change` is equal to 0.</haxe_doc>
		</changeCoopMode>
		<changeSelection public="1" set="method" line="387">
			<f a="?change:?force" v="0:false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false, change : 0 }</e></m></meta>
			<haxe_doc>* Change the current selection.
	 * @param change How much to change
	 * @param force Force the change, even if `change` is equal to 0.</haxe_doc>
		</changeSelection>
		<updateOptionsAlpha set="method" line="407"><f a=""><x path="Void"/></f></updateOptionsAlpha>
		<new public="1" set="method" line="16"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.FreeplaySonglist" params="" file="source/funkin/menus/FreeplayState.hx" module="funkin.menus.FreeplayState">
		<get public="1" set="method" line="450" static="1">
			<f a="?useTxt" v="true">
				<x path="Bool"/>
				<c path="funkin.menus.FreeplaySonglist"/>
			</f>
			<meta><m n=":value"><e>{ useTxt : true }</e></m></meta>
		</get>
		<songs public="1" expr="[]">
			<c path="Array"><t path="funkin.backend.chart.ChartMetaData"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</songs>
		<getSongsFromSource public="1" set="method" line="433">
			<f a="source:?useTxt" v=":true">
				<x path="funkin.backend.assets.AssetSource"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ useTxt : true }</e></m></meta>
		</getSongsFromSource>
		<new public="1" set="method" line="431"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.GitarooPause" params="" file="source/funkin/menus/GitarooPause.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<replayButton><c path="flixel.FlxSprite"/></replayButton>
		<cancelButton><c path="flixel.FlxSprite"/></cancelButton>
		<replaySelect expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</replaySelect>
		<create public="1" set="method" line="18" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="52" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<changeThing set="method" line="79"><f a=""><x path="Void"/></f></changeThing>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.MainMenuState" params="" file="source/funkin/menus/MainMenuState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<curSelected expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSelected>
		<menuItems><c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxSprite"/></c></menuItems>
		<optionShit expr="CoolUtil.coolTextFile(Paths.txt(&quot;config/menuItems&quot;))">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>CoolUtil.coolTextFile(Paths.txt("config/menuItems"))</e></m></meta>
		</optionShit>
		<bg><c path="flixel.FlxSprite"/></bg>
		<magenta><c path="flixel.FlxSprite"/></magenta>
		<camFollow><c path="flixel.FlxObject"/></camFollow>
		<versionText><c path="funkin.backend.FunkinText"/></versionText>
		<canAccessDebugMenus public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</canAccessDebugMenus>
		<create public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></create>
		<selectedSomethin expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selectedSomethin>
		<forceCenterX expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</forceCenterX>
		<update public="1" set="method" line="91" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<switchTo public="1" set="method" line="144" override="1"><f a="nextState">
	<c path="flixel.FlxState"/>
	<x path="Bool"/>
</f></switchTo>
		<selectItem set="method" line="153"><f a=""><x path="Void"/></f></selectItem>
		<changeItem set="method" line="175">
			<f a="?huh" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ huh : 0 }</e></m></meta>
		</changeItem>
		<new public="1" set="method" line="18"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.ModSwitchMenu" params="" file="source/funkin/menus/ModSwitchMenu.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<mods expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</mods>
		<alphabets><c path="flixel.group.FlxTypedGroup"><c path="funkin.menus.ui.Alphabet"/></c></alphabets>
		<curSelected expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSelected>
		<create public="1" set="method" line="14" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="39" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<changeSelection public="1" set="method" line="53">
			<f a="change:?force" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</changeSelection>
		<new public="1" set="method" line="9"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.PauseSubState" params="" file="source/funkin/menus/PauseSubState.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<script public="1" expr="&quot;&quot;" line="20" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</script>
		<grpMenuShit><c path="flixel.group.FlxTypedGroup"><c path="funkin.menus.ui.Alphabet"/></c></grpMenuShit>
		<menuItems expr="[&quot;Resume&quot;, &quot;Restart Song&quot;, &quot;Change Controls&quot;, &quot;Change Options&quot;, &quot;Exit to menu&quot;, &quot;Exit to charter&quot;]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["Resume", "Restart Song", "Change Controls", "Change Options", "Exit to menu", "Exit to charter"]</e></m></meta>
		</menuItems>
		<curSelected expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSelected>
		<pauseMusic><c path="flixel.sound.FlxSound"/></pauseMusic>
		<pauseScript public="1"><c path="funkin.backend.scripting.Script"/></pauseScript>
		<game public="1" expr="PlayState.instance">
			<c path="funkin.game.PlayState"/>
			<meta><m n=":value"><e>PlayState.instance</e></m></meta>
		</game>
		<__cancelDefault expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__cancelDefault>
		<parentDisabler><c path="funkin.backend.utils.FunkinParentDisabler"/></parentDisabler>
		<create public="1" set="method" line="41" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="114" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<selectOption public="1" set="method" line="136"><f a=""><x path="Void"/></f></selectOption>
		<destroy public="1" set="method" line="176" override="1"><f a=""><x path="Void"/></f></destroy>
		<changeSelection set="method" line="191">
			<f a="?change" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ change : 0 }</e></m></meta>
		</changeSelection>
		<new public="1" set="method" line="35">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.PlaytestingWarningSubstate" params="" file="source/funkin/menus/PlaytestingWarningSubstate.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<titleAlphabet><c path="funkin.menus.ui.Alphabet"/></titleAlphabet>
		<disclaimer><c path="funkin.backend.FunkinText"/></disclaimer>
		<windowClosing expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</windowClosing>
		<curSelected expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSelected>
		<options expr="[]">
			<c path="Array"><c path="funkin.backend.FunkinText"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</options>
		<buttonsData expr="[]">
			<c path="Array"><t path="funkin.editors.ui.WarningButton"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</buttonsData>
		<indicator><c path="funkin.backend.FunkinText"/></indicator>
		<create public="1" set="method" line="29" override="1"><f a=""><x path="Void"/></f></create>
		<sinner expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</sinner>
		<__firstFrame expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__firstFrame>
		<update public="1" set="method" line="75" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<changeSelection set="method" line="103"><f a="change">
	<x path="Int"/>
	<x path="Void"/>
</f></changeSelection>
		<destroy public="1" set="method" line="108" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="23"><f a="closingWindow:buttons">
	<x path="Bool"/>
	<c path="Array"><t path="funkin.editors.ui.WarningButton"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.StoryMenuState" params="" file="source/funkin/menus/StoryMenuState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<characters public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<t path="funkin.menus.MenuCharacter"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</characters>
		<weeks public="1" expr="[]">
			<c path="Array"><t path="funkin.menus.WeekData"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</weeks>
		<scoreText public="1"><c path="flixel.text.FlxText"/></scoreText>
		<tracklist public="1"><c path="flixel.text.FlxText"/></tracklist>
		<weekTitle public="1"><c path="flixel.text.FlxText"/></weekTitle>
		<curDifficulty public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curDifficulty>
		<curWeek public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curWeek>
		<difficultySprites public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</difficultySprites>
		<weekBG public="1"><c path="flixel.FlxSprite"/></weekBG>
		<leftArrow public="1"><c path="flixel.FlxSprite"/></leftArrow>
		<rightArrow public="1"><c path="flixel.FlxSprite"/></rightArrow>
		<blackBar public="1"><c path="flixel.FlxSprite"/></blackBar>
		<lerpScore public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lerpScore>
		<intendedScore public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</intendedScore>
		<canSelect public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</canSelect>
		<weekSprites public="1"><c path="flixel.group.FlxTypedGroup"><c path="funkin.menus.MenuItem"/></c></weekSprites>
		<characterSprites public="1"><c path="flixel.group.FlxTypedGroup"><c path="funkin.menus.MenuCharacterSprite"/></c></characterSprites>
		<create public="1" set="method" line="41" override="1"><f a=""><x path="Void"/></f></create>
		<__lastDifficultyTween><c path="flixel.tweens.FlxTween"/></__lastDifficultyTween>
		<update public="1" set="method" line="124" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<goBack public="1" set="method" line="150"><f a=""><x path="Void"/></f></goBack>
		<changeWeek public="1" set="method" line="156">
			<f a="change:?force" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</changeWeek>
		<__oldDiffName expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</__oldDiffName>
		<changeDifficulty public="1" set="method" line="179">
			<f a="change:?force" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</changeDifficulty>
		<loadXMLs public="1" set="method" line="205"><f a=""><x path="Void"/></f></loadXMLs>
		<addCharacter public="1" set="method" line="278"><f a="charName">
	<c path="String"/>
	<x path="Void"/>
</f></addCharacter>
		<getWeeksFromSource public="1" set="method" line="300"><f a="weeks:source">
	<c path="Array"><c path="String"/></c>
	<x path="funkin.backend.assets.AssetSource"/>
	<x path="Bool"/>
</f></getWeeksFromSource>
		<destroy public="1" set="method" line="318" override="1"><f a=""><x path="Void"/></f></destroy>
		<selectWeek public="1" set="method" line="325"><f a=""><x path="Void"/></f></selectWeek>
		<new public="1" set="method" line="14"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.menus.WeekData" params="" file="source/funkin/menus/StoryMenuState.hx" module="funkin.menus.StoryMenuState"><a>
	<sprite><c path="String"/></sprite>
	<songs><c path="Array"><t path="funkin.menus.WeekSong"/></c></songs>
	<name><c path="String"/></name>
	<id><c path="String"/></id>
	<difficulties><c path="Array"><c path="String"/></c></difficulties>
	<chars><c path="Array"><c path="String"/></c></chars>
</a></typedef>
	<typedef path="funkin.menus.WeekSong" params="" file="source/funkin/menus/StoryMenuState.hx" module="funkin.menus.StoryMenuState"><a>
	<name><c path="String"/></name>
	<hide><x path="Bool"/></hide>
</a></typedef>
	<typedef path="funkin.menus.MenuCharacter" params="" file="source/funkin/menus/StoryMenuState.hx" module="funkin.menus.StoryMenuState"><a>
	<xml><x path="haxe.xml.Access"/></xml>
	<spritePath><c path="String"/></spritePath>
	<scale><x path="Float"/></scale>
	<offset><x path="flixel.math.FlxPoint"/></offset>
</a></typedef>
	<class path="funkin.menus.MenuCharacterSprite" params="" file="source/funkin/menus/StoryMenuState.hx" module="funkin.menus.StoryMenuState">
		<extends path="flixel.FlxSprite"/>
		<character public="1"><c path="String"/></character>
		<pos><x path="Int"/></pos>
		<oldChar public="1" expr="null">
			<t path="funkin.menus.MenuCharacter"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</oldChar>
		<changeCharacter public="1" set="method" line="383"><f a="data">
	<t path="funkin.menus.MenuCharacter"/>
	<x path="Void"/>
</f></changeCharacter>
		<new public="1" set="method" line="374"><f a="pos">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.MenuItem" params="" file="source/funkin/menus/StoryMenuState.hx" module="funkin.menus.StoryMenuState">
		<extends path="flixel.FlxSprite"/>
		<targetY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</targetY>
		<isFlashing expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isFlashing>
		<startFlashing public="1" set="method" line="421"><f a=""><x path="Void"/></f></startFlashing>
		<time expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</time>
		<update public="1" set="method" line="438" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="410"><f a="x:y:path">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.TitleState" params="" file="source/funkin/menus/TitleState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<initialized expr="false" line="19" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</initialized>
		<hasCheckedUpdates expr="false" line="20" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasCheckedUpdates>
		<curWacky public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</curWacky>
		<blackScreen public="1"><c path="flixel.FlxSprite"/></blackScreen>
		<textGroup public="1"><t path="flixel.group.FlxGroup"/></textGroup>
		<ngSpr public="1"><c path="flixel.FlxSprite"/></ngSpr>
		<wackyImage public="1"><c path="flixel.FlxSprite"/></wackyImage>
		<create public="1" set="method" line="31" override="1"><f a=""><x path="Void"/></f></create>
		<logoBl><c path="flixel.FlxSprite"/></logoBl>
		<gfDance><c path="flixel.FlxSprite"/></gfDance>
		<danceLeft expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</danceLeft>
		<titleText><c path="flixel.FlxSprite"/></titleText>
		<titleScreenSprites><c path="funkin.backend.MusicBeatGroup"/></titleScreenSprites>
		<startIntro set="method" line="50"><f a=""><x path="Void"/></f></startIntro>
		<getIntroTextShit public="1" set="method" line="102"><f a=""><c path="Array"><c path="Array"><c path="String"/></c></c></f></getIntroTextShit>
		<transitioning expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</transitioning>
		<update public="1" set="method" line="119" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<pressEnter public="1" set="method" line="163"><f a=""><x path="Void"/></f></pressEnter>
		<goToMainMenu set="method" line="175"><f a=""><x path="Void"/></f></goToMainMenu>
		<createCoolText public="1" set="method" line="191"><f a="textArray">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></createCoolText>
		<addMoreText public="1" set="method" line="202"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></addMoreText>
		<deleteCoolText public="1" set="method" line="209"><f a=""><x path="Void"/></f></deleteCoolText>
		<beatHit public="1" set="method" line="217" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<xml public="1"><x path="haxe.xml.Access"/></xml>
		<titleLength public="1" expr="16">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</titleLength>
		<titleLines public="1" expr="[1 =&gt; new IntroText([&quot;ninjamuffin99&quot;, &quot;phantomArcade&quot;, &quot;kawaisprite&quot;, &quot;evilsk8er&quot;]), 3 =&gt; new IntroText([&quot;ninjamuffin99&quot;, &quot;phantomArcade&quot;, &quot;kawaisprite&quot;, &quot;evilsk8er&quot;, &quot;present&quot;]), 4 =&gt; new IntroText(), 5 =&gt; new IntroText([&quot;In association&quot;, &quot;with&quot;]), 7 =&gt; new IntroText([&quot;In association&quot;, &quot;with&quot;, &quot;newgrounds&quot;, { name : &quot;newgroundsLogo&quot;, path : &quot;menus/titlescreen/newgrounds_logo&quot;, scale : 0.8 }]), 8 =&gt; new IntroText(), 9 =&gt; new IntroText([&quot;{introText1}&quot;]), 11 =&gt; new IntroText([&quot;{introText1}&quot;, &quot;{introText2}&quot;]), 12 =&gt; new IntroText(), 13 =&gt; new IntroText([&quot;Friday&quot;]), 14 =&gt; new IntroText([&quot;Friday&quot;, &quot;Night&quot;]), 15 =&gt; new IntroText([&quot;Friday&quot;, &quot;Night&quot;, &quot;Funkin'&quot;])]">
			<t path="Map">
				<x path="Int"/>
				<c path="funkin.menus.IntroText"/>
			</t>
			<meta><m n=":value"><e>[1 =&gt; new IntroText(["ninjamuffin99", "phantomArcade", "kawaisprite", "evilsk8er"]), 3 =&gt; new IntroText(["ninjamuffin99", "phantomArcade", "kawaisprite", "evilsk8er", "present"]), 4 =&gt; new IntroText(), 5 =&gt; new IntroText(["In association", "with"]), 7 =&gt; new IntroText(["In association", "with", "newgrounds", { name : "newgroundsLogo", path : "menus/titlescreen/newgrounds_logo", scale : 0.8 }]), 8 =&gt; new IntroText(), 9 =&gt; new IntroText(["{introText1}"]), 11 =&gt; new IntroText(["{introText1}", "{introText2}"]), 12 =&gt; new IntroText(), 13 =&gt; new IntroText(["Friday"]), 14 =&gt; new IntroText(["Friday", "Night"]), 15 =&gt; new IntroText(["Friday", "Night", "Funkin'"])]</e></m></meta>
		</titleLines>
		<loadXML public="1" set="method" line="270"><f a=""><x path="Void"/></f></loadXML>
		<skippedIntro expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skippedIntro>
		<skipIntro public="1" set="method" line="328"><f a=""><x path="Void"/></f></skipIntro>
		<new public="1" set="method" line="17"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.backend.assets.ModsFolder</e></m>
			<m n=":allow"><e>funkin.backend.system.MainState</e></m>
		</meta>
	</class>
	<class path="funkin.menus.IntroText" params="" file="source/funkin/menus/TitleState.hx" module="funkin.menus.TitleState">
		<lines public="1" expr="[]">
			<c path="Array"><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="String"/>
	<t path="funkin.menus.TitleStateImage"/>
</x></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</lines>
		<show public="1" set="method" line="351"><f a=""><x path="Void"/></f></show>
		<new public="1" set="method" line="347"><f a="?lines">
	<c path="Array"><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="String"/>
	<t path="funkin.menus.TitleStateImage"/>
</x></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.menus.TitleStateImage" params="" file="source/funkin/menus/TitleState.hx" module="funkin.menus.TitleState"><a>
	<scale>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</scale>
	<path><c path="String"/></path>
	<name><c path="String"/></name>
	<flipY>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</flipY>
	<flipX>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</flipX>
</a></typedef>
	<class path="funkin.menus.credits.CreditsCodename" params="" file="source/funkin/menus/credits/CreditsCodename.hx">
		<extends path="funkin.options.OptionsScreen"/>
		<error public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</error>
		<author public="1" expr="&quot;FNF-CNE-Devs&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"FNF-CNE-Devs"</e></m></meta>
		</author>
		<totalContributions public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</totalContributions>
		<mainDevCol public="1" expr="0xFF9C35D5">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFF9C35D5</e></m></meta>
		</mainDevCol>
		<minContrCol public="1" expr="0xFFB4A7DA">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFFB4A7DA</e></m></meta>
		</minContrCol>
		<contribFormats public="1" expr="[]">
			<c path="Array"><c path="flixel.text.FlxTextFormatMarkerPair"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</contribFormats>
		<_canReset expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</_canReset>
		<_downloadingSteps expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_downloadingSteps>
		<update public="1" set="method" line="29" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<tryUpdating public="1" set="method" line="44">
			<f a="?forceDisplaying" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceDisplaying : false }</e></m></meta>
		</tryUpdating>
		<updateMenuDesc public="1" set="method" line="53" override="1"><f a="?txt">
	<c path="String"/>
	<x path="Void"/>
</f></updateMenuDesc>
		<updateMarkup public="1" set="method" line="59"><f a=""><x path="Void"/></f></updateMarkup>
		<close public="1" set="method" line="69" override="1"><f a=""><x path="Void"/></f></close>
		<checkUpdate public="1" set="method" line="74"><f a=""><x path="Bool"/></f></checkUpdate>
		<displayList public="1" set="method" line="105"><f a=""><x path="Void"/></f></displayList>
		<new public="1" set="method" line="20"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.credits.CreditsMain" params="" file="source/funkin/menus/credits/CreditsMain.hx">
		<extends path="funkin.options.TreeMenu"/>
		<bg><c path="flixel.FlxSprite"/></bg>
		<items expr="[]">
			<c path="Array"><c path="funkin.options.type.OptionType"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</items>
		<create public="1" set="method" line="13" override="1"><f a=""><x path="Void"/></f></create>
		<parseCreditsFromXML public="1" set="method" line="54">
			<f a="xml:source">
				<x path="haxe.xml.Access"/>
				<x path="Bool"/>
				<c path="Array"><c path="funkin.options.type.OptionType"/></c>
			</f>
			<haxe_doc>* XML STUFF</haxe_doc>
		</parseCreditsFromXML>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.ui.Alphabet" params="" file="source/funkin/menus/ui/Alphabet.hx">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<delay public="1" expr="0.05">
			<x path="Float"/>
			<meta><m n=":value"><e>0.05</e></m></meta>
		</delay>
		<paused public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</paused>
		<targetY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</targetY>
		<isMenuItem public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isMenuItem>
		<text public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</text>
		<_finalText expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</_finalText>
		<_curText expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</_curText>
		<yMulti expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</yMulti>
		<lastSprite><c path="funkin.menus.ui.AlphaCharacter"/></lastSprite>
		<xPosResetted expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</xPosResetted>
		<splitWords expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</splitWords>
		<isBold expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isBold>
		<set_color set="method" line="41" override="1"><f a="c">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<refreshAlphabetXML public="1" set="method" line="52"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></refreshAlphabetXML>
		<addText public="1" set="method" line="125"><f a=""><x path="Void"/></f></addText>
		<doSplitWords set="method" line="152"><f a=""><x path="Void"/></f></doSplitWords>
		<startTypedText public="1" set="method" line="159"><f a=""><x path="Void"/></f></startTypedText>
		<update public="1" set="method" line="187" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="80">
			<f a="x:y:?text:?bold:?typed" v="::&quot;&quot;:false:false">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ typed : false, bold : false, text : "" }</e></m></meta>
		</new>
		<haxe_doc>* Loosely based on FlxTypeText lolol</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.ui.AlphaCharacter" params="" file="source/funkin/menus/ui/Alphabet.hx" module="funkin.menus.ui.Alphabet">
		<extends path="flixel.FlxSprite"/>
		<__alphaPath public="1" expr="null" line="211" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__alphaPath>
		<letterAlphabetPath public="1" static="1"><c path="String"/></letterAlphabetPath>
		<boldAlphabetPath public="1" static="1"><c path="String"/></boldAlphabetPath>
		<boldAnims public="1" expr="[]" line="216" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</boldAnims>
		<letterAnims public="1" expr="[]" line="217" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</letterAnims>
		<row public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</row>
		<setColor public="1" set="method" line="221"><f a="c:isBold">
	<x path="flixel.util.FlxColor"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setColor>
		<createBold public="1" set="method" line="240"><f a="letter">
	<c path="String"/>
	<x path="Void"/>
</f></createBold>
		<createLetter public="1" set="method" line="257"><f a="letter">
	<c path="String"/>
	<x path="Void"/>
</f></createLetter>
		<new public="1" set="method" line="232"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.Options" params="" file="source/funkin/options/Options.hx">
		<__save public="1" static="1">
			<c path="flixel.util.FlxSave"/>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":doNotSave"/>
			</meta>
		</__save>
		<__eventAdded expr="false" line="14" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":dox"><e>hide</e></m>
				<m n=":doNotSave"/>
			</meta>
		</__eventAdded>
		<naughtyness public="1" expr="true" line="19" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* SETTINGS</haxe_doc>
		</naughtyness>
		<downscroll public="1" expr="false" line="20" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</downscroll>
		<ghostTapping public="1" expr="true" line="21" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</ghostTapping>
		<flashingMenu public="1" expr="true" line="22" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</flashingMenu>
		<camZoomOnBeat public="1" expr="true" line="23" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</camZoomOnBeat>
		<fpsCounter public="1" expr="true" line="24" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</fpsCounter>
		<autoPause public="1" expr="true" line="25" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoPause>
		<antialiasing public="1" expr="true" line="26" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</antialiasing>
		<volume public="1" expr="1" line="27" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</volume>
		<week6PixelPerfect public="1" expr="true" line="28" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</week6PixelPerfect>
		<gameplayShaders public="1" expr="true" line="29" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</gameplayShaders>
		<colorHealthBar public="1" expr="true" line="30" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</colorHealthBar>
		<lowMemoryMode public="1" expr="false" line="31" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</lowMemoryMode>
		<betaUpdates public="1" expr="false" line="32" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</betaUpdates>
		<splashesEnabled public="1" expr="true" line="33" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</splashesEnabled>
		<hitWindow public="1" expr="250" line="34" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>250</e></m></meta>
		</hitWindow>
		<songOffset public="1" expr="0" line="35" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</songOffset>
		<framerate public="1" expr="120" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</framerate>
		<gpuOnlyBitmaps public="1" expr="true" line="37" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</gpuOnlyBitmaps>
		<lastLoadedMod public="1" expr="null" line="39" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastLoadedMod>
		<intensiveBlur public="1" expr="true" line="44" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* EDITORS SETTINGS</haxe_doc>
		</intensiveBlur>
		<editorSFX public="1" expr="true" line="45" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</editorSFX>
		<editorPrettyPrint public="1" expr="false" line="46" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</editorPrettyPrint>
		<maxUndos public="1" expr="120" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</maxUndos>
		<freeplayLastSong public="1" expr="null" line="52" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* QOL FEATURES</haxe_doc>
		</freeplayLastSong>
		<freeplayLastDifficulty public="1" expr="&quot;normal&quot;" line="53" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"normal"</e></m></meta>
		</freeplayLastDifficulty>
		<contributors public="1" expr="[]" line="54" static="1">
			<c path="Array"><t path="funkin.backend.system.github.GitHubContributor"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</contributors>
		<mainDevs public="1" expr="[]" line="55" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</mainDevs>
		<lastUpdated public="1" static="1"><x path="Null"><x path="Float"/></x></lastUpdated>
		<charterMetronomeEnabled public="1" expr="false" line="61" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* CHARTER</haxe_doc>
		</charterMetronomeEnabled>
		<charterShowSections public="1" expr="true" line="62" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</charterShowSections>
		<charterShowBeats public="1" expr="true" line="63" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</charterShowBeats>
		<charterEnablePlaytestScripts public="1" expr="true" line="64" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</charterEnablePlaytestScripts>
		<charterLowDetailWaveforms public="1" expr="false" line="65" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</charterLowDetailWaveforms>
		<charterAutoSaves public="1" expr="true" line="66" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</charterAutoSaves>
		<charterAutoSaveTime public="1" expr="60 * 5" line="67" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>60 * 5</e></m></meta>
		</charterAutoSaveTime>
		<charterAutoSaveWarningTime public="1" expr="5" line="68" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</charterAutoSaveWarningTime>
		<charterAutoSavesSeperateFolder public="1" expr="false" line="69" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</charterAutoSavesSeperateFolder>
		<P1_NOTE_LEFT public="1" expr="[A]" line="74" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[A]</e></m></meta>
			<haxe_doc>* PLAYER 1 CONTROLS</haxe_doc>
		</P1_NOTE_LEFT>
		<P1_NOTE_DOWN public="1" expr="[S]" line="75" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[S]</e></m></meta>
		</P1_NOTE_DOWN>
		<P1_NOTE_UP public="1" expr="[W]" line="76" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[W]</e></m></meta>
		</P1_NOTE_UP>
		<P1_NOTE_RIGHT public="1" expr="[D]" line="77" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[D]</e></m></meta>
		</P1_NOTE_RIGHT>
		<P1_LEFT public="1" expr="[A]" line="78" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[A]</e></m></meta>
		</P1_LEFT>
		<P1_DOWN public="1" expr="[S]" line="79" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[S]</e></m></meta>
		</P1_DOWN>
		<P1_UP public="1" expr="[W]" line="80" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[W]</e></m></meta>
		</P1_UP>
		<P1_RIGHT public="1" expr="[D]" line="81" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[D]</e></m></meta>
		</P1_RIGHT>
		<P1_ACCEPT public="1" expr="[ENTER]" line="82" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[ENTER]</e></m></meta>
		</P1_ACCEPT>
		<P1_BACK public="1" expr="[BACKSPACE]" line="83" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[BACKSPACE]</e></m></meta>
		</P1_BACK>
		<P1_PAUSE public="1" expr="[ENTER]" line="84" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[ENTER]</e></m></meta>
		</P1_PAUSE>
		<P1_RESET public="1" expr="[R]" line="85" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[R]</e></m></meta>
		</P1_RESET>
		<P1_SWITCHMOD public="1" expr="[TAB]" line="86" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[TAB]</e></m></meta>
		</P1_SWITCHMOD>
		<P2_NOTE_LEFT public="1" expr="[LEFT]" line="91" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[LEFT]</e></m></meta>
			<haxe_doc>* PLAYER 2 CONTROLS (ALT)</haxe_doc>
		</P2_NOTE_LEFT>
		<P2_NOTE_DOWN public="1" expr="[DOWN]" line="92" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[DOWN]</e></m></meta>
		</P2_NOTE_DOWN>
		<P2_NOTE_UP public="1" expr="[UP]" line="93" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[UP]</e></m></meta>
		</P2_NOTE_UP>
		<P2_NOTE_RIGHT public="1" expr="[RIGHT]" line="94" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[RIGHT]</e></m></meta>
		</P2_NOTE_RIGHT>
		<P2_LEFT public="1" expr="[LEFT]" line="95" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[LEFT]</e></m></meta>
		</P2_LEFT>
		<P2_DOWN public="1" expr="[DOWN]" line="96" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[DOWN]</e></m></meta>
		</P2_DOWN>
		<P2_UP public="1" expr="[UP]" line="97" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[UP]</e></m></meta>
		</P2_UP>
		<P2_RIGHT public="1" expr="[RIGHT]" line="98" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[RIGHT]</e></m></meta>
		</P2_RIGHT>
		<P2_ACCEPT public="1" expr="[SPACE]" line="99" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[SPACE]</e></m></meta>
		</P2_ACCEPT>
		<P2_BACK public="1" expr="[ESCAPE]" line="100" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[ESCAPE]</e></m></meta>
		</P2_BACK>
		<P2_PAUSE public="1" expr="[ESCAPE]" line="101" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[ESCAPE]</e></m></meta>
		</P2_PAUSE>
		<P2_RESET public="1" expr="[]" line="102" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</P2_RESET>
		<P2_SWITCHMOD public="1" expr="[]" line="103" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</P2_SWITCHMOD>
		<SOLO_NOTE_LEFT public="1" get="accessor" set="null" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<haxe_doc>* SOLO GETTERS</haxe_doc>
		</SOLO_NOTE_LEFT>
		<SOLO_NOTE_DOWN public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_NOTE_DOWN>
		<SOLO_NOTE_UP public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_NOTE_UP>
		<SOLO_NOTE_RIGHT public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_NOTE_RIGHT>
		<SOLO_LEFT public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_LEFT>
		<SOLO_DOWN public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_DOWN>
		<SOLO_UP public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_UP>
		<SOLO_RIGHT public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_RIGHT>
		<SOLO_ACCEPT public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_ACCEPT>
		<SOLO_BACK public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_BACK>
		<SOLO_PAUSE public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_PAUSE>
		<SOLO_RESET public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_RESET>
		<SOLO_SWITCHMOD public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_SWITCHMOD>
		<load public="1" set="method" line="122" static="1"><f a=""><x path="Void"/></f></load>
		<applySettings public="1" set="method" line="138" static="1"><f a=""><x path="Void"/></f></applySettings>
		<applyKeybinds public="1" set="method" line="145" static="1"><f a=""><x path="Void"/></f></applyKeybinds>
		<save public="1" set="method" line="151" static="1"><f a=""><x path="Void"/></f></save>
		<get_SOLO_NOTE_LEFT get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_NOTE_LEFT>
		<get_SOLO_NOTE_DOWN get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_NOTE_DOWN>
		<get_SOLO_NOTE_UP get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_NOTE_UP>
		<get_SOLO_NOTE_RIGHT get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_NOTE_RIGHT>
		<get_SOLO_LEFT get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_LEFT>
		<get_SOLO_DOWN get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_DOWN>
		<get_SOLO_UP get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_UP>
		<get_SOLO_RIGHT get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_RIGHT>
		<get_SOLO_ACCEPT get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_ACCEPT>
		<get_SOLO_BACK get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_BACK>
		<get_SOLO_PAUSE get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_PAUSE>
		<get_SOLO_RESET get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_RESET>
		<get_SOLO_SWITCHMOD get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_SWITCHMOD>
		<__flush public="1" set="method" line="8" static="1"><f a=""><x path="Void"/></f></__flush>
		<__load public="1" set="method" line="8" static="1"><f a=""><x path="Void"/></f></__load>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.OptionsMacro.build()</e></m>
			<m n=":build"><e>funkin.backend.system.macros.FunkinSaveMacro.build("__save", "__flush", "__load")</e></m>
		</meta>
	</class>
	<class path="funkin.options.keybinds.KeybindsOptions" params="" file="source/funkin/options/keybinds/KeybindsOptions.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<instance public="1" static="1"><c path="funkin.options.keybinds.KeybindsOptions"/></instance>
		<categories public="1" expr="[{ name : &quot;Notes&quot;, settings : [{ name : &quot;{noteLeft}&quot;, control : &quot;NOTE_LEFT&quot; }, { name : &quot;{noteDown}&quot;, control : &quot;NOTE_DOWN&quot; }, { name : &quot;{noteUp}&quot;, control : &quot;NOTE_UP&quot; }, { name : &quot;{noteRight}&quot;, control : &quot;NOTE_RIGHT&quot; }] }, { name : &quot;UI&quot;, settings : [{ name : &quot;Left&quot;, control : &quot;LEFT&quot; }, { name : &quot;Down&quot;, control : &quot;DOWN&quot; }, { name : &quot;Up&quot;, control : &quot;UP&quot; }, { name : &quot;Right&quot;, control : &quot;RIGHT&quot; }, { name : &quot;Accept&quot;, control : &quot;ACCEPT&quot; }, { name : &quot;Back&quot;, control : &quot;BACK&quot; }, { name : &quot;Reset&quot;, control : &quot;RESET&quot; }, { name : &quot;Pause&quot;, control : &quot;PAUSE&quot; }] }, { name : &quot;Engine&quot;, settings : [{ name : &quot;Switch Mod&quot;, control : &quot;SWITCHMOD&quot; }] }]">
			<c path="Array"><a>
	<settings><c path="Array"><a>
	<name><c path="String"/></name>
	<control><c path="String"/></control>
</a></c></settings>
	<name><c path="String"/></name>
</a></c>
			<meta><m n=":value"><e>[{ name : "Notes", settings : [{ name : "{noteLeft}", control : "NOTE_LEFT" }, { name : "{noteDown}", control : "NOTE_DOWN" }, { name : "{noteUp}", control : "NOTE_UP" }, { name : "{noteRight}", control : "NOTE_RIGHT" }] }, { name : "UI", settings : [{ name : "Left", control : "LEFT" }, { name : "Down", control : "DOWN" }, { name : "Up", control : "UP" }, { name : "Right", control : "RIGHT" }, { name : "Accept", control : "ACCEPT" }, { name : "Back", control : "BACK" }, { name : "Reset", control : "RESET" }, { name : "Pause", control : "PAUSE" }] }, { name : "Engine", settings : [{ name : "Switch Mod", control : "SWITCHMOD" }] }]</e></m></meta>
		</categories>
		<settingCam public="1"><c path="flixel.FlxCamera"/></settingCam>
		<p2Selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</p2Selected>
		<curSelected public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSelected>
		<canSelect public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</canSelect>
		<alphabets public="1"><c path="flixel.group.FlxTypedGroup"><c path="funkin.options.keybinds.KeybindSetting"/></c></alphabets>
		<bg public="1"><c path="flixel.FlxSprite"/></bg>
		<coloredBG public="1"><c path="flixel.FlxSprite"/></coloredBG>
		<noteColors public="1" expr="[0xFFC24B99, 0xFF00FFFF, 0xFF12FA05, 0xFFF9393F]">
			<c path="Array"><x path="flixel.util.FlxColor"/></c>
			<meta><m n=":value"><e>[0xFFC24B99, 0xFF00FFFF, 0xFF12FA05, 0xFFF9393F]</e></m></meta>
		</noteColors>
		<camFollow public="1" expr="new FlxObject(0, 0, 2, 2)">
			<c path="flixel.FlxObject"/>
			<meta><m n=":value"><e>new FlxObject(0, 0, 2, 2)</e></m></meta>
		</camFollow>
		<isSubState expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isSubState>
		<create public="1" set="method" line="98" override="1"><f a=""><x path="Void"/></f></create>
		<destroy public="1" set="method" line="167" override="1"><f a=""><x path="Void"/></f></destroy>
		<skipThisFrame expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</skipThisFrame>
		<update public="1" set="method" line="175" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<changeSelection public="1" set="method" line="232"><f a="change">
	<x path="Int"/>
	<x path="Void"/>
</f></changeSelection>
		<new public="1" set="method" line="7"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.categories.GameplayOptions" params="" file="source/funkin/options/categories/GameplayOptions.hx">
		<extends path="funkin.options.OptionsScreen"/>
		<__metronome expr="FlxG.sound.load(Paths.sound(&quot;editors/charter/metronome&quot;))">
			<c path="flixel.sound.FlxSound"/>
			<meta><m n=":value"><e>FlxG.sound.load(Paths.sound("editors/charter/metronome"))</e></m></meta>
		</__metronome>
		<offsetSetting><c path="funkin.options.type.NumOption"/></offsetSetting>
		<__changeOffset set="method" line="40"><f a="offset">
	<x path="Float"/>
	<x path="Void"/>
</f></__changeOffset>
		<__lastBeat expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__lastBeat>
		<__lastSongBeat expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__lastSongBeat>
		<update public="1" set="method" line="45" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<close public="1" set="method" line="65" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.categories.AppearanceOptions" params="" file="source/funkin/options/categories/AppearanceOptions.hx">
		<extends path="funkin.options.OptionsScreen"/>
		<__changeFPS set="method" line="52"><f a="change">
	<x path="Float"/>
	<x path="Void"/>
</f></__changeFPS>
		<new public="1" set="method" line="4"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.categories.MiscOptions" params="" file="source/funkin/options/categories/MiscOptions.hx">
		<extends path="funkin.options.OptionsScreen"/>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.OptionsMenu" params="" file="source/funkin/options/OptionsMenu.hx">
		<extends path="funkin.options.TreeMenu"/>
		<mainOptions public="1" expr="[{ name : &quot;Controls&quot;, desc : &quot;Change Controls for Player 1 and Player 2!&quot;, state : null, substate : funkin.options.keybinds.KeybindsOptions }, { name : &quot;Gameplay &gt;&quot;, desc : &quot;Change Gameplay options such as Downscroll, Scroll Speed, Naughtyness...&quot;, state : GameplayOptions }, { name : &quot;Appearance &gt;&quot;, desc : &quot;Change Appearance options such as Flashing menus...&quot;, state : AppearanceOptions }, { name : &quot;Miscellaneous &gt;&quot;, desc : &quot;Use this menu to reset save data or engine settings.&quot;, state : MiscOptions }]" line="10" static="1">
			<c path="Array"><t path="funkin.options.OptionCategory"/></c>
			<meta><m n=":value"><e>[{ name : "Controls", desc : "Change Controls for Player 1 and Player 2!", state : null, substate : funkin.options.keybinds.KeybindsOptions }, { name : "Gameplay &gt;", desc : "Change Gameplay options such as Downscroll, Scroll Speed, Naughtyness...", state : GameplayOptions }, { name : "Appearance &gt;", desc : "Change Appearance options such as Flashing menus...", state : AppearanceOptions }, { name : "Miscellaneous &gt;", desc : "Use this menu to reset save data or engine settings.", state : MiscOptions }]</e></m></meta>
		</mainOptions>
		<create public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></create>
		<exit public="1" set="method" line="86" override="1"><f a=""><x path="Void"/></f></exit>
		<parseOptionsFromXML public="1" set="method" line="95">
			<f a="xml">
				<x path="haxe.xml.Access"/>
				<c path="Array"><c path="funkin.options.type.OptionType"/></c>
			</f>
			<haxe_doc>* XML STUFF</haxe_doc>
		</parseOptionsFromXML>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.OptionsTree" params="" file="source/funkin/options/OptionsTree.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.options.OptionsScreen"/></extends>
		<lastMenu public="1"><c path="funkin.options.OptionsScreen"/></lastMenu>
		<treeParent public="1"><c path="funkin.options.TreeMenu"/></treeParent>
		<update public="1" set="method" line="10" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="17" override="1"><f a=""><x path="Void"/></f></draw>
		<add public="1" set="method" line="24" override="1"><f a="m">
	<c path="funkin.options.OptionsScreen"/>
	<c path="funkin.options.OptionsScreen"/>
</f></add>
		<insert public="1" set="method" line="31" override="1"><f a="pos:m">
	<x path="Int"/>
	<c path="funkin.options.OptionsScreen"/>
	<c path="funkin.options.OptionsScreen"/>
</f></insert>
		<setup public="1" set="method" line="40"><f a="m">
	<c path="funkin.options.OptionsScreen"/>
	<x path="Void"/>
</f></setup>
		<__subMenuClose set="method" line="47"><f a="m">
	<c path="funkin.options.OptionsScreen"/>
	<x path="Void"/>
</f></__subMenuClose>
		<clearLastMenu public="1" set="method" line="55"><f a=""><x path="Void"/></f></clearLastMenu>
		<destroy public="1" set="method" line="59" override="1"><f a=""><x path="Void"/></f></destroy>
		<onMenuChange public="1" set="dynamic" line="64"><f a=""><x path="Void"/></f></onMenuChange>
		<onMenuClose public="1" set="dynamic" line="68"><f a="m">
	<c path="funkin.options.OptionsScreen"/>
	<x path="Void"/>
</f></onMenuClose>
		<new public="1" set="method" line="3"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.PlayerSettings" params="" file="source/funkin/options/PlayerSettings.hx">
		<numPlayers public="1" set="null" expr="0" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numPlayers>
		<numAvatars public="1" set="null" expr="0" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numAvatars>
		<solo public="1" set="null" static="1"><c path="funkin.options.PlayerSettings"/></solo>
		<player1 public="1" set="null" static="1"><c path="funkin.options.PlayerSettings"/></player1>
		<player2 public="1" set="null" static="1"><c path="funkin.options.PlayerSettings"/></player2>
		<onAvatarAdd final="1" public="1" set="null" expr="new FlxTypedSignal&lt;PlayerSettings&gt;()" line="17" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="funkin.options.PlayerSettings"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;PlayerSettings&gt;()</e></m></meta>
		</onAvatarAdd>
		<onAvatarRemove final="1" public="1" set="null" expr="new FlxTypedSignal&lt;PlayerSettings&gt;()" line="18" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="funkin.options.PlayerSettings"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;PlayerSettings&gt;()</e></m></meta>
		</onAvatarRemove>
		<init public="1" set="method" line="44" static="1"><f a=""><x path="Void"/></f></init>
		<reset public="1" set="method" line="89" static="1"><f a=""><x path="Void"/></f></reset>
		<id public="1" set="null"><x path="Int"/></id>
		<controls final="1" public="1"><c path="funkin.backend.system.Controls"/></controls>
		<setKeyboardScheme public="1" set="method" line="39"><f a="scheme">
	<e path="funkin.backend.system.KeyboardScheme"/>
	<x path="Void"/>
</f></setKeyboardScheme>
		<new set="method" line="33"><f a="id:scheme">
	<x path="Int"/>
	<e path="funkin.backend.system.KeyboardScheme"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.options.OptionCategory" params="" file="source/funkin/options/TreeMenu.hx" module="funkin.options.TreeMenu"><a>
	<substate>
		<x path="Null"><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="funkin.backend.MusicBeatSubstate"/>
	<x path="Class"><c path="funkin.backend.MusicBeatSubstate"/></x>
</x></x>
		<meta><m n=":optional"/></meta>
	</substate>
	<state><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="funkin.options.OptionsScreen"/>
	<x path="Class"><c path="funkin.options.OptionsScreen"/></x>
</x></state>
	<name><c path="String"/></name>
	<desc><c path="String"/></desc>
</a></typedef>
	<typedef path="funkin.options.OptionTypeDef" params="" file="source/funkin/options/TreeMenu.hx" module="funkin.options.TreeMenu"><a>
	<type><x path="Class"><c path="funkin.options.type.OptionType"/></x></type>
	<args><c path="Array"><d/></c></args>
</a></typedef>
	<class path="funkin.options.keybinds.ChangeKeybindSubState" params="" file="source/funkin/options/keybinds/ChangeKeybindSubState.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<callback><f a="">
	<x path="flixel.input.keyboard.FlxKey"/>
	<x path="Void"/>
</f></callback>
		<cancelCallback><f a=""><x path="Void"/></f></cancelCallback>
		<stillPressed expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</stillPressed>
		<update public="1" set="method" line="16" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="10"><f a="callback:cancelCallback">
	<f a="">
		<x path="flixel.input.keyboard.FlxKey"/>
		<x path="Void"/>
	</f>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.keybinds.KeybindSetting" params="" file="source/funkin/options/keybinds/KeybindSetting.hx">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<title public="1"><c path="funkin.menus.ui.Alphabet"/></title>
		<bind1 public="1"><c path="funkin.menus.ui.Alphabet"/></bind1>
		<bind2 public="1"><c path="funkin.menus.ui.Alphabet"/></bind2>
		<icon public="1"><c path="flixel.FlxSprite"/></icon>
		<changingKeybind public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</changingKeybind>
		<p2Selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</p2Selected>
		<value public="1"><c path="String"/></value>
		<option1 public="1"><x path="Null"><x path="flixel.input.keyboard.FlxKey"/></x></option1>
		<option2 public="1"><x path="Null"><x path="flixel.input.keyboard.FlxKey"/></x></option2>
		<update public="1" set="method" line="62" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<changeKeybind public="1" set="method" line="70">
			<f a="callback:cancelCallback:?p2" v="::false">
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ p2 : false }</e></m></meta>
		</changeKeybind>
		<updateText public="1" set="method" line="96"><f a=""><x path="Void"/></f></updateText>
		<new public="1" set="method" line="20"><f a="x:y:name:value:?sparrowIcon:?sparrowAnim">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.OptionType" params="" file="source/funkin/options/type/OptionType.hx">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<controls public="1" get="accessor" set="null"><c path="funkin.backend.system.Controls"/></controls>
		<selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selected>
		<desc public="1"><c path="String"/></desc>
		<get_controls set="method" line="16"><f a=""><c path="funkin.backend.system.Controls"/></f></get_controls>
		<onSelect public="1" set="method" line="18"><f a=""><x path="Void"/></f></onSelect>
		<onChangeSelection public="1" set="method" line="20"><f a="change">
	<x path="Float"/>
	<x path="Void"/>
</f></onChangeSelection>
		<update public="1" set="method" line="22" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="11"><f a="desc">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="funkin.options.type.ArrayOption" params="" file="source/funkin/options/type/ArrayOption.hx">
		<extends path="funkin.options.type.OptionType"/>
		<selectCallback public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></selectCallback>
		<__text><c path="funkin.menus.ui.Alphabet"/></__text>
		<__selectiontext><c path="funkin.menus.ui.Alphabet"/></__selectiontext>
		<options public="1"><c path="Array"><d/></c></options>
		<displayOptions public="1"><c path="Array"><c path="String"/></c></displayOptions>
		<currentSelection public="1"><x path="Int"/></currentSelection>
		<optionName><c path="String"/></optionName>
		<parent public="1"><d/></parent>
		<text public="1" get="accessor" set="accessor"><c path="String"/></text>
		<get_text set="method" line="19"><f a=""><c path="String"/></f></get_text>
		<set_text set="method" line="20"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<draw public="1" set="method" line="42" override="1"><f a=""><x path="Void"/></f></draw>
		<onChangeSelection public="1" set="method" line="47" override="1"><f a="change">
	<x path="Float"/>
	<x path="Void"/>
</f></onChangeSelection>
		<formatTextOption set="method" line="56"><f a=""><c path="String"/></f></formatTextOption>
		<new public="1" set="method" line="22">
			<f a="text:desc:options:displayOptions:optionName:?selectCallback:?parent" v=":::::null:">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
				<f a="">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ selectCallback : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.TextOption" params="" file="source/funkin/options/type/TextOption.hx">
		<extends path="funkin.options.type.OptionType"/>
		<selectCallback public="1"><f a=""><x path="Void"/></f></selectCallback>
		<__text><c path="funkin.menus.ui.Alphabet"/></__text>
		<text public="1" get="accessor" set="accessor"><c path="String"/></text>
		<get_text set="method" line="11"><f a=""><c path="String"/></f></get_text>
		<set_text set="method" line="12"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<draw public="1" set="method" line="20" override="1"><f a=""><x path="Void"/></f></draw>
		<onSelect public="1" set="method" line="23" override="1"><f a=""><x path="Void"/></f></onSelect>
		<new public="1" set="method" line="14"><f a="text:desc:selectCallback">
	<c path="String"/>
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.Checkbox" params="" file="source/funkin/options/type/Checkbox.hx">
		<extends path="funkin.options.type.TextOption"/>
		<checkbox public="1"><c path="flixel.FlxSprite"/></checkbox>
		<checked public="1"><x path="Bool"/></checked>
		<parent public="1"><d/></parent>
		<get_selected set="method" line="12"><f a=""><x path="Void"/></f></get_selected>
		<optionName public="1"><c path="String"/></optionName>
		<offsets expr="[&quot;checked&quot; =&gt; FlxPoint.get(1, -1), &quot;unchecked&quot; =&gt; FlxPoint.get(-12, -72), &quot;checking&quot; =&gt; FlxPoint.get(12, 30)]">
			<t path="Map">
				<c path="String"/>
				<x path="flixel.math.FlxPoint"/>
			</t>
			<meta><m n=":value"><e>["checked" =&gt; FlxPoint.get(1, -1), "unchecked" =&gt; FlxPoint.get(-12, -72), "checking" =&gt; FlxPoint.get(12, 30)]</e></m></meta>
		</offsets>
		<baseCheckboxOffset expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</baseCheckboxOffset>
		<update public="1" set="method" line="48" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<onSelect public="1" set="method" line="60" override="1"><f a=""><x path="Void"/></f></onSelect>
		<destroy public="1" set="method" line="65" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="24"><f a="text:desc:optionName:?parent">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.IconOption" params="" file="source/funkin/options/type/IconOption.hx">
		<extends path="funkin.options.type.TextOption"/>
		<iconSpr public="1"><c path="funkin.game.HealthIcon"/></iconSpr>
		<new public="1" set="method" line="8"><f a="name:desc:icon:callback">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.EditorIconOption" params="" file="source/funkin/options/type/EditorIconOption.hx">
		<extends path="funkin.options.type.IconOption"/>
		<flashColor public="1"><x path="flixel.util.FlxColor"/></flashColor>
		<new public="1" set="method" line="8">
			<f a="name:desc:icon:callback:?flashColor" v="::::0">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="flixel.util.FlxColor"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ flashColor : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.GithubIconOption" params="" file="source/funkin/options/type/GithubIconOption.hx">
		<extends path="funkin.options.type.TextOption"/>
		<user public="1" set="null"><d/></user>
		<icon public="1" expr="null">
			<c path="funkin.options.type.GithubUserIcon"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</icon>
		<usePortrait public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</usePortrait>
		<set_usePortrait public="1" set="method" line="16"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_usePortrait>
		<new public="1" set="method" line="22">
			<f a="user:desc:?callback:?customName:?size:?usePortrait:?waitUntilLoad" v="::::96:true:0.25">
				<d/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ waitUntilLoad : 0.25, usePortrait : true, size : 96 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.GithubUserIcon" params="" file="source/funkin/options/type/GithubIconOption.hx" module="funkin.options.type.GithubIconOption">
		<extends path="flixel.FlxSprite"/>
		<waitUntilLoad public="1"><x path="Null"><x path="Float"/></x></waitUntilLoad>
		<user><d/></user>
		<size><x path="Int"/></size>
		<update public="1" set="method" line="46" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<mutex final="1" expr="new sys.thread.Mutex()">
			<c path="sys.thread.Mutex"/>
			<meta><m n=":value"><e>new sys.thread.Mutex()</e></m></meta>
		</mutex>
		<drawComplex set="method" line="52" override="1"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></drawComplex>
		<updateDaFunni public="1" get="inline" set="null" line="103"><f a="graphic">
	<c path="flixel.graphics.FlxGraphic"/>
	<x path="Void"/>
</f></updateDaFunni>
		<new public="1" set="method" line="37">
			<f a="user:?size:?waitUntilLoad" v=":96:0.25">
				<d/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ waitUntilLoad : 0.25, size : 96 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.NewOption" params="" file="source/funkin/options/type/NewOption.hx">
		<extends path="funkin.options.type.TextOption"/>
		<iconSpr public="1"><c path="flixel.FlxSprite"/></iconSpr>
		<new public="1" set="method" line="9"><f a="name:desc:callback">
	<c path="String"/>
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.NumOption" params="" file="source/funkin/options/type/NumOption.hx">
		<extends path="funkin.options.type.OptionType"/>
		<selectCallback public="1"><f a="">
	<x path="Float"/>
	<x path="Void"/>
</f></selectCallback>
		<__text><c path="funkin.menus.ui.Alphabet"/></__text>
		<__number><c path="funkin.menus.ui.Alphabet"/></__number>
		<min public="1"><x path="Float"/></min>
		<max public="1"><x path="Float"/></max>
		<currentSelection public="1"><x path="Float"/></currentSelection>
		<changeVal public="1"><x path="Float"/></changeVal>
		<optionName><c path="String"/></optionName>
		<parent public="1"><d/></parent>
		<text public="1" get="accessor" set="accessor"><c path="String"/></text>
		<get_text set="method" line="22"><f a=""><c path="String"/></f></get_text>
		<set_text set="method" line="23"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<onChangeSelection public="1" set="method" line="45" override="1"><f a="change">
	<x path="Float"/>
	<x path="Void"/>
</f></onChangeSelection>
		<new public="1" set="method" line="25">
			<f a="text:desc:min:max:changeVal:optionName:?selectCallback:?parent" v="::::::null:">
				<c path="String"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<f a="">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ selectCallback : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.PortraitOption" params="" file="source/funkin/options/type/PortraitOption.hx">
		<extends path="funkin.options.type.TextOption"/>
		<portrait public="1" expr="null">
			<c path="flixel.FlxSprite"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</portrait>
		<addPortrait public="1" set="method" line="14">
			<f a="graphic:?size:?usePortrait" v=":96:true">
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ usePortrait : true, size : 96 }</e></m></meta>
		</addPortrait>
		<new public="1" set="method" line="9">
			<f a="name:desc:callback:?graphic:?size:?usePortrait" v="::::96:true">
				<c path="String"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ usePortrait : true, size : 96 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.savedata.FunkinSave" params="" file="source/funkin/savedata/FunkinSave.hx">
		<highscores public="1" expr="[]" line="14" static="1">
			<t path="Map">
				<e path="funkin.savedata.HighscoreEntry"/>
				<t path="funkin.savedata.SongScore"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</highscores>
		<__eventAdded expr="false" line="22" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":dox"><e>hide</e></m>
				<m n=":doNotSave"/>
			</meta>
			<haxe_doc>* ONLY OPEN IF YOU WANT TO EDIT FUNCTIONS RELATED TO SAVING, LOADING OR HIGHSCORES.</haxe_doc>
		</__eventAdded>
		<save public="1" static="1">
			<c path="flixel.util.FlxSave"/>
			<meta><m n=":doNotSave"/></meta>
		</save>
		<init public="1" set="method" line="26" static="1"><f a=""><x path="Void"/></f></init>
		<getSongHighscore public="1" get="inline" set="null" line="48" static="1">
			<f a="name:diff:?changes">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><e path="funkin.savedata.HighscoreChange"/></c>
				<t path="funkin.savedata.SongScore"/>
			</f>
			<haxe_doc>* Returns the high-score for a song.
	 * @param name Song name
	 * @param diff Song difficulty
	 * @param changes Changes made to that song in freeplay.</haxe_doc>
		</getSongHighscore>
		<setSongHighscore public="1" get="inline" set="null" line="53" static="1"><f a="name:diff:highscore:?changes">
	<c path="String"/>
	<c path="String"/>
	<t path="funkin.savedata.SongScore"/>
	<c path="Array"><e path="funkin.savedata.HighscoreChange"/></c>
	<x path="Bool"/>
</f></setSongHighscore>
		<getWeekHighscore public="1" get="inline" set="null" line="63" static="1"><f a="name:diff">
	<c path="String"/>
	<c path="String"/>
	<t path="funkin.savedata.SongScore"/>
</f></getWeekHighscore>
		<setWeekHighscore public="1" get="inline" set="null" line="65" static="1"><f a="name:diff:highscore">
	<c path="String"/>
	<c path="String"/>
	<t path="funkin.savedata.SongScore"/>
	<x path="Bool"/>
</f></setWeekHighscore>
		<safeGetHighscore set="method" line="73" static="1"><f a="entry">
	<e path="funkin.savedata.HighscoreEntry"/>
	<t path="funkin.savedata.SongScore"/>
</f></safeGetHighscore>
		<safeRegisterHighscore set="method" line="86" static="1"><f a="entry:highscore">
	<e path="funkin.savedata.HighscoreEntry"/>
	<t path="funkin.savedata.SongScore"/>
	<x path="Bool"/>
</f></safeRegisterHighscore>
		<flush public="1" set="method" line="12" static="1"><f a=""><x path="Void"/></f></flush>
		<load public="1" set="method" line="12" static="1"><f a=""><x path="Void"/></f></load>
		<haxe_doc>* Class used for saves WITHOUT going through the struggle of type checks
 * Just add your save variables the way you would do in the Options.hx file.
 * The macro will automatically generate the `flush` and `load` functions.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.FunkinSaveMacro.build("save", "flush", "load")</e></m>
		</meta>
	</class>
	<enum path="funkin.savedata.HighscoreEntry" params="" file="source/funkin/savedata/FunkinSave.hx" module="funkin.savedata.FunkinSave">
		<HWeekEntry a="weekName:difficulty">
			<c path="String"/>
			<c path="String"/>
		</HWeekEntry>
		<HSongEntry a="songName:difficulty:changes">
			<c path="String"/>
			<c path="String"/>
			<c path="Array"><e path="funkin.savedata.HighscoreChange"/></c>
		</HSongEntry>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="funkin.savedata.HighscoreChange" params="" file="source/funkin/savedata/FunkinSave.hx" module="funkin.savedata.FunkinSave">
		<CCoopMode/>
		<COpponentMode/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="funkin.savedata.SongScore" params="" file="source/funkin/savedata/FunkinSave.hx" module="funkin.savedata.FunkinSave"><a>
	<score><x path="Int"/></score>
	<misses><x path="Int"/></misses>
	<hits><t path="Map">
	<c path="String"/>
	<x path="Int"/>
</t></hits>
	<date><c path="String"/></date>
	<accuracy><x path="Float"/></accuracy>
</a></typedef>
	</haxe>
